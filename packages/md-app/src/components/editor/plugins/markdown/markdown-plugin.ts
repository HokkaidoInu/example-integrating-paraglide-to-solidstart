
// import { Descendant } from "@udecode/plate";
import {
	convertChildrenDeserialize,
	convertNodesSerialize,
	getPlateNodeType,
	MarkdownPlugin,
	MdParagraph,
} from "../markdown-plate-fork-new";

import { SuggestionPlugin } from "@udecode/plate-suggestion/react";
import remarkGfm from "remark-gfm";
import { sanatizeUnknownNodeStructuresInTree } from "./sanitizeUnsupported";

export const ExtendedMarkdownPlugin = MarkdownPlugin.configure({
	options: {
		disallowedNodes: [SuggestionPlugin.key],
		remarkPlugins: [
			remarkGfm as any,
			// remarkMdx,
			sanatizeUnknownNodeStructuresInTree,
			// sanitizeHtml,
		],
		rules: {
			sanitized_block_html: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			sanitized_inline_html: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			sanitized_block: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},
			frontmatter: {
				serialize: (node) => {
					return {
						type: "html",
						value: node.value,
					};
				},
				deserialize(mdastNode) {
					return mdastNode;
				},
			},

			// remove this after the pr is merged and we updated to the latest version of plate markdown plugin
			p: {
				deserialize: (node, deco, options) => {
					const isKeepLineBreak = options.splitLineBreaks;
					const children = convertChildrenDeserialize(
						node.children,
						deco,
						options
					);
					const paragraphType = getPlateNodeType("paragraph");
					const splitBlockTypes = new Set(["img"]);

					const elements: any[] = [];
					let inlineNodes: any[] = [];

					const flushInlineNodes = () => {
						if (inlineNodes.length > 0) {
							elements.push({
								children: inlineNodes,
								type: paragraphType,
							});
							inlineNodes = [];
						}
					};

					children.forEach((child, index, children) => {
						const { type } = child as { type?: string };

						if (type && splitBlockTypes.has(type)) {
							flushInlineNodes();
							elements.push(child);
						} else if (
							isKeepLineBreak &&
							"text" in child &&
							typeof child.text === "string"
						) {
							const textParts = child.text.split("\n");

							// Handle line break generated by <br>
							const isSingleLineBreak =
								child.text === "\n" && inlineNodes.length === 0;

							if (isSingleLineBreak) {
								inlineNodes.push({ ...child, text: "" });
								flushInlineNodes();

								return;
							}

							textParts.forEach((part, index, array) => {
								const isNotFirstPart = index > 0;
								const isNotLastPart = index < array.length - 1;

								// Create new paragraph for non-first parts
								if (isNotFirstPart) {
									flushInlineNodes();
								}
								// Only add non-empty text
								if (part) {
									inlineNodes.push({ ...child, text: part });
								}
								// Create paragraph break for non-last parts
								if (isNotLastPart) {
									flushInlineNodes();
								}
							});
						} else {
							// TODO remove the last br of the paragraph if the previos element is not a br

							if (
								child.text === "\n" &&
								children.length > 1 &&
								index === children.length - 1
							) {
								// no - op
								console.log("test");
							} else {
								inlineNodes.push(child);
							}
						}
					});

					flushInlineNodes();

					return elements.length === 1 ? elements[0] : elements;
				},
				serialize: (node, options) => {
					let cleanedChildren = node.children;

					if (
						node.children.length > 0 &&
						cleanedChildren[cleanedChildren.length - 1].text === "\n"
					) {
						// if the last child of the paragraph is a line breake add an additional one
						cleanedChildren.push({ text: "\n" });
					}

					cleanedChildren = cleanedChildren.map((child) => {
						if (child.text === "\n") {
							return {
								type: "break",
							} as any;
						}
						return child;
					});

					return {
						children: convertNodesSerialize(
							cleanedChildren,
							options
						) as MdParagraph["children"],
						type: "paragraph",
					};
				},
			},
		},
	},
});
