var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js
var require_typebox = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/typebox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;
    exports.Transform = Symbol.for("TypeBox.Transform");
    exports.Readonly = Symbol.for("TypeBox.Readonly");
    exports.Optional = Symbol.for("TypeBox.Optional");
    exports.Hint = Symbol.for("TypeBox.Hint");
    exports.Kind = Symbol.for("TypeBox.Kind");
    exports.PatternBoolean = "(true|false)";
    exports.PatternNumber = "(0|[1-9][0-9]*)";
    exports.PatternString = "(.*)";
    exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
    exports.PatternNumberExact = `^${exports.PatternNumber}$`;
    exports.PatternStringExact = `^${exports.PatternString}$`;
    var TypeRegistry;
    (function(TypeRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      TypeRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      TypeRegistry2.Clear = Clear;
      function Delete(kind) {
        return map.delete(kind);
      }
      TypeRegistry2.Delete = Delete;
      function Has(kind) {
        return map.has(kind);
      }
      TypeRegistry2.Has = Has;
      function Set2(kind, func) {
        map.set(kind, func);
      }
      TypeRegistry2.Set = Set2;
      function Get(kind) {
        return map.get(kind);
      }
      TypeRegistry2.Get = Get;
    })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
    var TypeBoxError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TypeBoxError = TypeBoxError;
    var FormatRegistry;
    (function(FormatRegistry2) {
      const map = /* @__PURE__ */ new Map();
      function Entries() {
        return new Map(map);
      }
      FormatRegistry2.Entries = Entries;
      function Clear() {
        return map.clear();
      }
      FormatRegistry2.Clear = Clear;
      function Delete(format) {
        return map.delete(format);
      }
      FormatRegistry2.Delete = Delete;
      function Has(format) {
        return map.has(format);
      }
      FormatRegistry2.Has = Has;
      function Set2(format, func) {
        map.set(format, func);
      }
      FormatRegistry2.Set = Set2;
      function Get(format) {
        return map.get(format);
      }
      FormatRegistry2.Get = Get;
    })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
    var ValueGuard;
    (function(ValueGuard2) {
      function IsArray(value) {
        return Array.isArray(value);
      }
      ValueGuard2.IsArray = IsArray;
      function IsBigInt(value) {
        return typeof value === "bigint";
      }
      ValueGuard2.IsBigInt = IsBigInt;
      function IsBoolean(value) {
        return typeof value === "boolean";
      }
      ValueGuard2.IsBoolean = IsBoolean;
      function IsDate(value) {
        return value instanceof globalThis.Date;
      }
      ValueGuard2.IsDate = IsDate;
      function IsNull(value) {
        return value === null;
      }
      ValueGuard2.IsNull = IsNull;
      function IsNumber(value) {
        return typeof value === "number";
      }
      ValueGuard2.IsNumber = IsNumber;
      function IsObject(value) {
        return typeof value === "object" && value !== null;
      }
      ValueGuard2.IsObject = IsObject;
      function IsString(value) {
        return typeof value === "string";
      }
      ValueGuard2.IsString = IsString;
      function IsUint8Array(value) {
        return value instanceof globalThis.Uint8Array;
      }
      ValueGuard2.IsUint8Array = IsUint8Array;
      function IsUndefined(value) {
        return value === void 0;
      }
      ValueGuard2.IsUndefined = IsUndefined;
    })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
    var TypeGuardUnknownTypeError = class extends TypeBoxError {
    };
    exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    var TypeGuard;
    (function(TypeGuard2) {
      function IsPattern(value) {
        try {
          new RegExp(value);
          return true;
        } catch {
          return false;
        }
      }
      function IsControlCharacterFree(value) {
        if (!ValueGuard.IsString(value))
          return false;
        for (let i4 = 0; i4 < value.length; i4++) {
          const code = value.charCodeAt(i4);
          if (code >= 7 && code <= 13 || code === 27 || code === 127) {
            return false;
          }
        }
        return true;
      }
      function IsAdditionalProperties(value) {
        return IsOptionalBoolean(value) || TSchema(value);
      }
      function IsOptionalBigInt(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
      }
      function IsOptionalNumber(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
      }
      function IsOptionalBoolean(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
      }
      function IsOptionalString(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
      }
      function IsOptionalPattern(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
      }
      function IsOptionalFormat(value) {
        return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
      }
      function IsOptionalSchema(value) {
        return ValueGuard.IsUndefined(value) || TSchema(value);
      }
      function TAny(schema2) {
        return TKindOf(schema2, "Any") && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TAny = TAny;
      function TArray(schema2) {
        return TKindOf(schema2, "Array") && schema2.type === "array" && IsOptionalString(schema2.$id) && TSchema(schema2.items) && IsOptionalNumber(schema2.minItems) && IsOptionalNumber(schema2.maxItems) && IsOptionalBoolean(schema2.uniqueItems) && IsOptionalSchema(schema2.contains) && IsOptionalNumber(schema2.minContains) && IsOptionalNumber(schema2.maxContains);
      }
      TypeGuard2.TArray = TArray;
      function TAsyncIterator(schema2) {
        return TKindOf(schema2, "AsyncIterator") && schema2.type === "AsyncIterator" && IsOptionalString(schema2.$id) && TSchema(schema2.items);
      }
      TypeGuard2.TAsyncIterator = TAsyncIterator;
      function TBigInt(schema2) {
        return TKindOf(schema2, "BigInt") && schema2.type === "bigint" && IsOptionalString(schema2.$id) && IsOptionalBigInt(schema2.exclusiveMaximum) && IsOptionalBigInt(schema2.exclusiveMinimum) && IsOptionalBigInt(schema2.maximum) && IsOptionalBigInt(schema2.minimum) && IsOptionalBigInt(schema2.multipleOf);
      }
      TypeGuard2.TBigInt = TBigInt;
      function TBoolean(schema2) {
        return TKindOf(schema2, "Boolean") && schema2.type === "boolean" && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TBoolean = TBoolean;
      function TConstructor(schema2) {
        return TKindOf(schema2, "Constructor") && schema2.type === "Constructor" && IsOptionalString(schema2.$id) && ValueGuard.IsArray(schema2.parameters) && schema2.parameters.every((schema3) => TSchema(schema3)) && TSchema(schema2.returns);
      }
      TypeGuard2.TConstructor = TConstructor;
      function TDate(schema2) {
        return TKindOf(schema2, "Date") && schema2.type === "Date" && IsOptionalString(schema2.$id) && IsOptionalNumber(schema2.exclusiveMaximumTimestamp) && IsOptionalNumber(schema2.exclusiveMinimumTimestamp) && IsOptionalNumber(schema2.maximumTimestamp) && IsOptionalNumber(schema2.minimumTimestamp) && IsOptionalNumber(schema2.multipleOfTimestamp);
      }
      TypeGuard2.TDate = TDate;
      function TFunction(schema2) {
        return TKindOf(schema2, "Function") && schema2.type === "Function" && IsOptionalString(schema2.$id) && ValueGuard.IsArray(schema2.parameters) && schema2.parameters.every((schema3) => TSchema(schema3)) && TSchema(schema2.returns);
      }
      TypeGuard2.TFunction = TFunction;
      function TInteger(schema2) {
        return TKindOf(schema2, "Integer") && schema2.type === "integer" && IsOptionalString(schema2.$id) && IsOptionalNumber(schema2.exclusiveMaximum) && IsOptionalNumber(schema2.exclusiveMinimum) && IsOptionalNumber(schema2.maximum) && IsOptionalNumber(schema2.minimum) && IsOptionalNumber(schema2.multipleOf);
      }
      TypeGuard2.TInteger = TInteger;
      function TIntersect(schema2) {
        return TKindOf(schema2, "Intersect") && (ValueGuard.IsString(schema2.type) && schema2.type !== "object" ? false : true) && ValueGuard.IsArray(schema2.allOf) && schema2.allOf.every((schema3) => TSchema(schema3) && !TTransform(schema3)) && IsOptionalString(schema2.type) && (IsOptionalBoolean(schema2.unevaluatedProperties) || IsOptionalSchema(schema2.unevaluatedProperties)) && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TIntersect = TIntersect;
      function TIterator(schema2) {
        return TKindOf(schema2, "Iterator") && schema2.type === "Iterator" && IsOptionalString(schema2.$id) && TSchema(schema2.items);
      }
      TypeGuard2.TIterator = TIterator;
      function TKindOf(schema2, kind) {
        return TKind(schema2) && schema2[exports.Kind] === kind;
      }
      TypeGuard2.TKindOf = TKindOf;
      function TKind(schema2) {
        return ValueGuard.IsObject(schema2) && exports.Kind in schema2 && ValueGuard.IsString(schema2[exports.Kind]);
      }
      TypeGuard2.TKind = TKind;
      function TLiteralString(schema2) {
        return TLiteral(schema2) && ValueGuard.IsString(schema2.const);
      }
      TypeGuard2.TLiteralString = TLiteralString;
      function TLiteralNumber(schema2) {
        return TLiteral(schema2) && ValueGuard.IsNumber(schema2.const);
      }
      TypeGuard2.TLiteralNumber = TLiteralNumber;
      function TLiteralBoolean(schema2) {
        return TLiteral(schema2) && ValueGuard.IsBoolean(schema2.const);
      }
      TypeGuard2.TLiteralBoolean = TLiteralBoolean;
      function TLiteral(schema2) {
        return TKindOf(schema2, "Literal") && IsOptionalString(schema2.$id) && (ValueGuard.IsBoolean(schema2.const) || ValueGuard.IsNumber(schema2.const) || ValueGuard.IsString(schema2.const));
      }
      TypeGuard2.TLiteral = TLiteral;
      function TNever(schema2) {
        return TKindOf(schema2, "Never") && ValueGuard.IsObject(schema2.not) && Object.getOwnPropertyNames(schema2.not).length === 0;
      }
      TypeGuard2.TNever = TNever;
      function TNot(schema2) {
        return TKindOf(schema2, "Not") && TSchema(schema2.not);
      }
      TypeGuard2.TNot = TNot;
      function TNull(schema2) {
        return TKindOf(schema2, "Null") && schema2.type === "null" && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TNull = TNull;
      function TNumber(schema2) {
        return TKindOf(schema2, "Number") && schema2.type === "number" && IsOptionalString(schema2.$id) && IsOptionalNumber(schema2.exclusiveMaximum) && IsOptionalNumber(schema2.exclusiveMinimum) && IsOptionalNumber(schema2.maximum) && IsOptionalNumber(schema2.minimum) && IsOptionalNumber(schema2.multipleOf);
      }
      TypeGuard2.TNumber = TNumber;
      function TObject(schema2) {
        return TKindOf(schema2, "Object") && schema2.type === "object" && IsOptionalString(schema2.$id) && ValueGuard.IsObject(schema2.properties) && IsAdditionalProperties(schema2.additionalProperties) && IsOptionalNumber(schema2.minProperties) && IsOptionalNumber(schema2.maxProperties) && Object.entries(schema2.properties).every(([key, schema3]) => IsControlCharacterFree(key) && TSchema(schema3));
      }
      TypeGuard2.TObject = TObject;
      function TPromise(schema2) {
        return TKindOf(schema2, "Promise") && schema2.type === "Promise" && IsOptionalString(schema2.$id) && TSchema(schema2.item);
      }
      TypeGuard2.TPromise = TPromise;
      function TRecord(schema2) {
        return TKindOf(schema2, "Record") && schema2.type === "object" && IsOptionalString(schema2.$id) && IsAdditionalProperties(schema2.additionalProperties) && ValueGuard.IsObject(schema2.patternProperties) && ((schema3) => {
          const keys = Object.getOwnPropertyNames(schema3.patternProperties);
          return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema3.patternProperties) && TSchema(schema3.patternProperties[keys[0]]);
        })(schema2);
      }
      TypeGuard2.TRecord = TRecord;
      function TRecursive(schema2) {
        return ValueGuard.IsObject(schema2) && exports.Hint in schema2 && schema2[exports.Hint] === "Recursive";
      }
      TypeGuard2.TRecursive = TRecursive;
      function TRef(schema2) {
        return TKindOf(schema2, "Ref") && IsOptionalString(schema2.$id) && ValueGuard.IsString(schema2.$ref);
      }
      TypeGuard2.TRef = TRef;
      function TString(schema2) {
        return TKindOf(schema2, "String") && schema2.type === "string" && IsOptionalString(schema2.$id) && IsOptionalNumber(schema2.minLength) && IsOptionalNumber(schema2.maxLength) && IsOptionalPattern(schema2.pattern) && IsOptionalFormat(schema2.format);
      }
      TypeGuard2.TString = TString;
      function TSymbol(schema2) {
        return TKindOf(schema2, "Symbol") && schema2.type === "symbol" && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TSymbol = TSymbol;
      function TTemplateLiteral(schema2) {
        return TKindOf(schema2, "TemplateLiteral") && schema2.type === "string" && ValueGuard.IsString(schema2.pattern) && schema2.pattern[0] === "^" && schema2.pattern[schema2.pattern.length - 1] === "$";
      }
      TypeGuard2.TTemplateLiteral = TTemplateLiteral;
      function TThis(schema2) {
        return TKindOf(schema2, "This") && IsOptionalString(schema2.$id) && ValueGuard.IsString(schema2.$ref);
      }
      TypeGuard2.TThis = TThis;
      function TTransform(schema2) {
        return ValueGuard.IsObject(schema2) && exports.Transform in schema2;
      }
      TypeGuard2.TTransform = TTransform;
      function TTuple(schema2) {
        return TKindOf(schema2, "Tuple") && schema2.type === "array" && IsOptionalString(schema2.$id) && ValueGuard.IsNumber(schema2.minItems) && ValueGuard.IsNumber(schema2.maxItems) && schema2.minItems === schema2.maxItems && // empty
        (ValueGuard.IsUndefined(schema2.items) && ValueGuard.IsUndefined(schema2.additionalItems) && schema2.minItems === 0 || ValueGuard.IsArray(schema2.items) && schema2.items.every((schema3) => TSchema(schema3)));
      }
      TypeGuard2.TTuple = TTuple;
      function TUndefined(schema2) {
        return TKindOf(schema2, "Undefined") && schema2.type === "undefined" && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TUndefined = TUndefined;
      function TUnionLiteral(schema2) {
        return TUnion(schema2) && schema2.anyOf.every((schema3) => TLiteralString(schema3) || TLiteralNumber(schema3));
      }
      TypeGuard2.TUnionLiteral = TUnionLiteral;
      function TUnion(schema2) {
        return TKindOf(schema2, "Union") && IsOptionalString(schema2.$id) && ValueGuard.IsObject(schema2) && ValueGuard.IsArray(schema2.anyOf) && schema2.anyOf.every((schema3) => TSchema(schema3));
      }
      TypeGuard2.TUnion = TUnion;
      function TUint8Array(schema2) {
        return TKindOf(schema2, "Uint8Array") && schema2.type === "Uint8Array" && IsOptionalString(schema2.$id) && IsOptionalNumber(schema2.minByteLength) && IsOptionalNumber(schema2.maxByteLength);
      }
      TypeGuard2.TUint8Array = TUint8Array;
      function TUnknown(schema2) {
        return TKindOf(schema2, "Unknown") && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TUnknown = TUnknown;
      function TUnsafe(schema2) {
        return TKindOf(schema2, "Unsafe");
      }
      TypeGuard2.TUnsafe = TUnsafe;
      function TVoid(schema2) {
        return TKindOf(schema2, "Void") && schema2.type === "void" && IsOptionalString(schema2.$id);
      }
      TypeGuard2.TVoid = TVoid;
      function TReadonly(schema2) {
        return ValueGuard.IsObject(schema2) && schema2[exports.Readonly] === "Readonly";
      }
      TypeGuard2.TReadonly = TReadonly;
      function TOptional(schema2) {
        return ValueGuard.IsObject(schema2) && schema2[exports.Optional] === "Optional";
      }
      TypeGuard2.TOptional = TOptional;
      function TSchema(schema2) {
        return ValueGuard.IsObject(schema2) && (TAny(schema2) || TArray(schema2) || TBoolean(schema2) || TBigInt(schema2) || TAsyncIterator(schema2) || TConstructor(schema2) || TDate(schema2) || TFunction(schema2) || TInteger(schema2) || TIntersect(schema2) || TIterator(schema2) || TLiteral(schema2) || TNever(schema2) || TNot(schema2) || TNull(schema2) || TNumber(schema2) || TObject(schema2) || TPromise(schema2) || TRecord(schema2) || TRef(schema2) || TString(schema2) || TSymbol(schema2) || TTemplateLiteral(schema2) || TThis(schema2) || TTuple(schema2) || TUndefined(schema2) || TUnion(schema2) || TUint8Array(schema2) || TUnknown(schema2) || TUnsafe(schema2) || TVoid(schema2) || TKind(schema2) && TypeRegistry.Has(schema2[exports.Kind]));
      }
      TypeGuard2.TSchema = TSchema;
    })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
    var ExtendsUndefined;
    (function(ExtendsUndefined2) {
      function Check(schema2) {
        return schema2[exports.Kind] === "Intersect" ? schema2.allOf.every((schema3) => Check(schema3)) : schema2[exports.Kind] === "Union" ? schema2.anyOf.some((schema3) => Check(schema3)) : schema2[exports.Kind] === "Undefined" ? true : schema2[exports.Kind] === "Not" ? !Check(schema2.not) : false;
      }
      ExtendsUndefined2.Check = Check;
    })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
    var TypeExtendsError = class extends TypeBoxError {
    };
    exports.TypeExtendsError = TypeExtendsError;
    var TypeExtendsResult;
    (function(TypeExtendsResult2) {
      TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
      TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
      TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
    })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
    var TypeExtends;
    (function(TypeExtends2) {
      function IntoBooleanResult(result) {
        return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
      }
      function Throw(message) {
        throw new TypeExtendsError(message);
      }
      function IsStructuralRight(right) {
        return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
      }
      function StructuralRight(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
      }
      function TAnyRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TAny(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema2) => TypeGuard.TAny(schema2) || TypeGuard.TUnknown(schema2)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
      }
      function TArrayRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TArray(left, right) {
        return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TAsyncIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TBigInt(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBooleanRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TBoolean(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TConstructor(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema2, index2) => IntoBooleanResult(Visit(right.parameters[index2], schema2)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TDate(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TFunction(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema2, index2) => IntoBooleanResult(Visit(right.parameters[index2], schema2)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
      }
      function TIntegerRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TInteger(left, right) {
        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
      }
      function TIntersectRight(left, right) {
        return right.allOf.every((schema2) => Visit(left, schema2) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIntersect(left, right) {
        return left.allOf.some((schema2) => Visit(schema2, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TIterator(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
      }
      function TLiteral(left, right) {
        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
      }
      function TNeverRight(left, right) {
        return TypeExtendsResult.False;
      }
      function TNever(left, right) {
        return TypeExtendsResult.True;
      }
      function UnwrapTNot(schema2) {
        let [current, depth] = [schema2, 0];
        while (true) {
          if (!TypeGuard.TNot(current))
            break;
          current = current.not;
          depth += 1;
        }
        return depth % 2 === 0 ? current : exports.Type.Unknown();
      }
      function TNot(left, right) {
        return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
      }
      function TNull(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumberRight(left, right) {
        return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TNumber(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function IsObjectPropertyCount(schema2, count) {
        return Object.getOwnPropertyNames(schema2.properties).length === count;
      }
      function IsObjectStringLike(schema2) {
        return IsObjectArrayLike(schema2);
      }
      function IsObjectSymbolLike(schema2) {
        return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "description" in schema2.properties && TypeGuard.TUnion(schema2.properties.description) && schema2.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema2.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema2.properties.description.anyOf[1]) || TypeGuard.TString(schema2.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema2.properties.description.anyOf[0]));
      }
      function IsObjectNumberLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectBooleanLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectBigIntLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectDateLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectUint8ArrayLike(schema2) {
        return IsObjectArrayLike(schema2);
      }
      function IsObjectFunctionLike(schema2) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "length" in schema2.properties && IntoBooleanResult(Visit(schema2.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectConstructorLike(schema2) {
        return IsObjectPropertyCount(schema2, 0);
      }
      function IsObjectArrayLike(schema2) {
        const length = exports.Type.Number();
        return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "length" in schema2.properties && IntoBooleanResult(Visit(schema2.properties["length"], length)) === TypeExtendsResult.True;
      }
      function IsObjectPromiseLike(schema2) {
        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
        return IsObjectPropertyCount(schema2, 0) || IsObjectPropertyCount(schema2, 1) && "then" in schema2.properties && IntoBooleanResult(Visit(schema2.properties["then"], then)) === TypeExtendsResult.True;
      }
      function Property(left, right) {
        return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
      }
      function TObjectRight(left, right) {
        return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
          return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
          return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
        })() : TypeExtendsResult.False;
      }
      function TObject(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
          for (const key of Object.getOwnPropertyNames(right.properties)) {
            if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.False;
            }
            if (TypeGuard.TOptional(right.properties[key])) {
              return TypeExtendsResult.True;
            }
            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })();
      }
      function TPromise(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
      }
      function RecordKey(schema2) {
        return exports.PatternNumberExact in schema2.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema2.patternProperties ? exports.Type.String() : Throw("Unknown record key pattern");
      }
      function RecordValue(schema2) {
        return exports.PatternNumberExact in schema2.patternProperties ? schema2.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema2.patternProperties ? schema2.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
      }
      function TRecordRight(left, right) {
        const [Key, Value3] = [RecordKey(right), RecordValue(right)];
        return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value3)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value3) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value3) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value3) : TypeGuard.TObject(left) ? (() => {
          for (const key of Object.getOwnPropertyNames(left.properties)) {
            if (Property(Value3, left.properties[key]) === TypeExtendsResult.False) {
              return TypeExtendsResult.False;
            }
          }
          return TypeExtendsResult.True;
        })() : TypeExtendsResult.False;
      }
      function TRecord(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
      }
      function TStringRight(left, right) {
        return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TString(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TSymbol(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TTemplateLiteral(left, right) {
        return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
      }
      function IsArrayOfTuple(left, right) {
        return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema2) => Visit(schema2, right.items) === TypeExtendsResult.True);
      }
      function TTupleRight(left, right) {
        return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
      }
      function TTuple(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema2, index2) => Visit(schema2, right.items[index2]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUint8Array(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUndefined(left, right) {
        return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnionRight(left, right) {
        return right.anyOf.some((schema2) => Visit(left, schema2) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnion(left, right) {
        return left.anyOf.every((schema2) => Visit(schema2, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TUnknownRight(left, right) {
        return TypeExtendsResult.True;
      }
      function TUnknown(left, right) {
        return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function VoidRight(left, right) {
        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function TVoid(left, right) {
        return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
      }
      function Visit(left, right) {
        return (
          // resolvable
          TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : (
            // standard
            TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
          )
        );
      }
      function Extends(left, right) {
        return Visit(left, right);
      }
      TypeExtends2.Extends = Extends;
    })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
    var TypeClone;
    (function(TypeClone2) {
      function ArrayType(value) {
        return value.map((value2) => Visit(value2));
      }
      function DateType(value) {
        return new Date(value.getTime());
      }
      function Uint8ArrayType(value) {
        return new Uint8Array(value);
      }
      function ObjectType(value) {
        const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
        return { ...clonedProperties, ...clonedSymbols };
      }
      function Visit(value) {
        return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
      }
      function Rest(schemas) {
        return schemas.map((schema2) => Type11(schema2));
      }
      TypeClone2.Rest = Rest;
      function Type11(schema2, options = {}) {
        return { ...Visit(schema2), ...options };
      }
      TypeClone2.Type = Type11;
    })(TypeClone || (exports.TypeClone = TypeClone = {}));
    var IndexedAccessor;
    (function(IndexedAccessor2) {
      function OptionalUnwrap(schema2) {
        return schema2.map((schema3) => {
          const { [exports.Optional]: _2, ...clone2 } = TypeClone.Type(schema3);
          return clone2;
        });
      }
      function IsIntersectOptional(schema2) {
        return schema2.every((schema3) => TypeGuard.TOptional(schema3));
      }
      function IsUnionOptional(schema2) {
        return schema2.some((schema3) => TypeGuard.TOptional(schema3));
      }
      function ResolveIntersect(schema2) {
        return IsIntersectOptional(schema2.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema2.allOf))) : schema2;
      }
      function ResolveUnion(schema2) {
        return IsUnionOptional(schema2.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema2.anyOf))) : schema2;
      }
      function ResolveOptional(schema2) {
        return schema2[exports.Kind] === "Intersect" ? ResolveIntersect(schema2) : schema2[exports.Kind] === "Union" ? ResolveUnion(schema2) : schema2;
      }
      function TIntersect(schema2, key) {
        const resolved = schema2.allOf.reduce((acc, schema3) => {
          const indexed = Visit(schema3, key);
          return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
        }, []);
        return ResolveOptional(exports.Type.Intersect(resolved));
      }
      function TUnion(schema2, key) {
        const resolved = schema2.anyOf.map((schema3) => Visit(schema3, key));
        return ResolveOptional(exports.Type.Union(resolved));
      }
      function TObject(schema2, key) {
        const property = schema2.properties[key];
        return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
      }
      function TTuple(schema2, key) {
        const items = schema2.items;
        if (ValueGuard.IsUndefined(items))
          return exports.Type.Never();
        const element = items[key];
        if (ValueGuard.IsUndefined(element))
          return exports.Type.Never();
        return element;
      }
      function Visit(schema2, key) {
        return schema2[exports.Kind] === "Intersect" ? TIntersect(schema2, key) : schema2[exports.Kind] === "Union" ? TUnion(schema2, key) : schema2[exports.Kind] === "Object" ? TObject(schema2, key) : schema2[exports.Kind] === "Tuple" ? TTuple(schema2, key) : exports.Type.Never();
      }
      function Resolve(schema2, keys, options = {}) {
        const resolved = keys.map((key) => Visit(schema2, key.toString()));
        return ResolveOptional(exports.Type.Union(resolved, options));
      }
      IndexedAccessor2.Resolve = Resolve;
    })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
    var Intrinsic;
    (function(Intrinsic2) {
      function Uncapitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toLowerCase()}${rest}`;
      }
      function Capitalize(value) {
        const [first, rest] = [value.slice(0, 1), value.slice(1)];
        return `${first.toUpperCase()}${rest}`;
      }
      function Uppercase(value) {
        return value.toUpperCase();
      }
      function Lowercase(value) {
        return value.toLowerCase();
      }
      function IntrinsicTemplateLiteral(schema2, mode) {
        const expression = TemplateLiteralParser.ParseExact(schema2.pattern);
        const finite = TemplateLiteralFinite.Check(expression);
        if (!finite)
          return { ...schema2, pattern: IntrinsicLiteral(schema2.pattern, mode) };
        const strings = [...TemplateLiteralGenerator.Generate(expression)];
        const literals = strings.map((value) => exports.Type.Literal(value));
        const mapped = IntrinsicRest(literals, mode);
        const union = exports.Type.Union(mapped);
        return exports.Type.TemplateLiteral([union]);
      }
      function IntrinsicLiteral(value, mode) {
        return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
      }
      function IntrinsicRest(schema2, mode) {
        if (schema2.length === 0)
          return [];
        const [L, ...R2] = schema2;
        return [Map2(L, mode), ...IntrinsicRest(R2, mode)];
      }
      function Visit(schema2, mode) {
        return TypeGuard.TTemplateLiteral(schema2) ? IntrinsicTemplateLiteral(schema2, mode) : TypeGuard.TUnion(schema2) ? exports.Type.Union(IntrinsicRest(schema2.anyOf, mode)) : TypeGuard.TLiteral(schema2) ? exports.Type.Literal(IntrinsicLiteral(schema2.const, mode)) : schema2;
      }
      function Map2(schema2, mode) {
        return Visit(schema2, mode);
      }
      Intrinsic2.Map = Map2;
    })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
    var ObjectMap;
    (function(ObjectMap2) {
      function TIntersect(schema2, callback) {
        return exports.Type.Intersect(schema2.allOf.map((inner) => Visit(inner, callback)), { ...schema2 });
      }
      function TUnion(schema2, callback) {
        return exports.Type.Union(schema2.anyOf.map((inner) => Visit(inner, callback)), { ...schema2 });
      }
      function TObject(schema2, callback) {
        return callback(schema2);
      }
      function Visit(schema2, callback) {
        return schema2[exports.Kind] === "Intersect" ? TIntersect(schema2, callback) : schema2[exports.Kind] === "Union" ? TUnion(schema2, callback) : schema2[exports.Kind] === "Object" ? TObject(schema2, callback) : schema2;
      }
      function Map2(schema2, callback, options) {
        return { ...Visit(TypeClone.Type(schema2), callback), ...options };
      }
      ObjectMap2.Map = Map2;
    })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
    var KeyResolver;
    (function(KeyResolver2) {
      function UnwrapPattern(key) {
        return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
      }
      function TIntersect(schema2, options) {
        return schema2.allOf.reduce((acc, schema3) => [...acc, ...Visit(schema3, options)], []);
      }
      function TUnion(schema2, options) {
        const sets = schema2.anyOf.map((inner) => Visit(inner, options));
        return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
      }
      function TObject(schema2, options) {
        return Object.getOwnPropertyNames(schema2.properties);
      }
      function TRecord(schema2, options) {
        return options.includePatterns ? Object.getOwnPropertyNames(schema2.patternProperties) : [];
      }
      function Visit(schema2, options) {
        return TypeGuard.TIntersect(schema2) ? TIntersect(schema2, options) : TypeGuard.TUnion(schema2) ? TUnion(schema2, options) : TypeGuard.TObject(schema2) ? TObject(schema2, options) : TypeGuard.TRecord(schema2) ? TRecord(schema2, options) : [];
      }
      function ResolveKeys(schema2, options) {
        return [...new Set(Visit(schema2, options))];
      }
      KeyResolver2.ResolveKeys = ResolveKeys;
      function ResolvePattern(schema2) {
        const keys = ResolveKeys(schema2, { includePatterns: true });
        const pattern3 = keys.map((key) => `(${UnwrapPattern(key)})`);
        return `^(${pattern3.join("|")})$`;
      }
      KeyResolver2.ResolvePattern = ResolvePattern;
    })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
    var KeyArrayResolverError = class extends TypeBoxError {
    };
    exports.KeyArrayResolverError = KeyArrayResolverError;
    var KeyArrayResolver;
    (function(KeyArrayResolver2) {
      function Resolve(schema2) {
        return Array.isArray(schema2) ? schema2 : TypeGuard.TUnionLiteral(schema2) ? schema2.anyOf.map((schema3) => schema3.const.toString()) : TypeGuard.TLiteral(schema2) ? [schema2.const] : TypeGuard.TTemplateLiteral(schema2) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(schema2.pattern);
          if (!TemplateLiteralFinite.Check(expression))
            throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
          return [...TemplateLiteralGenerator.Generate(expression)];
        })() : [];
      }
      KeyArrayResolver2.Resolve = Resolve;
    })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
    var UnionResolver;
    (function(UnionResolver2) {
      function* TUnion(union) {
        for (const schema2 of union.anyOf) {
          if (schema2[exports.Kind] === "Union") {
            yield* TUnion(schema2);
          } else {
            yield schema2;
          }
        }
      }
      function Resolve(union) {
        return exports.Type.Union([...TUnion(union)], { ...union });
      }
      UnionResolver2.Resolve = Resolve;
    })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
    var TemplateLiteralPatternError = class extends TypeBoxError {
    };
    exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
    var TemplateLiteralPattern;
    (function(TemplateLiteralPattern2) {
      function Throw(message) {
        throw new TemplateLiteralPatternError(message);
      }
      function Escape(value) {
        return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function Visit(schema2, acc) {
        return TypeGuard.TTemplateLiteral(schema2) ? schema2.pattern.slice(1, schema2.pattern.length - 1) : TypeGuard.TUnion(schema2) ? `(${schema2.anyOf.map((schema3) => Visit(schema3, acc)).join("|")})` : TypeGuard.TNumber(schema2) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema2) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema2) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema2) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema2) ? `${acc}${Escape(schema2.const.toString())}` : TypeGuard.TBoolean(schema2) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema2[exports.Kind]}'`);
      }
      function Create(kinds) {
        return `^${kinds.map((schema2) => Visit(schema2, "")).join("")}$`;
      }
      TemplateLiteralPattern2.Create = Create;
    })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
    var TemplateLiteralResolver;
    (function(TemplateLiteralResolver2) {
      function Resolve(template) {
        const expression = TemplateLiteralParser.ParseExact(template.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          return exports.Type.String();
        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
        return exports.Type.Union(literals);
      }
      TemplateLiteralResolver2.Resolve = Resolve;
    })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
    var TemplateLiteralParserError = class extends TypeBoxError {
    };
    exports.TemplateLiteralParserError = TemplateLiteralParserError;
    var TemplateLiteralParser;
    (function(TemplateLiteralParser2) {
      function IsNonEscaped(pattern3, index2, char) {
        return pattern3[index2] === char && pattern3.charCodeAt(index2 - 1) !== 92;
      }
      function IsOpenParen(pattern3, index2) {
        return IsNonEscaped(pattern3, index2, "(");
      }
      function IsCloseParen(pattern3, index2) {
        return IsNonEscaped(pattern3, index2, ")");
      }
      function IsSeparator(pattern3, index2) {
        return IsNonEscaped(pattern3, index2, "|");
      }
      function IsGroup(pattern3) {
        if (!(IsOpenParen(pattern3, 0) && IsCloseParen(pattern3, pattern3.length - 1)))
          return false;
        let count = 0;
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2))
            count += 1;
          if (IsCloseParen(pattern3, index2))
            count -= 1;
          if (count === 0 && index2 !== pattern3.length - 1)
            return false;
        }
        return true;
      }
      function InGroup(pattern3) {
        return pattern3.slice(1, pattern3.length - 1);
      }
      function IsPrecedenceOr(pattern3) {
        let count = 0;
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2))
            count += 1;
          if (IsCloseParen(pattern3, index2))
            count -= 1;
          if (IsSeparator(pattern3, index2) && count === 0)
            return true;
        }
        return false;
      }
      function IsPrecedenceAnd(pattern3) {
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2))
            return true;
        }
        return false;
      }
      function Or(pattern3) {
        let [count, start] = [0, 0];
        const expressions = [];
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2))
            count += 1;
          if (IsCloseParen(pattern3, index2))
            count -= 1;
          if (IsSeparator(pattern3, index2) && count === 0) {
            const range2 = pattern3.slice(start, index2);
            if (range2.length > 0)
              expressions.push(Parse(range2));
            start = index2 + 1;
          }
        }
        const range = pattern3.slice(start);
        if (range.length > 0)
          expressions.push(Parse(range));
        if (expressions.length === 0)
          return { type: "const", const: "" };
        if (expressions.length === 1)
          return expressions[0];
        return { type: "or", expr: expressions };
      }
      function And(pattern3) {
        function Group(value, index2) {
          if (!IsOpenParen(value, index2))
            throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
          let count = 0;
          for (let scan = index2; scan < value.length; scan++) {
            if (IsOpenParen(value, scan))
              count += 1;
            if (IsCloseParen(value, scan))
              count -= 1;
            if (count === 0)
              return [index2, scan];
          }
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
        }
        function Range(pattern4, index2) {
          for (let scan = index2; scan < pattern4.length; scan++) {
            if (IsOpenParen(pattern4, scan))
              return [index2, scan];
          }
          return [index2, pattern4.length];
        }
        const expressions = [];
        for (let index2 = 0; index2 < pattern3.length; index2++) {
          if (IsOpenParen(pattern3, index2)) {
            const [start, end] = Group(pattern3, index2);
            const range = pattern3.slice(start, end + 1);
            expressions.push(Parse(range));
            index2 = end;
          } else {
            const [start, end] = Range(pattern3, index2);
            const range = pattern3.slice(start, end);
            if (range.length > 0)
              expressions.push(Parse(range));
            index2 = end - 1;
          }
        }
        return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
      }
      function Parse(pattern3) {
        return IsGroup(pattern3) ? Parse(InGroup(pattern3)) : IsPrecedenceOr(pattern3) ? Or(pattern3) : IsPrecedenceAnd(pattern3) ? And(pattern3) : { type: "const", const: pattern3 };
      }
      TemplateLiteralParser2.Parse = Parse;
      function ParseExact(pattern3) {
        return Parse(pattern3.slice(1, pattern3.length - 1));
      }
      TemplateLiteralParser2.ParseExact = ParseExact;
    })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
    var TemplateLiteralFiniteError = class extends TypeBoxError {
    };
    exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    var TemplateLiteralFinite;
    (function(TemplateLiteralFinite2) {
      function Throw(message) {
        throw new TemplateLiteralFiniteError(message);
      }
      function IsNumber(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
      }
      function IsBoolean(expression) {
        return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
      }
      function IsString(expression) {
        return expression.type === "const" && expression.const === ".*";
      }
      function Check(expression) {
        return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
      }
      TemplateLiteralFinite2.Check = Check;
    })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
    var TemplateLiteralGeneratorError = class extends TypeBoxError {
    };
    exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
    var TemplateLiteralGenerator;
    (function(TemplateLiteralGenerator2) {
      function* Reduce(buffer) {
        if (buffer.length === 1)
          return yield* buffer[0];
        for (const left of buffer[0]) {
          for (const right of Reduce(buffer.slice(1))) {
            yield `${left}${right}`;
          }
        }
      }
      function* And(expression) {
        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
      }
      function* Or(expression) {
        for (const expr of expression.expr)
          yield* Generate(expr);
      }
      function* Const(expression) {
        return yield expression.const;
      }
      function* Generate(expression) {
        return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
          throw new TemplateLiteralGeneratorError("Unknown expression");
        })();
      }
      TemplateLiteralGenerator2.Generate = Generate;
    })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
    var TemplateLiteralDslParser;
    (function(TemplateLiteralDslParser2) {
      function* ParseUnion(template) {
        const trim = template.trim().replace(/"|'/g, "");
        return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
          const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
          return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
        })();
      }
      function* ParseTerminal(template) {
        if (template[1] !== "{") {
          const L = exports.Type.Literal("$");
          const R2 = ParseLiteral(template.slice(1));
          return yield* [L, ...R2];
        }
        for (let i4 = 2; i4 < template.length; i4++) {
          if (template[i4] === "}") {
            const L = ParseUnion(template.slice(2, i4));
            const R2 = ParseLiteral(template.slice(i4 + 1));
            return yield* [...L, ...R2];
          }
        }
        yield exports.Type.Literal(template);
      }
      function* ParseLiteral(template) {
        for (let i4 = 0; i4 < template.length; i4++) {
          if (template[i4] === "$") {
            const L = exports.Type.Literal(template.slice(0, i4));
            const R2 = ParseTerminal(template.slice(i4));
            return yield* [L, ...R2];
          }
        }
        yield exports.Type.Literal(template);
      }
      function Parse(template_dsl) {
        return [...ParseLiteral(template_dsl)];
      }
      TemplateLiteralDslParser2.Parse = Parse;
    })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
    var TransformDecodeBuilder = class {
      constructor(schema2) {
        this.schema = schema2;
      }
      Decode(decode) {
        return new TransformEncodeBuilder(this.schema, decode);
      }
    };
    exports.TransformDecodeBuilder = TransformDecodeBuilder;
    var TransformEncodeBuilder = class {
      constructor(schema2, decode) {
        this.schema = schema2;
        this.decode = decode;
      }
      Encode(encode) {
        const schema2 = TypeClone.Type(this.schema);
        return TypeGuard.TTransform(schema2) ? (() => {
          const Encode = (value) => schema2[exports.Transform].Encode(encode(value));
          const Decode = (value) => this.decode(schema2[exports.Transform].Decode(value));
          const Codec = { Encode, Decode };
          return { ...schema2, [exports.Transform]: Codec };
        })() : (() => {
          const Codec = { Decode: this.decode, Encode: encode };
          return { ...schema2, [exports.Transform]: Codec };
        })();
      }
    };
    exports.TransformEncodeBuilder = TransformEncodeBuilder;
    var TypeOrdinal = 0;
    var TypeBuilderError = class extends TypeBoxError {
    };
    exports.TypeBuilderError = TypeBuilderError;
    var TypeBuilder = class {
      /** `[Internal]` Creates a schema without `static` and `params` types */
      Create(schema2) {
        return schema2;
      }
      /** `[Internal]` Throws a TypeBuilder error with the given message */
      Throw(message) {
        throw new TypeBuilderError(message);
      }
      /** `[Internal]` Discards property keys from the given record type */
      Discard(record, keys) {
        return keys.reduce((acc, key) => {
          const { [key]: _2, ...rest } = acc;
          return rest;
        }, record);
      }
      /** `[Json]` Omits compositing symbols from this schema */
      Strict(schema2) {
        return JSON.parse(JSON.stringify(schema2));
      }
    };
    exports.TypeBuilder = TypeBuilder;
    var JsonTypeBuilder = class extends TypeBuilder {
      // ------------------------------------------------------------------------
      // Modifiers
      // ------------------------------------------------------------------------
      /** `[Json]` Creates a Readonly and Optional property */
      ReadonlyOptional(schema2) {
        return this.Readonly(this.Optional(schema2));
      }
      /** `[Json]` Creates a Readonly property */
      Readonly(schema2) {
        return { ...TypeClone.Type(schema2), [exports.Readonly]: "Readonly" };
      }
      /** `[Json]` Creates an Optional property */
      Optional(schema2) {
        return { ...TypeClone.Type(schema2), [exports.Optional]: "Optional" };
      }
      // ------------------------------------------------------------------------
      // Types
      // ------------------------------------------------------------------------
      /** `[Json]` Creates an Any type */
      Any(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Any" });
      }
      /** `[Json]` Creates an Array type */
      Array(schema2, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema2) });
      }
      /** `[Json]` Creates a Boolean type */
      Boolean(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
      }
      /** `[Json]` Intrinsic function to Capitalize LiteralString types */
      Capitalize(schema2, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema2), "Capitalize"), ...options };
      }
      /** `[Json]` Creates a Composite object type */
      Composite(objects, options) {
        const intersect = exports.Type.Intersect(objects, {});
        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
        return exports.Type.Object(properties, options);
      }
      /** `[Json]` Creates a Enum type */
      Enum(item, options = {}) {
        if (ValueGuard.IsUndefined(item))
          return this.Throw("Enum undefined or empty");
        const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
        const values2 = [...new Set(values1)];
        const anyOf = values2.map((value) => exports.Type.Literal(value));
        return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
      }
      /** `[Json]` Creates a Conditional type */
      Extends(left, right, trueType, falseType, options = {}) {
        switch (TypeExtends.Extends(left, right)) {
          case TypeExtendsResult.Union:
            return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
          case TypeExtendsResult.True:
            return TypeClone.Type(trueType, options);
          case TypeExtendsResult.False:
            return TypeClone.Type(falseType, options);
        }
      }
      /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
      Exclude(unionType, excludedMembers, options = {}) {
        return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
          const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
      }
      /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
      Extract(type, union, options = {}) {
        return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
          const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
          return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
        })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
      }
      /** `[Json]` Returns an Indexed property type for the given keys */
      Index(schema2, unresolved, options = {}) {
        return TypeGuard.TArray(schema2) && TypeGuard.TNumber(unresolved) ? (() => {
          return TypeClone.Type(schema2.items, options);
        })() : TypeGuard.TTuple(schema2) && TypeGuard.TNumber(unresolved) ? (() => {
          const items = ValueGuard.IsUndefined(schema2.items) ? [] : schema2.items;
          const cloned = items.map((schema3) => TypeClone.Type(schema3));
          return this.Union(cloned, options);
        })() : (() => {
          const keys = KeyArrayResolver.Resolve(unresolved);
          const clone2 = TypeClone.Type(schema2);
          return IndexedAccessor.Resolve(clone2, keys, options);
        })();
      }
      /** `[Json]` Creates an Integer type */
      Integer(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
      }
      /** `[Json]` Creates an Intersect type */
      Intersect(allOf, options = {}) {
        if (allOf.length === 0)
          return exports.Type.Never();
        if (allOf.length === 1)
          return TypeClone.Type(allOf[0], options);
        if (allOf.some((schema2) => TypeGuard.TTransform(schema2)))
          this.Throw("Cannot intersect transform types");
        const objects = allOf.every((schema2) => TypeGuard.TObject(schema2));
        const cloned = TypeClone.Rest(allOf);
        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
        return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
      }
      /** `[Json]` Creates a KeyOf type */
      KeyOf(schema2, options = {}) {
        return TypeGuard.TRecord(schema2) ? (() => {
          const pattern3 = Object.getOwnPropertyNames(schema2.patternProperties)[0];
          return pattern3 === exports.PatternNumberExact ? this.Number(options) : pattern3 === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
        })() : TypeGuard.TTuple(schema2) ? (() => {
          const items = ValueGuard.IsUndefined(schema2.items) ? [] : schema2.items;
          const literals = items.map((_2, index2) => exports.Type.Literal(index2.toString()));
          return this.Union(literals, options);
        })() : TypeGuard.TArray(schema2) ? (() => {
          return this.Number(options);
        })() : (() => {
          const keys = KeyResolver.ResolveKeys(schema2, { includePatterns: false });
          if (keys.length === 0)
            return this.Never(options);
          const literals = keys.map((key) => this.Literal(key));
          return this.Union(literals, options);
        })();
      }
      /** `[Json]` Creates a Literal type */
      Literal(value, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
      }
      /** `[Json]` Intrinsic function to Lowercase LiteralString types */
      Lowercase(schema2, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema2), "Lowercase"), ...options };
      }
      /** `[Json]` Creates a Never type */
      Never(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
      }
      /** `[Json]` Creates a Not type */
      Not(schema2, options) {
        return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema2) });
      }
      /** `[Json]` Creates a Null type */
      Null(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
      }
      /** `[Json]` Creates a Number type */
      Number(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
      }
      /** `[Json]` Creates an Object type */
      Object(properties, options = {}) {
        const propertyKeys = Object.getOwnPropertyNames(properties);
        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
        return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
      }
      /** `[Json]` Constructs a type whose keys are omitted from the given type */
      Omit(schema2, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]), (object) => {
          if (ValueGuard.IsArray(object.required)) {
            object.required = object.required.filter((key) => !keys.includes(key));
            if (object.required.length === 0)
              delete object.required;
          }
          for (const key of Object.getOwnPropertyNames(object.properties)) {
            if (keys.includes(key))
              delete object.properties[key];
          }
          return this.Create(object);
        }, options);
      }
      /** `[Json]` Constructs a type where all properties are optional */
      Partial(schema2, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]), (object) => {
          const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Optional(object.properties[key]) };
          }, {});
          return this.Object(
            properties,
            this.Discard(object, ["required"])
            /* object used as options to retain other constraints */
          );
        }, options);
      }
      /** `[Json]` Constructs a type whose keys are picked from the given type */
      Pick(schema2, unresolved, options = {}) {
        const keys = KeyArrayResolver.Resolve(unresolved);
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]), (object) => {
          if (ValueGuard.IsArray(object.required)) {
            object.required = object.required.filter((key) => keys.includes(key));
            if (object.required.length === 0)
              delete object.required;
          }
          for (const key of Object.getOwnPropertyNames(object.properties)) {
            if (!keys.includes(key))
              delete object.properties[key];
          }
          return this.Create(object);
        }, options);
      }
      /** `[Json]` Creates a Record type */
      Record(key, schema2, options = {}) {
        return TypeGuard.TTemplateLiteral(key) ? (() => {
          const expression = TemplateLiteralParser.ParseExact(key.pattern);
          return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema2) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema2) } });
        })() : TypeGuard.TUnion(key) ? (() => {
          const union = UnionResolver.Resolve(key);
          if (TypeGuard.TUnionLiteral(union)) {
            const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema2) }), {});
            return this.Object(properties, { ...options, [exports.Hint]: "Record" });
          } else
            this.Throw("Record key of type union contains non-literal types");
        })() : TypeGuard.TLiteral(key) ? (() => {
          return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema2) }, options) : this.Throw("Record key of type literal is not of type string or number");
        })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema2) } });
        })() : TypeGuard.TString(key) ? (() => {
          const pattern3 = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
          return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern3]: TypeClone.Type(schema2) } });
        })() : this.Never();
      }
      /** `[Json]` Creates a Recursive type */
      Recursive(callback, options = {}) {
        if (ValueGuard.IsUndefined(options.$id))
          options.$id = `T${TypeOrdinal++}`;
        const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
        thisType.$id = options.$id;
        return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
      }
      /** `[Json]` Creates a Ref type. */
      Ref(unresolved, options = {}) {
        if (ValueGuard.IsString(unresolved))
          return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
        if (ValueGuard.IsUndefined(unresolved.$id))
          this.Throw("Reference target type must specify an $id");
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
      }
      /** `[Json]` Constructs a type where all properties are required */
      Required(schema2, options = {}) {
        return ObjectMap.Map(this.Discard(TypeClone.Type(schema2), ["$id", exports.Transform]), (object) => {
          const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
            return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
          }, {});
          return this.Object(
            properties,
            object
            /* object used as options to retain other constraints  */
          );
        }, options);
      }
      /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
      Rest(schema2) {
        return TypeGuard.TTuple(schema2) && !ValueGuard.IsUndefined(schema2.items) ? TypeClone.Rest(schema2.items) : TypeGuard.TIntersect(schema2) ? TypeClone.Rest(schema2.allOf) : TypeGuard.TUnion(schema2) ? TypeClone.Rest(schema2.anyOf) : [];
      }
      /** `[Json]` Creates a String type */
      String(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
      }
      /** `[Json]` Creates a TemplateLiteral type */
      TemplateLiteral(unresolved, options = {}) {
        const pattern3 = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
        return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern: pattern3 });
      }
      /** `[Json]` Creates a Transform type */
      Transform(schema2) {
        return new TransformDecodeBuilder(schema2);
      }
      /** `[Json]` Creates a Tuple type */
      Tuple(items, options = {}) {
        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
        const clonedItems = TypeClone.Rest(items);
        const schema2 = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
        return this.Create(schema2);
      }
      /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
      Uncapitalize(schema2, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema2), "Uncapitalize"), ...options };
      }
      /** `[Json]` Creates a Union type */
      Union(union, options = {}) {
        return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
          const anyOf = union;
          if (anyOf.length === 0)
            return this.Never(options);
          if (anyOf.length === 1)
            return this.Create(TypeClone.Type(anyOf[0], options));
          const clonedAnyOf = TypeClone.Rest(anyOf);
          return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
        })();
      }
      /** `[Json]` Creates an Unknown type */
      Unknown(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Unknown" });
      }
      /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
      Unsafe(options = {}) {
        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
      }
      /** `[Json]` Intrinsic function to Uppercase LiteralString types */
      Uppercase(schema2, options = {}) {
        return { ...Intrinsic.Map(TypeClone.Type(schema2), "Uppercase"), ...options };
      }
    };
    exports.JsonTypeBuilder = JsonTypeBuilder;
    var JavaScriptTypeBuilder = class extends JsonTypeBuilder {
      /** `[JavaScript]` Creates a AsyncIterator type */
      AsyncIterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
      Awaited(schema2, options = {}) {
        const Unwrap = (rest) => rest.length > 0 ? (() => {
          const [L, ...R2] = rest;
          return [this.Awaited(L), ...Unwrap(R2)];
        })() : rest;
        return TypeGuard.TIntersect(schema2) ? exports.Type.Intersect(Unwrap(schema2.allOf)) : TypeGuard.TUnion(schema2) ? exports.Type.Union(Unwrap(schema2.anyOf)) : TypeGuard.TPromise(schema2) ? this.Awaited(schema2.item) : TypeClone.Type(schema2, options);
      }
      /** `[JavaScript]` Creates a BigInt type */
      BigInt(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
      }
      /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
      ConstructorParameters(schema2, options = {}) {
        return this.Tuple([...schema2.parameters], { ...options });
      }
      /** `[JavaScript]` Creates a Constructor type */
      Constructor(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Creates a Date type */
      Date(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
      }
      /** `[JavaScript]` Creates a Function type */
      Function(parameters, returns, options) {
        const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
        return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
      }
      /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
      InstanceType(schema2, options = {}) {
        return TypeClone.Type(schema2.returns, options);
      }
      /** `[JavaScript]` Creates an Iterator type */
      Iterator(items, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
      }
      /** `[JavaScript]` Extracts the Parameters from the given Function type */
      Parameters(schema2, options = {}) {
        return this.Tuple(schema2.parameters, { ...options });
      }
      /** `[JavaScript]` Creates a Promise type */
      Promise(item, options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
      }
      /** `[Extended]` Creates a String type */
      RegExp(unresolved, options = {}) {
        const pattern3 = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
        return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern: pattern3 });
      }
      /**
       * @deprecated Use `Type.RegExp`
       */
      RegEx(regex, options = {}) {
        return this.RegExp(regex, options);
      }
      /** `[JavaScript]` Extracts the ReturnType from the given Function type */
      ReturnType(schema2, options = {}) {
        return TypeClone.Type(schema2.returns, options);
      }
      /** `[JavaScript]` Creates a Symbol type */
      Symbol(options) {
        return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
      }
      /** `[JavaScript]` Creates a Undefined type */
      Undefined(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
      }
      /** `[JavaScript]` Creates a Uint8Array type */
      Uint8Array(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
      }
      /** `[JavaScript]` Creates a Void type */
      Void(options = {}) {
        return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
      }
    };
    exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
    exports.JsonType = new JsonTypeBuilder();
    exports.Type = new JavaScriptTypeBuilder();
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/guard.js
var require_guard = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/guard.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = void 0;
    function IsAsyncIterator(value) {
      return IsObject(value) && Symbol.asyncIterator in value;
    }
    exports.IsAsyncIterator = IsAsyncIterator;
    function IsIterator(value) {
      return IsObject(value) && Symbol.iterator in value;
    }
    exports.IsIterator = IsIterator;
    function IsTypedArray(value) {
      return ArrayBuffer.isView(value);
    }
    exports.IsTypedArray = IsTypedArray;
    function IsPromise(value) {
      return value instanceof Promise;
    }
    exports.IsPromise = IsPromise;
    function IsUint8Array(value) {
      return value instanceof Uint8Array;
    }
    exports.IsUint8Array = IsUint8Array;
    function IsDate(value) {
      return value instanceof Date && Number.isFinite(value.getTime());
    }
    exports.IsDate = IsDate;
    function HasPropertyKey(value, key) {
      return key in value;
    }
    exports.HasPropertyKey = HasPropertyKey;
    function IsPlainObject(value) {
      return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
    }
    exports.IsPlainObject = IsPlainObject;
    function IsObject(value) {
      return value !== null && typeof value === "object";
    }
    exports.IsObject = IsObject;
    function IsArray(value) {
      return Array.isArray(value) && !ArrayBuffer.isView(value);
    }
    exports.IsArray = IsArray;
    function IsUndefined(value) {
      return value === void 0;
    }
    exports.IsUndefined = IsUndefined;
    function IsNull(value) {
      return value === null;
    }
    exports.IsNull = IsNull;
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    exports.IsBoolean = IsBoolean;
    function IsNumber(value) {
      return typeof value === "number";
    }
    exports.IsNumber = IsNumber;
    function IsInteger(value) {
      return IsNumber(value) && Number.isInteger(value);
    }
    exports.IsInteger = IsInteger;
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    exports.IsBigInt = IsBigInt;
    function IsString(value) {
      return typeof value === "string";
    }
    exports.IsString = IsString;
    function IsFunction(value) {
      return typeof value === "function";
    }
    exports.IsFunction = IsFunction;
    function IsSymbol(value) {
      return typeof value === "symbol";
    }
    exports.IsSymbol = IsSymbol;
    function IsValueType(value) {
      return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
    }
    exports.IsValueType = IsValueType;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/system.js
var require_system = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultErrorFunction = exports.TypeSystemPolicy = exports.TypeSystemErrorFunction = exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;
    var guard_1 = require_guard();
    var errors_1 = require_errors();
    var Types = require_typebox();
    var TypeSystemDuplicateTypeKind = class extends Types.TypeBoxError {
      constructor(kind) {
        super(`Duplicate type kind '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
    var TypeSystemDuplicateFormat = class extends Types.TypeBoxError {
      constructor(kind) {
        super(`Duplicate string format '${kind}' detected`);
      }
    };
    exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
    var TypeSystem;
    (function(TypeSystem2) {
      function Type11(kind, check) {
        if (Types.TypeRegistry.Has(kind))
          throw new TypeSystemDuplicateTypeKind(kind);
        Types.TypeRegistry.Set(kind, check);
        return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
      }
      TypeSystem2.Type = Type11;
      function Format(format, check) {
        if (Types.FormatRegistry.Has(format))
          throw new TypeSystemDuplicateFormat(format);
        Types.FormatRegistry.Set(format, check);
        return format;
      }
      TypeSystem2.Format = Format;
    })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
    var TypeSystemErrorFunction;
    (function(TypeSystemErrorFunction2) {
      let errorMessageFunction = DefaultErrorFunction;
      function Reset() {
        errorMessageFunction = DefaultErrorFunction;
      }
      TypeSystemErrorFunction2.Reset = Reset;
      function Set2(callback) {
        errorMessageFunction = callback;
      }
      TypeSystemErrorFunction2.Set = Set2;
      function Get() {
        return errorMessageFunction;
      }
      TypeSystemErrorFunction2.Get = Get;
    })(TypeSystemErrorFunction || (exports.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
    var TypeSystemPolicy;
    (function(TypeSystemPolicy2) {
      TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
      TypeSystemPolicy2.AllowArrayObject = false;
      TypeSystemPolicy2.AllowNaN = false;
      TypeSystemPolicy2.AllowNullVoid = false;
      function IsExactOptionalProperty(value, key) {
        return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== void 0;
      }
      TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        const isObject2 = (0, guard_1.IsObject)(value);
        return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !(0, guard_1.IsArray)(value);
      }
      TypeSystemPolicy2.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
      }
      TypeSystemPolicy2.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        const isNumber = (0, guard_1.IsNumber)(value);
        return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
      }
      TypeSystemPolicy2.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        const isUndefined = (0, guard_1.IsUndefined)(value);
        return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
      }
      TypeSystemPolicy2.IsVoidLike = IsVoidLike;
    })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
    function DefaultErrorFunction(schema2, errorType) {
      switch (errorType) {
        case errors_1.ValueErrorType.ArrayContains:
          return "Expected array to contain at least one matching value";
        case errors_1.ValueErrorType.ArrayMaxContains:
          return `Expected array to contain no more than ${schema2.maxContains} matching values`;
        case errors_1.ValueErrorType.ArrayMinContains:
          return `Expected array to contain at least ${schema2.minContains} matching values`;
        case errors_1.ValueErrorType.ArrayMaxItems:
          return `Expected array length to be less or equal to ${schema2.maxItems}`;
        case errors_1.ValueErrorType.ArrayMinItems:
          return `Expected array length to be greater or equal to ${schema2.minItems}`;
        case errors_1.ValueErrorType.ArrayUniqueItems:
          return "Expected array elements to be unique";
        case errors_1.ValueErrorType.Array:
          return "Expected array";
        case errors_1.ValueErrorType.AsyncIterator:
          return "Expected AsyncIterator";
        case errors_1.ValueErrorType.BigIntExclusiveMaximum:
          return `Expected bigint to be less than ${schema2.exclusiveMaximum}`;
        case errors_1.ValueErrorType.BigIntExclusiveMinimum:
          return `Expected bigint to be greater than ${schema2.exclusiveMinimum}`;
        case errors_1.ValueErrorType.BigIntMaximum:
          return `Expected bigint to be less or equal to ${schema2.maximum}`;
        case errors_1.ValueErrorType.BigIntMinimum:
          return `Expected bigint to be greater or equal to ${schema2.minimum}`;
        case errors_1.ValueErrorType.BigIntMultipleOf:
          return `Expected bigint to be a multiple of ${schema2.multipleOf}`;
        case errors_1.ValueErrorType.BigInt:
          return "Expected bigint";
        case errors_1.ValueErrorType.Boolean:
          return "Expected boolean";
        case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
          return `Expected Date timestamp to be greater than ${schema2.exclusiveMinimumTimestamp}`;
        case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
          return `Expected Date timestamp to be less than ${schema2.exclusiveMaximumTimestamp}`;
        case errors_1.ValueErrorType.DateMinimumTimestamp:
          return `Expected Date timestamp to be greater or equal to ${schema2.minimumTimestamp}`;
        case errors_1.ValueErrorType.DateMaximumTimestamp:
          return `Expected Date timestamp to be less or equal to ${schema2.maximumTimestamp}`;
        case errors_1.ValueErrorType.DateMultipleOfTimestamp:
          return `Expected Date timestamp to be a multiple of ${schema2.multipleOfTimestamp}`;
        case errors_1.ValueErrorType.Date:
          return "Expected Date";
        case errors_1.ValueErrorType.Function:
          return "Expected function";
        case errors_1.ValueErrorType.IntegerExclusiveMaximum:
          return `Expected integer to be less than ${schema2.exclusiveMaximum}`;
        case errors_1.ValueErrorType.IntegerExclusiveMinimum:
          return `Expected integer to be greater than ${schema2.exclusiveMinimum}`;
        case errors_1.ValueErrorType.IntegerMaximum:
          return `Expected integer to be less or equal to ${schema2.maximum}`;
        case errors_1.ValueErrorType.IntegerMinimum:
          return `Expected integer to be greater or equal to ${schema2.minimum}`;
        case errors_1.ValueErrorType.IntegerMultipleOf:
          return `Expected integer to be a multiple of ${schema2.multipleOf}`;
        case errors_1.ValueErrorType.Integer:
          return "Expected integer";
        case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.Intersect:
          return "Expected all values to match";
        case errors_1.ValueErrorType.Iterator:
          return "Expected Iterator";
        case errors_1.ValueErrorType.Literal:
          return `Expected ${typeof schema2.const === "string" ? `'${schema2.const}'` : schema2.const}`;
        case errors_1.ValueErrorType.Never:
          return "Never";
        case errors_1.ValueErrorType.Not:
          return "Value should not match";
        case errors_1.ValueErrorType.Null:
          return "Expected null";
        case errors_1.ValueErrorType.NumberExclusiveMaximum:
          return `Expected number to be less than ${schema2.exclusiveMaximum}`;
        case errors_1.ValueErrorType.NumberExclusiveMinimum:
          return `Expected number to be greater than ${schema2.exclusiveMinimum}`;
        case errors_1.ValueErrorType.NumberMaximum:
          return `Expected number to be less or equal to ${schema2.maximum}`;
        case errors_1.ValueErrorType.NumberMinimum:
          return `Expected number to be greater or equal to ${schema2.minimum}`;
        case errors_1.ValueErrorType.NumberMultipleOf:
          return `Expected number to be a multiple of ${schema2.multipleOf}`;
        case errors_1.ValueErrorType.Number:
          return "Expected number";
        case errors_1.ValueErrorType.Object:
          return "Expected object";
        case errors_1.ValueErrorType.ObjectAdditionalProperties:
          return "Unexpected property";
        case errors_1.ValueErrorType.ObjectMaxProperties:
          return `Expected object to have no more than ${schema2.maxProperties} properties`;
        case errors_1.ValueErrorType.ObjectMinProperties:
          return `Expected object to have at least ${schema2.minProperties} properties`;
        case errors_1.ValueErrorType.ObjectRequiredProperty:
          return "Required property";
        case errors_1.ValueErrorType.Promise:
          return "Expected Promise";
        case errors_1.ValueErrorType.StringFormatUnknown:
          return `Unknown format '${schema2.format}'`;
        case errors_1.ValueErrorType.StringFormat:
          return `Expected string to match '${schema2.format}' format`;
        case errors_1.ValueErrorType.StringMaxLength:
          return `Expected string length less or equal to ${schema2.maxLength}`;
        case errors_1.ValueErrorType.StringMinLength:
          return `Expected string length greater or equal to ${schema2.minLength}`;
        case errors_1.ValueErrorType.StringPattern:
          return `Expected string to match '${schema2.pattern}'`;
        case errors_1.ValueErrorType.String:
          return "Expected string";
        case errors_1.ValueErrorType.Symbol:
          return "Expected symbol";
        case errors_1.ValueErrorType.TupleLength:
          return `Expected tuple to have ${schema2.maxItems || 0} elements`;
        case errors_1.ValueErrorType.Tuple:
          return "Expected tuple";
        case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
          return `Expected byte length less or equal to ${schema2.maxByteLength}`;
        case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
          return `Expected byte length greater or equal to ${schema2.minByteLength}`;
        case errors_1.ValueErrorType.Uint8Array:
          return "Expected Uint8Array";
        case errors_1.ValueErrorType.Undefined:
          return "Expected undefined";
        case errors_1.ValueErrorType.Union:
          return "Expected union value";
        case errors_1.ValueErrorType.Void:
          return "Expected void";
        case errors_1.ValueErrorType.Kind:
          return `Expected kind '${schema2[Types.Kind]}'`;
        default:
          return "Unknown error type";
      }
    }
    exports.DefaultErrorFunction = DefaultErrorFunction;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/deref.js
var require_deref = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/deref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deref = exports.TypeDereferenceError = void 0;
    var typebox_1 = require_typebox();
    var TypeDereferenceError = class extends typebox_1.TypeBoxError {
      constructor(schema2) {
        super(`Unable to dereference schema with $id '${schema2.$id}'`);
        this.schema = schema2;
      }
    };
    exports.TypeDereferenceError = TypeDereferenceError;
    function Deref(schema2, references) {
      const index2 = references.findIndex((target) => target.$id === schema2.$ref);
      if (index2 === -1)
        throw new TypeDereferenceError(schema2);
      return references[index2];
    }
    exports.Deref = Deref;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/hash.js
var require_hash = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = exports.ByteMarker = exports.ValueHashError = void 0;
    var guard_1 = require_guard();
    var ValueHashError = class extends Error {
      constructor(value) {
        super(`Unable to hash value`);
        this.value = value;
      }
    };
    exports.ValueHashError = ValueHashError;
    var ByteMarker;
    (function(ByteMarker2) {
      ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
      ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
      ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
      ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
      ByteMarker2[ByteMarker2["String"] = 4] = "String";
      ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
      ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
      ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
      ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
      ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
      ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
    })(ByteMarker || (exports.ByteMarker = ByteMarker = {}));
    var Accumulator = BigInt("14695981039346656037");
    var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
    var Bytes = Array.from({ length: 256 }).map((_2, i4) => BigInt(i4));
    var F64 = new Float64Array(1);
    var F64In = new DataView(F64.buffer);
    var F64Out = new Uint8Array(F64.buffer);
    function* NumberToBytes(value) {
      const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
      for (let i4 = 0; i4 < byteCount; i4++) {
        yield value >> 8 * (byteCount - 1 - i4) & 255;
      }
    }
    function ArrayType(value) {
      FNV1A64(ByteMarker.Array);
      for (const item of value) {
        Visit(item);
      }
    }
    function BooleanType(value) {
      FNV1A64(ByteMarker.Boolean);
      FNV1A64(value ? 1 : 0);
    }
    function BigIntType(value) {
      FNV1A64(ByteMarker.BigInt);
      F64In.setBigInt64(0, value);
      for (const byte of F64Out) {
        FNV1A64(byte);
      }
    }
    function DateType(value) {
      FNV1A64(ByteMarker.Date);
      Visit(value.getTime());
    }
    function NullType(value) {
      FNV1A64(ByteMarker.Null);
    }
    function NumberType(value) {
      FNV1A64(ByteMarker.Number);
      F64In.setFloat64(0, value);
      for (const byte of F64Out) {
        FNV1A64(byte);
      }
    }
    function ObjectType(value) {
      FNV1A64(ByteMarker.Object);
      for (const key of globalThis.Object.keys(value).sort()) {
        Visit(key);
        Visit(value[key]);
      }
    }
    function StringType(value) {
      FNV1A64(ByteMarker.String);
      for (let i4 = 0; i4 < value.length; i4++) {
        for (const byte of NumberToBytes(value.charCodeAt(i4))) {
          FNV1A64(byte);
        }
      }
    }
    function SymbolType(value) {
      FNV1A64(ByteMarker.Symbol);
      Visit(value.description);
    }
    function Uint8ArrayType(value) {
      FNV1A64(ByteMarker.Uint8Array);
      for (let i4 = 0; i4 < value.length; i4++) {
        FNV1A64(value[i4]);
      }
    }
    function UndefinedType(value) {
      return FNV1A64(ByteMarker.Undefined);
    }
    function Visit(value) {
      if ((0, guard_1.IsArray)(value))
        return ArrayType(value);
      if ((0, guard_1.IsBoolean)(value))
        return BooleanType(value);
      if ((0, guard_1.IsBigInt)(value))
        return BigIntType(value);
      if ((0, guard_1.IsDate)(value))
        return DateType(value);
      if ((0, guard_1.IsNull)(value))
        return NullType(value);
      if ((0, guard_1.IsNumber)(value))
        return NumberType(value);
      if ((0, guard_1.IsPlainObject)(value))
        return ObjectType(value);
      if ((0, guard_1.IsString)(value))
        return StringType(value);
      if ((0, guard_1.IsSymbol)(value))
        return SymbolType(value);
      if ((0, guard_1.IsUint8Array)(value))
        return Uint8ArrayType(value);
      if ((0, guard_1.IsUndefined)(value))
        return UndefinedType(value);
      throw new ValueHashError(value);
    }
    function FNV1A64(byte) {
      Accumulator = Accumulator ^ Bytes[byte];
      Accumulator = Accumulator * Prime % Size;
    }
    function Hash2(value) {
      Accumulator = BigInt("14695981039346656037");
      Visit(value);
      return Accumulator;
    }
    exports.Hash = Hash2;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/errors.js
var require_errors = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Errors = exports.ValueErrorIterator = exports.EscapeKey = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = void 0;
    var guard_1 = require_guard();
    var system_1 = require_system();
    var deref_1 = require_deref();
    var hash_1 = require_hash();
    var Types = require_typebox();
    var ValueErrorType2;
    (function(ValueErrorType3) {
      ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
      ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
      ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
      ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
      ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
      ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
      ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
      ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
      ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
      ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
      ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
      ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
      ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
      ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
      ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
      ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
      ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
      ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
      ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
      ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
      ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
      ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
      ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
      ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
      ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
      ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
      ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
      ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
      ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
      ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
      ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
      ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
      ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
      ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
      ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
      ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
      ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
      ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
      ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
      ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
      ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
      ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
      ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
      ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
      ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
      ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
      ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
      ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
      ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 48] = "StringFormatUnknown";
      ValueErrorType3[ValueErrorType3["StringFormat"] = 49] = "StringFormat";
      ValueErrorType3[ValueErrorType3["StringMaxLength"] = 50] = "StringMaxLength";
      ValueErrorType3[ValueErrorType3["StringMinLength"] = 51] = "StringMinLength";
      ValueErrorType3[ValueErrorType3["StringPattern"] = 52] = "StringPattern";
      ValueErrorType3[ValueErrorType3["String"] = 53] = "String";
      ValueErrorType3[ValueErrorType3["Symbol"] = 54] = "Symbol";
      ValueErrorType3[ValueErrorType3["TupleLength"] = 55] = "TupleLength";
      ValueErrorType3[ValueErrorType3["Tuple"] = 56] = "Tuple";
      ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
      ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
      ValueErrorType3[ValueErrorType3["Uint8Array"] = 59] = "Uint8Array";
      ValueErrorType3[ValueErrorType3["Undefined"] = 60] = "Undefined";
      ValueErrorType3[ValueErrorType3["Union"] = 61] = "Union";
      ValueErrorType3[ValueErrorType3["Void"] = 62] = "Void";
    })(ValueErrorType2 || (exports.ValueErrorType = ValueErrorType2 = {}));
    var ValueErrorsUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
    function EscapeKey(key) {
      return key.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.EscapeKey = EscapeKey;
    function IsDefined(value) {
      return value !== void 0;
    }
    var ValueErrorIterator = class {
      constructor(iterator) {
        this.iterator = iterator;
      }
      [Symbol.iterator]() {
        return this.iterator;
      }
      /** Returns the first value error or undefined if no errors */
      First() {
        const next = this.iterator.next();
        return next.done ? void 0 : next.value;
      }
    };
    exports.ValueErrorIterator = ValueErrorIterator;
    function Create(type, schema2, path, value) {
      return { type, schema: schema2, path, value, message: system_1.TypeSystemErrorFunction.Get()(schema2, type) };
    }
    function* TAny(schema2, references, path, value) {
    }
    function* TArray(schema2, references, path, value) {
      if (!(0, guard_1.IsArray)(value)) {
        return yield Create(ValueErrorType2.Array, schema2, path, value);
      }
      if (IsDefined(schema2.minItems) && !(value.length >= schema2.minItems)) {
        yield Create(ValueErrorType2.ArrayMinItems, schema2, path, value);
      }
      if (IsDefined(schema2.maxItems) && !(value.length <= schema2.maxItems)) {
        yield Create(ValueErrorType2.ArrayMaxItems, schema2, path, value);
      }
      for (let i4 = 0; i4 < value.length; i4++) {
        yield* Visit(schema2.items, references, `${path}/${i4}`, value[i4]);
      }
      if (schema2.uniqueItems === true && !function() {
        const set = /* @__PURE__ */ new Set();
        for (const element of value) {
          const hashed = (0, hash_1.Hash)(element);
          if (set.has(hashed)) {
            return false;
          } else {
            set.add(hashed);
          }
        }
        return true;
      }()) {
        yield Create(ValueErrorType2.ArrayUniqueItems, schema2, path, value);
      }
      if (!(IsDefined(schema2.contains) || IsDefined(schema2.minContains) || IsDefined(schema2.maxContains))) {
        return;
      }
      const containsSchema = IsDefined(schema2.contains) ? schema2.contains : Types.Type.Never();
      const containsCount = value.reduce((acc, value2, index2) => Visit(containsSchema, references, `${path}${index2}`, value2).next().done === true ? acc + 1 : acc, 0);
      if (containsCount === 0) {
        yield Create(ValueErrorType2.ArrayContains, schema2, path, value);
      }
      if ((0, guard_1.IsNumber)(schema2.minContains) && containsCount < schema2.minContains) {
        yield Create(ValueErrorType2.ArrayMinContains, schema2, path, value);
      }
      if ((0, guard_1.IsNumber)(schema2.maxContains) && containsCount > schema2.maxContains) {
        yield Create(ValueErrorType2.ArrayMaxContains, schema2, path, value);
      }
    }
    function* TAsyncIterator(schema2, references, path, value) {
      if (!(0, guard_1.IsAsyncIterator)(value))
        yield Create(ValueErrorType2.AsyncIterator, schema2, path, value);
    }
    function* TBigInt(schema2, references, path, value) {
      if (!(0, guard_1.IsBigInt)(value))
        return yield Create(ValueErrorType2.BigInt, schema2, path, value);
      if (IsDefined(schema2.exclusiveMaximum) && !(value < schema2.exclusiveMaximum)) {
        yield Create(ValueErrorType2.BigIntExclusiveMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.exclusiveMinimum) && !(value > schema2.exclusiveMinimum)) {
        yield Create(ValueErrorType2.BigIntExclusiveMinimum, schema2, path, value);
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        yield Create(ValueErrorType2.BigIntMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        yield Create(ValueErrorType2.BigIntMinimum, schema2, path, value);
      }
      if (IsDefined(schema2.multipleOf) && !(value % schema2.multipleOf === BigInt(0))) {
        yield Create(ValueErrorType2.BigIntMultipleOf, schema2, path, value);
      }
    }
    function* TBoolean(schema2, references, path, value) {
      if (!(0, guard_1.IsBoolean)(value))
        yield Create(ValueErrorType2.Boolean, schema2, path, value);
    }
    function* TConstructor(schema2, references, path, value) {
      yield* Visit(schema2.returns, references, path, value.prototype);
    }
    function* TDate(schema2, references, path, value) {
      if (!(0, guard_1.IsDate)(value))
        return yield Create(ValueErrorType2.Date, schema2, path, value);
      if (IsDefined(schema2.exclusiveMaximumTimestamp) && !(value.getTime() < schema2.exclusiveMaximumTimestamp)) {
        yield Create(ValueErrorType2.DateExclusiveMaximumTimestamp, schema2, path, value);
      }
      if (IsDefined(schema2.exclusiveMinimumTimestamp) && !(value.getTime() > schema2.exclusiveMinimumTimestamp)) {
        yield Create(ValueErrorType2.DateExclusiveMinimumTimestamp, schema2, path, value);
      }
      if (IsDefined(schema2.maximumTimestamp) && !(value.getTime() <= schema2.maximumTimestamp)) {
        yield Create(ValueErrorType2.DateMaximumTimestamp, schema2, path, value);
      }
      if (IsDefined(schema2.minimumTimestamp) && !(value.getTime() >= schema2.minimumTimestamp)) {
        yield Create(ValueErrorType2.DateMinimumTimestamp, schema2, path, value);
      }
      if (IsDefined(schema2.multipleOfTimestamp) && !(value.getTime() % schema2.multipleOfTimestamp === 0)) {
        yield Create(ValueErrorType2.DateMultipleOfTimestamp, schema2, path, value);
      }
    }
    function* TFunction(schema2, references, path, value) {
      if (!(0, guard_1.IsFunction)(value))
        yield Create(ValueErrorType2.Function, schema2, path, value);
    }
    function* TInteger(schema2, references, path, value) {
      if (!(0, guard_1.IsInteger)(value))
        return yield Create(ValueErrorType2.Integer, schema2, path, value);
      if (IsDefined(schema2.exclusiveMaximum) && !(value < schema2.exclusiveMaximum)) {
        yield Create(ValueErrorType2.IntegerExclusiveMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.exclusiveMinimum) && !(value > schema2.exclusiveMinimum)) {
        yield Create(ValueErrorType2.IntegerExclusiveMinimum, schema2, path, value);
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        yield Create(ValueErrorType2.IntegerMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        yield Create(ValueErrorType2.IntegerMinimum, schema2, path, value);
      }
      if (IsDefined(schema2.multipleOf) && !(value % schema2.multipleOf === 0)) {
        yield Create(ValueErrorType2.IntegerMultipleOf, schema2, path, value);
      }
    }
    function* TIntersect(schema2, references, path, value) {
      for (const inner of schema2.allOf) {
        const next = Visit(inner, references, path, value).next();
        if (!next.done) {
          yield Create(ValueErrorType2.Intersect, schema2, path, value);
          yield next.value;
        }
      }
      if (schema2.unevaluatedProperties === false) {
        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            yield Create(ValueErrorType2.IntersectUnevaluatedProperties, schema2, `${path}/${valueKey}`, value);
          }
        }
      }
      if (typeof schema2.unevaluatedProperties === "object") {
        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        for (const valueKey of Object.getOwnPropertyNames(value)) {
          if (!keyCheck.test(valueKey)) {
            const next = Visit(schema2.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
            if (!next.done)
              yield next.value;
          }
        }
      }
    }
    function* TIterator(schema2, references, path, value) {
      if (!(0, guard_1.IsIterator)(value))
        yield Create(ValueErrorType2.Iterator, schema2, path, value);
    }
    function* TLiteral(schema2, references, path, value) {
      if (!(value === schema2.const))
        yield Create(ValueErrorType2.Literal, schema2, path, value);
    }
    function* TNever(schema2, references, path, value) {
      yield Create(ValueErrorType2.Never, schema2, path, value);
    }
    function* TNot(schema2, references, path, value) {
      if (Visit(schema2.not, references, path, value).next().done === true)
        yield Create(ValueErrorType2.Not, schema2, path, value);
    }
    function* TNull(schema2, references, path, value) {
      if (!(0, guard_1.IsNull)(value))
        yield Create(ValueErrorType2.Null, schema2, path, value);
    }
    function* TNumber(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsNumberLike(value))
        return yield Create(ValueErrorType2.Number, schema2, path, value);
      if (IsDefined(schema2.exclusiveMaximum) && !(value < schema2.exclusiveMaximum)) {
        yield Create(ValueErrorType2.NumberExclusiveMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.exclusiveMinimum) && !(value > schema2.exclusiveMinimum)) {
        yield Create(ValueErrorType2.NumberExclusiveMinimum, schema2, path, value);
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        yield Create(ValueErrorType2.NumberMaximum, schema2, path, value);
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        yield Create(ValueErrorType2.NumberMinimum, schema2, path, value);
      }
      if (IsDefined(schema2.multipleOf) && !(value % schema2.multipleOf === 0)) {
        yield Create(ValueErrorType2.NumberMultipleOf, schema2, path, value);
      }
    }
    function* TObject(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsObjectLike(value))
        return yield Create(ValueErrorType2.Object, schema2, path, value);
      if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)) {
        yield Create(ValueErrorType2.ObjectMinProperties, schema2, path, value);
      }
      if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)) {
        yield Create(ValueErrorType2.ObjectMaxProperties, schema2, path, value);
      }
      const requiredKeys = Array.isArray(schema2.required) ? schema2.required : [];
      const knownKeys = Object.getOwnPropertyNames(schema2.properties);
      const unknownKeys = Object.getOwnPropertyNames(value);
      for (const requiredKey of requiredKeys) {
        if (unknownKeys.includes(requiredKey))
          continue;
        yield Create(ValueErrorType2.ObjectRequiredProperty, schema2.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);
      }
      if (schema2.additionalProperties === false) {
        for (const valueKey of unknownKeys) {
          if (!knownKeys.includes(valueKey)) {
            yield Create(ValueErrorType2.ObjectAdditionalProperties, schema2, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
          }
        }
      }
      if (typeof schema2.additionalProperties === "object") {
        for (const valueKey of unknownKeys) {
          if (knownKeys.includes(valueKey))
            continue;
          yield* Visit(schema2.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
      for (const knownKey of knownKeys) {
        const property = schema2.properties[knownKey];
        if (schema2.required && schema2.required.includes(knownKey)) {
          yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
          if (Types.ExtendsUndefined.Check(schema2) && !(knownKey in value)) {
            yield Create(ValueErrorType2.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0);
          }
        } else {
          if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
            yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
          }
        }
      }
    }
    function* TPromise(schema2, references, path, value) {
      if (!(0, guard_1.IsPromise)(value))
        yield Create(ValueErrorType2.Promise, schema2, path, value);
    }
    function* TRecord(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsRecordLike(value))
        return yield Create(ValueErrorType2.Object, schema2, path, value);
      if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)) {
        yield Create(ValueErrorType2.ObjectMinProperties, schema2, path, value);
      }
      if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)) {
        yield Create(ValueErrorType2.ObjectMaxProperties, schema2, path, value);
      }
      const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];
      const regex = new RegExp(patternKey);
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
      if (typeof schema2.additionalProperties === "object") {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (!regex.test(propertyKey))
            yield* Visit(schema2.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
      }
      if (schema2.additionalProperties === false) {
        for (const [propertyKey, propertyValue] of Object.entries(value)) {
          if (regex.test(propertyKey))
            continue;
          return yield Create(ValueErrorType2.ObjectAdditionalProperties, schema2, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
        }
      }
    }
    function* TRef(schema2, references, path, value) {
      yield* Visit((0, deref_1.Deref)(schema2, references), references, path, value);
    }
    function* TString(schema2, references, path, value) {
      if (!(0, guard_1.IsString)(value))
        return yield Create(ValueErrorType2.String, schema2, path, value);
      if (IsDefined(schema2.minLength) && !(value.length >= schema2.minLength)) {
        yield Create(ValueErrorType2.StringMinLength, schema2, path, value);
      }
      if (IsDefined(schema2.maxLength) && !(value.length <= schema2.maxLength)) {
        yield Create(ValueErrorType2.StringMaxLength, schema2, path, value);
      }
      if ((0, guard_1.IsString)(schema2.pattern)) {
        const regex = new RegExp(schema2.pattern);
        if (!regex.test(value)) {
          yield Create(ValueErrorType2.StringPattern, schema2, path, value);
        }
      }
      if ((0, guard_1.IsString)(schema2.format)) {
        if (!Types.FormatRegistry.Has(schema2.format)) {
          yield Create(ValueErrorType2.StringFormatUnknown, schema2, path, value);
        } else {
          const format = Types.FormatRegistry.Get(schema2.format);
          if (!format(value)) {
            yield Create(ValueErrorType2.StringFormat, schema2, path, value);
          }
        }
      }
    }
    function* TSymbol(schema2, references, path, value) {
      if (!(0, guard_1.IsSymbol)(value))
        yield Create(ValueErrorType2.Symbol, schema2, path, value);
    }
    function* TTemplateLiteral(schema2, references, path, value) {
      if (!(0, guard_1.IsString)(value))
        return yield Create(ValueErrorType2.String, schema2, path, value);
      const regex = new RegExp(schema2.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType2.StringPattern, schema2, path, value);
      }
    }
    function* TThis(schema2, references, path, value) {
      yield* Visit((0, deref_1.Deref)(schema2, references), references, path, value);
    }
    function* TTuple(schema2, references, path, value) {
      if (!(0, guard_1.IsArray)(value))
        return yield Create(ValueErrorType2.Tuple, schema2, path, value);
      if (schema2.items === void 0 && !(value.length === 0)) {
        return yield Create(ValueErrorType2.TupleLength, schema2, path, value);
      }
      if (!(value.length === schema2.maxItems)) {
        return yield Create(ValueErrorType2.TupleLength, schema2, path, value);
      }
      if (!schema2.items) {
        return;
      }
      for (let i4 = 0; i4 < schema2.items.length; i4++) {
        yield* Visit(schema2.items[i4], references, `${path}/${i4}`, value[i4]);
      }
    }
    function* TUndefined(schema2, references, path, value) {
      if (!(0, guard_1.IsUndefined)(value))
        yield Create(ValueErrorType2.Undefined, schema2, path, value);
    }
    function* TUnion(schema2, references, path, value) {
      let count = 0;
      for (const subschema of schema2.anyOf) {
        const errors = [...Visit(subschema, references, path, value)];
        if (errors.length === 0)
          return;
        count += errors.length;
      }
      if (count > 0) {
        yield Create(ValueErrorType2.Union, schema2, path, value);
      }
    }
    function* TUint8Array(schema2, references, path, value) {
      if (!(0, guard_1.IsUint8Array)(value))
        return yield Create(ValueErrorType2.Uint8Array, schema2, path, value);
      if (IsDefined(schema2.maxByteLength) && !(value.length <= schema2.maxByteLength)) {
        yield Create(ValueErrorType2.Uint8ArrayMaxByteLength, schema2, path, value);
      }
      if (IsDefined(schema2.minByteLength) && !(value.length >= schema2.minByteLength)) {
        yield Create(ValueErrorType2.Uint8ArrayMinByteLength, schema2, path, value);
      }
    }
    function* TUnknown(schema2, references, path, value) {
    }
    function* TVoid(schema2, references, path, value) {
      if (!system_1.TypeSystemPolicy.IsVoidLike(value))
        yield Create(ValueErrorType2.Void, schema2, path, value);
    }
    function* TKind(schema2, references, path, value) {
      const check = Types.TypeRegistry.Get(schema2[Types.Kind]);
      if (!check(schema2, value))
        yield Create(ValueErrorType2.Kind, schema2, path, value);
    }
    function* Visit(schema2, references, path, value) {
      const references_ = IsDefined(schema2.$id) ? [...references, schema2] : references;
      const schema_ = schema2;
      switch (schema_[Types.Kind]) {
        case "Any":
          return yield* TAny(schema_, references_, path, value);
        case "Array":
          return yield* TArray(schema_, references_, path, value);
        case "AsyncIterator":
          return yield* TAsyncIterator(schema_, references_, path, value);
        case "BigInt":
          return yield* TBigInt(schema_, references_, path, value);
        case "Boolean":
          return yield* TBoolean(schema_, references_, path, value);
        case "Constructor":
          return yield* TConstructor(schema_, references_, path, value);
        case "Date":
          return yield* TDate(schema_, references_, path, value);
        case "Function":
          return yield* TFunction(schema_, references_, path, value);
        case "Integer":
          return yield* TInteger(schema_, references_, path, value);
        case "Intersect":
          return yield* TIntersect(schema_, references_, path, value);
        case "Iterator":
          return yield* TIterator(schema_, references_, path, value);
        case "Literal":
          return yield* TLiteral(schema_, references_, path, value);
        case "Never":
          return yield* TNever(schema_, references_, path, value);
        case "Not":
          return yield* TNot(schema_, references_, path, value);
        case "Null":
          return yield* TNull(schema_, references_, path, value);
        case "Number":
          return yield* TNumber(schema_, references_, path, value);
        case "Object":
          return yield* TObject(schema_, references_, path, value);
        case "Promise":
          return yield* TPromise(schema_, references_, path, value);
        case "Record":
          return yield* TRecord(schema_, references_, path, value);
        case "Ref":
          return yield* TRef(schema_, references_, path, value);
        case "String":
          return yield* TString(schema_, references_, path, value);
        case "Symbol":
          return yield* TSymbol(schema_, references_, path, value);
        case "TemplateLiteral":
          return yield* TTemplateLiteral(schema_, references_, path, value);
        case "This":
          return yield* TThis(schema_, references_, path, value);
        case "Tuple":
          return yield* TTuple(schema_, references_, path, value);
        case "Undefined":
          return yield* TUndefined(schema_, references_, path, value);
        case "Union":
          return yield* TUnion(schema_, references_, path, value);
        case "Uint8Array":
          return yield* TUint8Array(schema_, references_, path, value);
        case "Unknown":
          return yield* TUnknown(schema_, references_, path, value);
        case "Void":
          return yield* TVoid(schema_, references_, path, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueErrorsUnknownTypeError(schema2);
          return yield* TKind(schema_, references_, path, value);
      }
    }
    function Errors2(...args) {
      const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
      return new ValueErrorIterator(iterator);
    }
    exports.Errors = Errors2;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/index.js
var require_errors2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/errors/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o5, k22, desc);
    } : function(o5, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o5[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors(), exports);
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/pointer.js
var require_pointer = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/pointer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = void 0;
    var ValuePointerRootSetError = class extends Error {
      constructor(value, path, update2) {
        super("Cannot set root value");
        this.value = value;
        this.path = path;
        this.update = update2;
      }
    };
    exports.ValuePointerRootSetError = ValuePointerRootSetError;
    var ValuePointerRootDeleteError = class extends Error {
      constructor(value, path) {
        super("Cannot delete root value");
        this.value = value;
        this.path = path;
      }
    };
    exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
    var ValuePointer;
    (function(ValuePointer2) {
      function Escape(component) {
        return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      function* Format(pointer) {
        if (pointer === "")
          return;
        let [start, end] = [0, 0];
        for (let i4 = 0; i4 < pointer.length; i4++) {
          const char = pointer.charAt(i4);
          if (char === "/") {
            if (i4 === 0) {
              start = i4 + 1;
            } else {
              end = i4;
              yield Escape(pointer.slice(start, end));
              start = i4 + 1;
            }
          } else {
            end = i4;
          }
        }
        yield Escape(pointer.slice(start));
      }
      ValuePointer2.Format = Format;
      function Set2(value, pointer, update2) {
        if (pointer === "")
          throw new ValuePointerRootSetError(value, pointer, update2);
        let [owner, next, key] = [null, value, ""];
        for (const component of Format(pointer)) {
          if (next[component] === void 0)
            next[component] = {};
          owner = next;
          next = next[component];
          key = component;
        }
        owner[key] = update2;
      }
      ValuePointer2.Set = Set2;
      function Delete(value, pointer) {
        if (pointer === "")
          throw new ValuePointerRootDeleteError(value, pointer);
        let [owner, next, key] = [null, value, ""];
        for (const component of Format(pointer)) {
          if (next[component] === void 0 || next[component] === null)
            return;
          owner = next;
          next = next[component];
          key = component;
        }
        if (Array.isArray(owner)) {
          const index2 = parseInt(key);
          owner.splice(index2, 1);
        } else {
          delete owner[key];
        }
      }
      ValuePointer2.Delete = Delete;
      function Has(value, pointer) {
        if (pointer === "")
          return true;
        let [owner, next, key] = [null, value, ""];
        for (const component of Format(pointer)) {
          if (next[component] === void 0)
            return false;
          owner = next;
          next = next[component];
          key = component;
        }
        return Object.getOwnPropertyNames(owner).includes(key);
      }
      ValuePointer2.Has = Has;
      function Get(value, pointer) {
        if (pointer === "")
          return value;
        let current = value;
        for (const component of Format(pointer)) {
          if (current[component] === void 0)
            return void 0;
          current = current[component];
        }
        return current;
      }
      ValuePointer2.Get = Get;
    })(ValuePointer || (exports.ValuePointer = ValuePointer = {}));
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/clone.js
var require_clone = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/clone.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Clone = void 0;
    var guard_1 = require_guard();
    function ObjectType(value) {
      const keys = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];
      return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});
    }
    function ArrayType(value) {
      return value.map((element) => Clone(element));
    }
    function TypedArrayType(value) {
      return value.slice();
    }
    function DateType(value) {
      return new Date(value.toISOString());
    }
    function ValueType(value) {
      return value;
    }
    function Clone(value) {
      if ((0, guard_1.IsArray)(value))
        return ArrayType(value);
      if ((0, guard_1.IsDate)(value))
        return DateType(value);
      if ((0, guard_1.IsPlainObject)(value))
        return ObjectType(value);
      if ((0, guard_1.IsTypedArray)(value))
        return TypedArrayType(value);
      if ((0, guard_1.IsValueType)(value))
        return ValueType(value);
      throw new Error("ValueClone: Unable to clone value");
    }
    exports.Clone = Clone;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/delta.js
var require_delta = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/delta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;
    var guard_1 = require_guard();
    var typebox_1 = require_typebox();
    var pointer_1 = require_pointer();
    var clone_1 = require_clone();
    exports.Insert = typebox_1.Type.Object({
      type: typebox_1.Type.Literal("insert"),
      path: typebox_1.Type.String(),
      value: typebox_1.Type.Unknown()
    });
    exports.Update = typebox_1.Type.Object({
      type: typebox_1.Type.Literal("update"),
      path: typebox_1.Type.String(),
      value: typebox_1.Type.Unknown()
    });
    exports.Delete = typebox_1.Type.Object({
      type: typebox_1.Type.Literal("delete"),
      path: typebox_1.Type.String()
    });
    exports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);
    var ValueDeltaObjectWithSymbolKeyError = class extends Error {
      constructor(key) {
        super("Cannot diff objects with symbol keys");
        this.key = key;
      }
    };
    exports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;
    var ValueDeltaUnableToDiffUnknownValue = class extends Error {
      constructor(value) {
        super("Unable to create diff edits for unknown value");
        this.value = value;
      }
    };
    exports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
    function CreateUpdate(path, value) {
      return { type: "update", path, value };
    }
    function CreateInsert(path, value) {
      return { type: "insert", path, value };
    }
    function CreateDelete(path) {
      return { type: "delete", path };
    }
    function* ObjectType(path, current, next) {
      if (!(0, guard_1.IsPlainObject)(next))
        return yield CreateUpdate(path, next);
      const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
      const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
      for (const key of currentKeys) {
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        if ((0, guard_1.IsUndefined)(next[key]) && nextKeys.includes(key))
          yield CreateUpdate(`${path}/${String(key)}`, void 0);
      }
      for (const key of nextKeys) {
        if ((0, guard_1.IsUndefined)(current[key]) || (0, guard_1.IsUndefined)(next[key]))
          continue;
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        yield* Visit(`${path}/${String(key)}`, current[key], next[key]);
      }
      for (const key of nextKeys) {
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        if ((0, guard_1.IsUndefined)(current[key]))
          yield CreateInsert(`${path}/${String(key)}`, next[key]);
      }
      for (const key of currentKeys.reverse()) {
        if ((0, guard_1.IsSymbol)(key))
          throw new ValueDeltaObjectWithSymbolKeyError(key);
        if ((0, guard_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
          yield CreateDelete(`${path}/${String(key)}`);
      }
    }
    function* ArrayType(path, current, next) {
      if (!(0, guard_1.IsArray)(next))
        return yield CreateUpdate(path, next);
      for (let i4 = 0; i4 < Math.min(current.length, next.length); i4++) {
        yield* Visit(`${path}/${i4}`, current[i4], next[i4]);
      }
      for (let i4 = 0; i4 < next.length; i4++) {
        if (i4 < current.length)
          continue;
        yield CreateInsert(`${path}/${i4}`, next[i4]);
      }
      for (let i4 = current.length - 1; i4 >= 0; i4--) {
        if (i4 < next.length)
          continue;
        yield CreateDelete(`${path}/${i4}`);
      }
    }
    function* TypedArrayType(path, current, next) {
      if (!(0, guard_1.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)
        return yield CreateUpdate(path, next);
      for (let i4 = 0; i4 < Math.min(current.length, next.length); i4++) {
        yield* Visit(`${path}/${i4}`, current[i4], next[i4]);
      }
    }
    function* ValueType(path, current, next) {
      if (current === next)
        return;
      yield CreateUpdate(path, next);
    }
    function* Visit(path, current, next) {
      if ((0, guard_1.IsPlainObject)(current))
        return yield* ObjectType(path, current, next);
      if ((0, guard_1.IsArray)(current))
        return yield* ArrayType(path, current, next);
      if ((0, guard_1.IsTypedArray)(current))
        return yield* TypedArrayType(path, current, next);
      if ((0, guard_1.IsValueType)(current))
        return yield* ValueType(path, current, next);
      throw new ValueDeltaUnableToDiffUnknownValue(current);
    }
    function Diff(current, next) {
      return [...Visit("", current, next)];
    }
    exports.Diff = Diff;
    function IsRootUpdate(edits) {
      return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
    }
    function IsIdentity(edits) {
      return edits.length === 0;
    }
    function Patch(current, edits) {
      if (IsRootUpdate(edits)) {
        return (0, clone_1.Clone)(edits[0].value);
      }
      if (IsIdentity(edits)) {
        return (0, clone_1.Clone)(current);
      }
      const clone2 = (0, clone_1.Clone)(current);
      for (const edit of edits) {
        switch (edit.type) {
          case "insert": {
            pointer_1.ValuePointer.Set(clone2, edit.path, edit.value);
            break;
          }
          case "update": {
            pointer_1.ValuePointer.Set(clone2, edit.path, edit.value);
            break;
          }
          case "delete": {
            pointer_1.ValuePointer.Delete(clone2, edit.path);
            break;
          }
        }
      }
      return clone2;
    }
    exports.Patch = Patch;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/mutate.js
var require_mutate = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/mutate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = void 0;
    var guard_1 = require_guard();
    var pointer_1 = require_pointer();
    var clone_1 = require_clone();
    var ValueMutateTypeMismatchError = class extends Error {
      constructor() {
        super("Cannot assign due type mismatch of assignable values");
      }
    };
    exports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;
    var ValueMutateInvalidRootMutationError = class extends Error {
      constructor() {
        super("Only object and array types can be mutated at the root level");
      }
    };
    exports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
    function ObjectType(root, path, current, next) {
      if (!(0, guard_1.IsPlainObject)(current)) {
        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
      } else {
        const currentKeys = Object.keys(current);
        const nextKeys = Object.keys(next);
        for (const currentKey of currentKeys) {
          if (!nextKeys.includes(currentKey)) {
            delete current[currentKey];
          }
        }
        for (const nextKey of nextKeys) {
          if (!currentKeys.includes(nextKey)) {
            current[nextKey] = null;
          }
        }
        for (const nextKey of nextKeys) {
          Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
        }
      }
    }
    function ArrayType(root, path, current, next) {
      if (!(0, guard_1.IsArray)(current)) {
        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
      } else {
        for (let index2 = 0; index2 < next.length; index2++) {
          Visit(root, `${path}/${index2}`, current[index2], next[index2]);
        }
        current.splice(next.length);
      }
    }
    function TypedArrayType(root, path, current, next) {
      if ((0, guard_1.IsTypedArray)(current) && current.length === next.length) {
        for (let i4 = 0; i4 < current.length; i4++) {
          current[i4] = next[i4];
        }
      } else {
        pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
      }
    }
    function ValueType(root, path, current, next) {
      if (current === next)
        return;
      pointer_1.ValuePointer.Set(root, path, next);
    }
    function Visit(root, path, current, next) {
      if ((0, guard_1.IsArray)(next))
        return ArrayType(root, path, current, next);
      if ((0, guard_1.IsTypedArray)(next))
        return TypedArrayType(root, path, current, next);
      if ((0, guard_1.IsPlainObject)(next))
        return ObjectType(root, path, current, next);
      if ((0, guard_1.IsValueType)(next))
        return ValueType(root, path, current, next);
    }
    function IsNonMutableValue(value) {
      return (0, guard_1.IsTypedArray)(value) || (0, guard_1.IsValueType)(value);
    }
    function IsMismatchedValue(current, next) {
      return (0, guard_1.IsPlainObject)(current) && (0, guard_1.IsArray)(next) || (0, guard_1.IsArray)(current) && (0, guard_1.IsPlainObject)(next);
    }
    function Mutate(current, next) {
      if (IsNonMutableValue(current) || IsNonMutableValue(next))
        throw new ValueMutateInvalidRootMutationError();
      if (IsMismatchedValue(current, next))
        throw new ValueMutateTypeMismatchError();
      Visit(current, "", current, next);
    }
    exports.Mutate = Mutate;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/equal.js
var require_equal = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Equal = void 0;
    var guard_1 = require_guard();
    function ObjectType(left, right) {
      if (!(0, guard_1.IsPlainObject)(right))
        return false;
      const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
      const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
      if (leftKeys.length !== rightKeys.length)
        return false;
      return leftKeys.every((key) => Equal(left[key], right[key]));
    }
    function DateType(left, right) {
      return (0, guard_1.IsDate)(right) && left.getTime() === right.getTime();
    }
    function ArrayType(left, right) {
      if (!(0, guard_1.IsArray)(right) || left.length !== right.length)
        return false;
      return left.every((value, index2) => Equal(value, right[index2]));
    }
    function TypedArrayType(left, right) {
      if (!(0, guard_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
        return false;
      return left.every((value, index2) => Equal(value, right[index2]));
    }
    function ValueType(left, right) {
      return left === right;
    }
    function Equal(left, right) {
      if ((0, guard_1.IsPlainObject)(left))
        return ObjectType(left, right);
      if ((0, guard_1.IsDate)(left))
        return DateType(left, right);
      if ((0, guard_1.IsTypedArray)(left))
        return TypedArrayType(left, right);
      if ((0, guard_1.IsArray)(left))
        return ArrayType(left, right);
      if ((0, guard_1.IsValueType)(left))
        return ValueType(left, right);
      throw new Error("ValueEquals: Unable to compare value");
    }
    exports.Equal = Equal;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/index.js
var require_system2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/system/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o5, k22, desc);
    } : function(o5, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o5[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorType = void 0;
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
      return errors_1.ValueErrorType;
    } });
    __exportStar(require_system(), exports);
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/check.js
var require_check = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/check.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Check = exports.ValueCheckUnknownTypeError = void 0;
    var guard_1 = require_guard();
    var index_1 = require_system2();
    var deref_1 = require_deref();
    var hash_1 = require_hash();
    var Types = require_typebox();
    var ValueCheckUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super(`Unknown type`);
        this.schema = schema2;
      }
    };
    exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
    function IsAnyOrUnknown(schema2) {
      return schema2[Types.Kind] === "Any" || schema2[Types.Kind] === "Unknown";
    }
    function IsDefined(value) {
      return value !== void 0;
    }
    function TAny(schema2, references, value) {
      return true;
    }
    function TArray(schema2, references, value) {
      if (!(0, guard_1.IsArray)(value))
        return false;
      if (IsDefined(schema2.minItems) && !(value.length >= schema2.minItems)) {
        return false;
      }
      if (IsDefined(schema2.maxItems) && !(value.length <= schema2.maxItems)) {
        return false;
      }
      if (!value.every((value2) => Visit(schema2.items, references, value2))) {
        return false;
      }
      if (schema2.uniqueItems === true && !function() {
        const set = /* @__PURE__ */ new Set();
        for (const element of value) {
          const hashed = (0, hash_1.Hash)(element);
          if (set.has(hashed)) {
            return false;
          } else {
            set.add(hashed);
          }
        }
        return true;
      }()) {
        return false;
      }
      if (!(IsDefined(schema2.contains) || (0, guard_1.IsNumber)(schema2.minContains) || (0, guard_1.IsNumber)(schema2.maxContains))) {
        return true;
      }
      const containsSchema = IsDefined(schema2.contains) ? schema2.contains : Types.Type.Never();
      const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
      if (containsCount === 0) {
        return false;
      }
      if ((0, guard_1.IsNumber)(schema2.minContains) && containsCount < schema2.minContains) {
        return false;
      }
      if ((0, guard_1.IsNumber)(schema2.maxContains) && containsCount > schema2.maxContains) {
        return false;
      }
      return true;
    }
    function TAsyncIterator(schema2, references, value) {
      return (0, guard_1.IsAsyncIterator)(value);
    }
    function TBigInt(schema2, references, value) {
      if (!(0, guard_1.IsBigInt)(value))
        return false;
      if (IsDefined(schema2.exclusiveMaximum) && !(value < schema2.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(schema2.exclusiveMinimum) && !(value > schema2.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        return false;
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        return false;
      }
      if (IsDefined(schema2.multipleOf) && !(value % schema2.multipleOf === BigInt(0))) {
        return false;
      }
      return true;
    }
    function TBoolean(schema2, references, value) {
      return (0, guard_1.IsBoolean)(value);
    }
    function TConstructor(schema2, references, value) {
      return Visit(schema2.returns, references, value.prototype);
    }
    function TDate(schema2, references, value) {
      if (!(0, guard_1.IsDate)(value))
        return false;
      if (IsDefined(schema2.exclusiveMaximumTimestamp) && !(value.getTime() < schema2.exclusiveMaximumTimestamp)) {
        return false;
      }
      if (IsDefined(schema2.exclusiveMinimumTimestamp) && !(value.getTime() > schema2.exclusiveMinimumTimestamp)) {
        return false;
      }
      if (IsDefined(schema2.maximumTimestamp) && !(value.getTime() <= schema2.maximumTimestamp)) {
        return false;
      }
      if (IsDefined(schema2.minimumTimestamp) && !(value.getTime() >= schema2.minimumTimestamp)) {
        return false;
      }
      if (IsDefined(schema2.multipleOfTimestamp) && !(value.getTime() % schema2.multipleOfTimestamp === 0)) {
        return false;
      }
      return true;
    }
    function TFunction(schema2, references, value) {
      return (0, guard_1.IsFunction)(value);
    }
    function TInteger(schema2, references, value) {
      if (!(0, guard_1.IsInteger)(value)) {
        return false;
      }
      if (IsDefined(schema2.exclusiveMaximum) && !(value < schema2.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(schema2.exclusiveMinimum) && !(value > schema2.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        return false;
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        return false;
      }
      if (IsDefined(schema2.multipleOf) && !(value % schema2.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function TIntersect(schema2, references, value) {
      const check1 = schema2.allOf.every((schema3) => Visit(schema3, references, value));
      if (schema2.unevaluatedProperties === false) {
        const keyPattern = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
        return check1 && check2;
      } else if (Types.TypeGuard.TSchema(schema2.unevaluatedProperties)) {
        const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema2));
        const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema2.unevaluatedProperties, references, value[key]));
        return check1 && check2;
      } else {
        return check1;
      }
    }
    function TIterator(schema2, references, value) {
      return (0, guard_1.IsIterator)(value);
    }
    function TLiteral(schema2, references, value) {
      return value === schema2.const;
    }
    function TNever(schema2, references, value) {
      return false;
    }
    function TNot(schema2, references, value) {
      return !Visit(schema2.not, references, value);
    }
    function TNull(schema2, references, value) {
      return (0, guard_1.IsNull)(value);
    }
    function TNumber(schema2, references, value) {
      if (!index_1.TypeSystemPolicy.IsNumberLike(value))
        return false;
      if (IsDefined(schema2.exclusiveMaximum) && !(value < schema2.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(schema2.exclusiveMinimum) && !(value > schema2.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(schema2.minimum) && !(value >= schema2.minimum)) {
        return false;
      }
      if (IsDefined(schema2.maximum) && !(value <= schema2.maximum)) {
        return false;
      }
      if (IsDefined(schema2.multipleOf) && !(value % schema2.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function TObject(schema2, references, value) {
      if (!index_1.TypeSystemPolicy.IsObjectLike(value))
        return false;
      if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)) {
        return false;
      }
      if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)) {
        return false;
      }
      const knownKeys = Object.getOwnPropertyNames(schema2.properties);
      for (const knownKey of knownKeys) {
        const property = schema2.properties[knownKey];
        if (schema2.required && schema2.required.includes(knownKey)) {
          if (!Visit(property, references, value[knownKey])) {
            return false;
          }
          if ((Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
            return false;
          }
        } else {
          if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
            return false;
          }
        }
      }
      if (schema2.additionalProperties === false) {
        const valueKeys = Object.getOwnPropertyNames(value);
        if (schema2.required && schema2.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
          return true;
        } else {
          return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
        }
      } else if (typeof schema2.additionalProperties === "object") {
        const valueKeys = Object.getOwnPropertyNames(value);
        return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema2.additionalProperties, references, value[key]));
      } else {
        return true;
      }
    }
    function TPromise(schema2, references, value) {
      return (0, guard_1.IsPromise)(value);
    }
    function TRecord(schema2, references, value) {
      if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
        return false;
      }
      if (IsDefined(schema2.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema2.minProperties)) {
        return false;
      }
      if (IsDefined(schema2.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema2.maxProperties)) {
        return false;
      }
      const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];
      const regex = new RegExp(patternKey);
      const check1 = Object.entries(value).every(([key, value2]) => {
        return regex.test(key) ? Visit(patternSchema, references, value2) : true;
      });
      const check2 = typeof schema2.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
        return !regex.test(key) ? Visit(schema2.additionalProperties, references, value2) : true;
      }) : true;
      const check3 = schema2.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
        return regex.test(key);
      }) : true;
      return check1 && check2 && check3;
    }
    function TRef(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TString(schema2, references, value) {
      if (!(0, guard_1.IsString)(value)) {
        return false;
      }
      if (IsDefined(schema2.minLength)) {
        if (!(value.length >= schema2.minLength))
          return false;
      }
      if (IsDefined(schema2.maxLength)) {
        if (!(value.length <= schema2.maxLength))
          return false;
      }
      if (IsDefined(schema2.pattern)) {
        const regex = new RegExp(schema2.pattern);
        if (!regex.test(value))
          return false;
      }
      if (IsDefined(schema2.format)) {
        if (!Types.FormatRegistry.Has(schema2.format))
          return false;
        const func = Types.FormatRegistry.Get(schema2.format);
        return func(value);
      }
      return true;
    }
    function TSymbol(schema2, references, value) {
      return (0, guard_1.IsSymbol)(value);
    }
    function TTemplateLiteral(schema2, references, value) {
      return (0, guard_1.IsString)(value) && new RegExp(schema2.pattern).test(value);
    }
    function TThis(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TTuple(schema2, references, value) {
      if (!(0, guard_1.IsArray)(value)) {
        return false;
      }
      if (schema2.items === void 0 && !(value.length === 0)) {
        return false;
      }
      if (!(value.length === schema2.maxItems)) {
        return false;
      }
      if (!schema2.items) {
        return true;
      }
      for (let i4 = 0; i4 < schema2.items.length; i4++) {
        if (!Visit(schema2.items[i4], references, value[i4]))
          return false;
      }
      return true;
    }
    function TUndefined(schema2, references, value) {
      return (0, guard_1.IsUndefined)(value);
    }
    function TUnion(schema2, references, value) {
      return schema2.anyOf.some((inner) => Visit(inner, references, value));
    }
    function TUint8Array(schema2, references, value) {
      if (!(0, guard_1.IsUint8Array)(value)) {
        return false;
      }
      if (IsDefined(schema2.maxByteLength) && !(value.length <= schema2.maxByteLength)) {
        return false;
      }
      if (IsDefined(schema2.minByteLength) && !(value.length >= schema2.minByteLength)) {
        return false;
      }
      return true;
    }
    function TUnknown(schema2, references, value) {
      return true;
    }
    function TVoid(schema2, references, value) {
      return index_1.TypeSystemPolicy.IsVoidLike(value);
    }
    function TKind(schema2, references, value) {
      if (!Types.TypeRegistry.Has(schema2[Types.Kind]))
        return false;
      const func = Types.TypeRegistry.Get(schema2[Types.Kind]);
      return func(schema2, value);
    }
    function Visit(schema2, references, value) {
      const references_ = IsDefined(schema2.$id) ? [...references, schema2] : references;
      const schema_ = schema2;
      switch (schema_[Types.Kind]) {
        case "Any":
          return TAny(schema_, references_, value);
        case "Array":
          return TArray(schema_, references_, value);
        case "AsyncIterator":
          return TAsyncIterator(schema_, references_, value);
        case "BigInt":
          return TBigInt(schema_, references_, value);
        case "Boolean":
          return TBoolean(schema_, references_, value);
        case "Constructor":
          return TConstructor(schema_, references_, value);
        case "Date":
          return TDate(schema_, references_, value);
        case "Function":
          return TFunction(schema_, references_, value);
        case "Integer":
          return TInteger(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Iterator":
          return TIterator(schema_, references_, value);
        case "Literal":
          return TLiteral(schema_, references_, value);
        case "Never":
          return TNever(schema_, references_, value);
        case "Not":
          return TNot(schema_, references_, value);
        case "Null":
          return TNull(schema_, references_, value);
        case "Number":
          return TNumber(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Promise":
          return TPromise(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "String":
          return TString(schema_, references_, value);
        case "Symbol":
          return TSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return TTemplateLiteral(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Undefined":
          return TUndefined(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Uint8Array":
          return TUint8Array(schema_, references_, value);
        case "Unknown":
          return TUnknown(schema_, references_, value);
        case "Void":
          return TVoid(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueCheckUnknownTypeError(schema_);
          return TKind(schema_, references_, value);
      }
    }
    function Check(...args) {
      return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
    }
    exports.Check = Check;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/create.js
var require_create = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/create.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = void 0;
    var guard_1 = require_guard();
    var check_1 = require_check();
    var deref_1 = require_deref();
    var Types = require_typebox();
    var ValueCreateUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;
    var ValueCreateNeverTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Never types cannot be created");
        this.schema = schema2;
      }
    };
    exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;
    var ValueCreateNotTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Not types must have a default value");
        this.schema = schema2;
      }
    };
    exports.ValueCreateNotTypeError = ValueCreateNotTypeError;
    var ValueCreateIntersectTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Intersect produced invalid value. Consider using a default value.");
        this.schema = schema2;
      }
    };
    exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;
    var ValueCreateTempateLiteralTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
        this.schema = schema2;
      }
    };
    exports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;
    var ValueCreateRecursiveInstantiationError = class extends Types.TypeBoxError {
      constructor(schema2, recursiveMaxDepth2) {
        super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
        this.schema = schema2;
        this.recursiveMaxDepth = recursiveMaxDepth2;
      }
    };
    exports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
    function TAny(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return {};
      }
    }
    function TArray(schema2, references) {
      if (schema2.uniqueItems === true && !(0, guard_1.HasPropertyKey)(schema2, "default")) {
        throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
      } else if ("contains" in schema2 && !(0, guard_1.HasPropertyKey)(schema2, "default")) {
        throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
      } else if ("default" in schema2) {
        return schema2.default;
      } else if (schema2.minItems !== void 0) {
        return Array.from({ length: schema2.minItems }).map((item) => {
          return Visit(schema2.items, references);
        });
      } else {
        return [];
      }
    }
    function TAsyncIterator(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return async function* () {
        }();
      }
    }
    function TBigInt(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return BigInt(0);
      }
    }
    function TBoolean(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return false;
      }
    }
    function TConstructor(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        const value = Visit(schema2.returns, references);
        if (typeof value === "object" && !Array.isArray(value)) {
          return class {
            constructor() {
              for (const [key, val] of Object.entries(value)) {
                const self = this;
                self[key] = val;
              }
            }
          };
        } else {
          return class {
          };
        }
      }
    }
    function TDate(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minimumTimestamp !== void 0) {
        return new Date(schema2.minimumTimestamp);
      } else {
        return /* @__PURE__ */ new Date();
      }
    }
    function TFunction(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return () => Visit(schema2.returns, references);
      }
    }
    function TInteger(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minimum !== void 0) {
        return schema2.minimum;
      } else {
        return 0;
      }
    }
    function TIntersect(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        const value = schema2.allOf.reduce((acc, schema3) => {
          const next = Visit(schema3, references);
          return typeof next === "object" ? { ...acc, ...next } : next;
        }, {});
        if (!(0, check_1.Check)(schema2, references, value))
          throw new ValueCreateIntersectTypeError(schema2);
        return value;
      }
    }
    function TIterator(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return function* () {
        }();
      }
    }
    function TLiteral(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return schema2.const;
      }
    }
    function TNever(schema2, references) {
      throw new ValueCreateNeverTypeError(schema2);
    }
    function TNot(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        throw new ValueCreateNotTypeError(schema2);
      }
    }
    function TNull(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return null;
      }
    }
    function TNumber(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minimum !== void 0) {
        return schema2.minimum;
      } else {
        return 0;
      }
    }
    function TObject(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        const required = new Set(schema2.required);
        return schema2.default || Object.entries(schema2.properties).reduce((acc, [key, schema3]) => {
          return required.has(key) ? { ...acc, [key]: Visit(schema3, references) } : { ...acc };
        }, {});
      }
    }
    function TPromise(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return Promise.resolve(Visit(schema2.item, references));
      }
    }
    function TRecord(schema2, references) {
      const [keyPattern, valueSchema] = Object.entries(schema2.patternProperties)[0];
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (!(keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact)) {
        const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
        return propertyKeys.reduce((acc, key) => {
          return { ...acc, [key]: Visit(valueSchema, references) };
        }, {});
      } else {
        return {};
      }
    }
    function TRef(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
    }
    function TString(schema2, references) {
      if (schema2.pattern !== void 0) {
        if (!(0, guard_1.HasPropertyKey)(schema2, "default")) {
          throw new Error("ValueCreate.String: String types with patterns must specify a default value");
        } else {
          return schema2.default;
        }
      } else if (schema2.format !== void 0) {
        if (!(0, guard_1.HasPropertyKey)(schema2, "default")) {
          throw new Error("ValueCreate.String: String types with formats must specify a default value");
        } else {
          return schema2.default;
        }
      } else {
        if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
          return schema2.default;
        } else if (schema2.minLength !== void 0) {
          return Array.from({ length: schema2.minLength }).map(() => ".").join("");
        } else {
          return "";
        }
      }
    }
    function TSymbol(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if ("value" in schema2) {
        return Symbol.for(schema2.value);
      } else {
        return Symbol();
      }
    }
    function TTemplateLiteral(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      }
      const expression = Types.TemplateLiteralParser.ParseExact(schema2.pattern);
      if (!Types.TemplateLiteralFinite.Check(expression))
        throw new ValueCreateTempateLiteralTypeError(schema2);
      const sequence = Types.TemplateLiteralGenerator.Generate(expression);
      return sequence.next().value;
    }
    function TThis(schema2, references) {
      if (recursiveDepth++ > recursiveMaxDepth)
        throw new ValueCreateRecursiveInstantiationError(schema2, recursiveMaxDepth);
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
    }
    function TTuple(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      }
      if (schema2.items === void 0) {
        return [];
      } else {
        return Array.from({ length: schema2.minItems }).map((_2, index2) => Visit(schema2.items[index2], references));
      }
    }
    function TUndefined(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return void 0;
      }
    }
    function TUnion(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.anyOf.length === 0) {
        throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
      } else {
        return Visit(schema2.anyOf[0], references);
      }
    }
    function TUint8Array(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else if (schema2.minByteLength !== void 0) {
        return new Uint8Array(schema2.minByteLength);
      } else {
        return new Uint8Array(0);
      }
    }
    function TUnknown(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return {};
      }
    }
    function TVoid(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        return void 0;
      }
    }
    function TKind(schema2, references) {
      if ((0, guard_1.HasPropertyKey)(schema2, "default")) {
        return schema2.default;
      } else {
        throw new Error("User defined types must specify a default value");
      }
    }
    function Visit(schema2, references) {
      const references_ = (0, guard_1.IsString)(schema2.$id) ? [...references, schema2] : references;
      const schema_ = schema2;
      switch (schema_[Types.Kind]) {
        case "Any":
          return TAny(schema_, references_);
        case "Array":
          return TArray(schema_, references_);
        case "AsyncIterator":
          return TAsyncIterator(schema_, references_);
        case "BigInt":
          return TBigInt(schema_, references_);
        case "Boolean":
          return TBoolean(schema_, references_);
        case "Constructor":
          return TConstructor(schema_, references_);
        case "Date":
          return TDate(schema_, references_);
        case "Function":
          return TFunction(schema_, references_);
        case "Integer":
          return TInteger(schema_, references_);
        case "Intersect":
          return TIntersect(schema_, references_);
        case "Iterator":
          return TIterator(schema_, references_);
        case "Literal":
          return TLiteral(schema_, references_);
        case "Never":
          return TNever(schema_, references_);
        case "Not":
          return TNot(schema_, references_);
        case "Null":
          return TNull(schema_, references_);
        case "Number":
          return TNumber(schema_, references_);
        case "Object":
          return TObject(schema_, references_);
        case "Promise":
          return TPromise(schema_, references_);
        case "Record":
          return TRecord(schema_, references_);
        case "Ref":
          return TRef(schema_, references_);
        case "String":
          return TString(schema_, references_);
        case "Symbol":
          return TSymbol(schema_, references_);
        case "TemplateLiteral":
          return TTemplateLiteral(schema_, references_);
        case "This":
          return TThis(schema_, references_);
        case "Tuple":
          return TTuple(schema_, references_);
        case "Undefined":
          return TUndefined(schema_, references_);
        case "Union":
          return TUnion(schema_, references_);
        case "Uint8Array":
          return TUint8Array(schema_, references_);
        case "Unknown":
          return TUnknown(schema_, references_);
        case "Void":
          return TVoid(schema_, references_);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueCreateUnknownTypeError(schema_);
          return TKind(schema_, references_);
      }
    }
    var recursiveMaxDepth = 512;
    var recursiveDepth = 0;
    function Create(...args) {
      recursiveDepth = 0;
      return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
    }
    exports.Create = Create;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/cast.js
var require_cast = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/cast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cast = exports.Default = exports.DefaultClone = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = void 0;
    var guard_1 = require_guard();
    var create_1 = require_create();
    var check_1 = require_check();
    var clone_1 = require_clone();
    var deref_1 = require_deref();
    var Types = require_typebox();
    var ValueCastArrayUniqueItemsTypeError = class extends Types.TypeBoxError {
      constructor(schema2, value) {
        super("Array cast produced invalid data due to uniqueItems constraint");
        this.schema = schema2;
        this.value = value;
      }
    };
    exports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;
    var ValueCastNeverTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Never types cannot be cast");
        this.schema = schema2;
      }
    };
    exports.ValueCastNeverTypeError = ValueCastNeverTypeError;
    var ValueCastRecursiveTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Cannot cast recursive schemas");
        this.schema = schema2;
      }
    };
    exports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;
    var ValueCastUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
    var UnionCastCreate;
    (function(UnionCastCreate2) {
      function Score(schema2, references, value) {
        if (schema2[Types.Kind] === "Object" && typeof value === "object" && !(0, guard_1.IsNull)(value)) {
          const object = schema2;
          const keys = Object.getOwnPropertyNames(value);
          const entries = Object.entries(object.properties);
          const [point, max6] = [1 / entries.length, entries.length];
          return entries.reduce((acc, [key, schema3]) => {
            const literal = schema3[Types.Kind] === "Literal" && schema3.const === value[key] ? max6 : 0;
            const checks = (0, check_1.Check)(schema3, references, value[key]) ? point : 0;
            const exists = keys.includes(key) ? point : 0;
            return acc + (literal + checks + exists);
          }, 0);
        } else {
          return (0, check_1.Check)(schema2, references, value) ? 1 : 0;
        }
      }
      function Select(union, references, value) {
        let [select, best] = [union.anyOf[0], 0];
        for (const schema2 of union.anyOf) {
          const score = Score(schema2, references, value);
          if (score > best) {
            select = schema2;
            best = score;
          }
        }
        return select;
      }
      function Create(union, references, value) {
        if ("default" in union) {
          return union.default;
        } else {
          const schema2 = Select(union, references, value);
          return Cast(schema2, references, value);
        }
      }
      UnionCastCreate2.Create = Create;
    })(UnionCastCreate || (UnionCastCreate = {}));
    function DefaultClone(schema2, references, value) {
      return (0, check_1.Check)(schema2, references, value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema2, references);
    }
    exports.DefaultClone = DefaultClone;
    function Default(schema2, references, value) {
      return (0, check_1.Check)(schema2, references, value) ? value : (0, create_1.Create)(schema2, references);
    }
    exports.Default = Default;
    function TArray(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, clone_1.Clone)(value);
      const created = (0, guard_1.IsArray)(value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema2, references);
      const minimum = (0, guard_1.IsNumber)(schema2.minItems) && created.length < schema2.minItems ? [...created, ...Array.from({ length: schema2.minItems - created.length }, () => null)] : created;
      const maximum = (0, guard_1.IsNumber)(schema2.maxItems) && minimum.length > schema2.maxItems ? minimum.slice(0, schema2.maxItems) : minimum;
      const casted = maximum.map((value2) => Visit(schema2.items, references, value2));
      if (schema2.uniqueItems !== true)
        return casted;
      const unique = [...new Set(casted)];
      if (!(0, check_1.Check)(schema2, references, unique))
        throw new ValueCastArrayUniqueItemsTypeError(schema2, unique);
      return unique;
    }
    function TConstructor(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, create_1.Create)(schema2, references);
      const required = new Set(schema2.returns.required || []);
      const result = function() {
      };
      for (const [key, property] of Object.entries(schema2.returns.properties)) {
        if (!required.has(key) && value.prototype[key] === void 0)
          continue;
        result.prototype[key] = Visit(property, references, value.prototype[key]);
      }
      return result;
    }
    function TIntersect(schema2, references, value) {
      const created = (0, create_1.Create)(schema2, references);
      const mapped = (0, guard_1.IsPlainObject)(created) && (0, guard_1.IsPlainObject)(value) ? { ...created, ...value } : value;
      return (0, check_1.Check)(schema2, references, mapped) ? mapped : (0, create_1.Create)(schema2, references);
    }
    function TNever(schema2, references, value) {
      throw new ValueCastNeverTypeError(schema2);
    }
    function TObject(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return value;
      if (value === null || typeof value !== "object")
        return (0, create_1.Create)(schema2, references);
      const required = new Set(schema2.required || []);
      const result = {};
      for (const [key, property] of Object.entries(schema2.properties)) {
        if (!required.has(key) && value[key] === void 0)
          continue;
        result[key] = Visit(property, references, value[key]);
      }
      if (typeof schema2.additionalProperties === "object") {
        const propertyNames = Object.getOwnPropertyNames(schema2.properties);
        for (const propertyName of Object.getOwnPropertyNames(value)) {
          if (propertyNames.includes(propertyName))
            continue;
          result[propertyName] = Visit(schema2.additionalProperties, references, value[propertyName]);
        }
      }
      return result;
    }
    function TRecord(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, clone_1.Clone)(value);
      if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
        return (0, create_1.Create)(schema2, references);
      const subschemaPropertyName = Object.getOwnPropertyNames(schema2.patternProperties)[0];
      const subschema = schema2.patternProperties[subschemaPropertyName];
      const result = {};
      for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit(subschema, references, propValue);
      }
      return result;
    }
    function TRef(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TThis(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TTuple(schema2, references, value) {
      if ((0, check_1.Check)(schema2, references, value))
        return (0, clone_1.Clone)(value);
      if (!(0, guard_1.IsArray)(value))
        return (0, create_1.Create)(schema2, references);
      if (schema2.items === void 0)
        return [];
      return schema2.items.map((schema3, index2) => Visit(schema3, references, value[index2]));
    }
    function TUnion(schema2, references, value) {
      return (0, check_1.Check)(schema2, references, value) ? (0, clone_1.Clone)(value) : UnionCastCreate.Create(schema2, references, value);
    }
    function Visit(schema2, references, value) {
      const references_ = (0, guard_1.IsString)(schema2.$id) ? [...references, schema2] : references;
      const schema_ = schema2;
      switch (schema2[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "Constructor":
          return TConstructor(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Never":
          return TNever(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Date":
        case "Symbol":
        case "Uint8Array":
          return DefaultClone(schema2, references, value);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Not":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Unknown":
        case "Void":
          return Default(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueCastUnknownTypeError(schema_);
          return Default(schema_, references_, value);
      }
    }
    function Cast(...args) {
      return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
    }
    exports.Cast = Cast;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/convert.js
var require_convert = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Convert = exports.Default = exports.ValueConvertUnknownTypeError = void 0;
    var guard_1 = require_guard();
    var clone_1 = require_clone();
    var check_1 = require_check();
    var deref_1 = require_deref();
    var Types = require_typebox();
    var ValueConvertUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
    function IsStringNumeric(value) {
      return (0, guard_1.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
    }
    function IsValueToString(value) {
      return (0, guard_1.IsBigInt)(value) || (0, guard_1.IsBoolean)(value) || (0, guard_1.IsNumber)(value);
    }
    function IsValueTrue(value) {
      return value === true || (0, guard_1.IsNumber)(value) && value === 1 || (0, guard_1.IsBigInt)(value) && value === BigInt("1") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
    }
    function IsValueFalse(value) {
      return value === false || (0, guard_1.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, guard_1.IsBigInt)(value) && value === BigInt("0") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
    }
    function IsTimeStringWithTimeZone(value) {
      return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
    }
    function IsTimeStringWithoutTimeZone(value) {
      return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
    }
    function IsDateTimeStringWithTimeZone(value) {
      return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
    }
    function IsDateTimeStringWithoutTimeZone(value) {
      return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
    }
    function IsDateString(value) {
      return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
    }
    function TryConvertLiteralString(value, target) {
      const conversion = TryConvertString(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteralNumber(value, target) {
      const conversion = TryConvertNumber(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteralBoolean(value, target) {
      const conversion = TryConvertBoolean(value);
      return conversion === target ? conversion : value;
    }
    function TryConvertLiteral(schema2, value) {
      if (typeof schema2.const === "string") {
        return TryConvertLiteralString(value, schema2.const);
      } else if (typeof schema2.const === "number") {
        return TryConvertLiteralNumber(value, schema2.const);
      } else if (typeof schema2.const === "boolean") {
        return TryConvertLiteralBoolean(value, schema2.const);
      } else {
        return (0, clone_1.Clone)(value);
      }
    }
    function TryConvertBoolean(value) {
      return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
    }
    function TryConvertBigInt(value) {
      return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, guard_1.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
    }
    function TryConvertString(value) {
      return IsValueToString(value) ? value.toString() : (0, guard_1.IsSymbol)(value) && value.description !== void 0 ? value.description.toString() : value;
    }
    function TryConvertNumber(value) {
      return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
    }
    function TryConvertInteger(value) {
      return IsStringNumeric(value) ? parseInt(value) : (0, guard_1.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
    }
    function TryConvertNull(value) {
      return (0, guard_1.IsString)(value) && value.toLowerCase() === "null" ? null : value;
    }
    function TryConvertUndefined(value) {
      return (0, guard_1.IsString)(value) && value === "undefined" ? void 0 : value;
    }
    function TryConvertDate(value) {
      return (0, guard_1.IsDate)(value) ? value : (0, guard_1.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? /* @__PURE__ */ new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? /* @__PURE__ */ new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? /* @__PURE__ */ new Date(`${value}T00:00:00.000Z`) : value;
    }
    function Default(value) {
      return value;
    }
    exports.Default = Default;
    function TArray(schema2, references, value) {
      if ((0, guard_1.IsArray)(value)) {
        return value.map((value2) => Visit(schema2.items, references, value2));
      }
      return value;
    }
    function TBigInt(schema2, references, value) {
      return TryConvertBigInt(value);
    }
    function TBoolean(schema2, references, value) {
      return TryConvertBoolean(value);
    }
    function TDate(schema2, references, value) {
      return TryConvertDate(value);
    }
    function TInteger(schema2, references, value) {
      return TryConvertInteger(value);
    }
    function TIntersect(schema2, references, value) {
      return schema2.allOf.every((schema3) => Types.TypeGuard.TObject(schema3)) ? Visit(Types.Type.Composite(schema2.allOf), references, value) : Visit(schema2.allOf[0], references, value);
    }
    function TLiteral(schema2, references, value) {
      return TryConvertLiteral(schema2, value);
    }
    function TNull(schema2, references, value) {
      return TryConvertNull(value);
    }
    function TNumber(schema2, references, value) {
      return TryConvertNumber(value);
    }
    function TObject(schema2, references, value) {
      if ((0, guard_1.IsObject)(value))
        return Object.getOwnPropertyNames(schema2.properties).reduce((acc, key) => {
          return value[key] !== void 0 ? { ...acc, [key]: Visit(schema2.properties[key], references, value[key]) } : { ...acc };
        }, value);
      return value;
    }
    function TRecord(schema2, references, value) {
      const propertyKey = Object.getOwnPropertyNames(schema2.patternProperties)[0];
      const property = schema2.patternProperties[propertyKey];
      const result = {};
      for (const [propKey, propValue] of Object.entries(value)) {
        result[propKey] = Visit(property, references, propValue);
      }
      return result;
    }
    function TRef(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TString(schema2, references, value) {
      return TryConvertString(value);
    }
    function TSymbol(schema2, references, value) {
      return (0, guard_1.IsString)(value) || (0, guard_1.IsNumber)(value) ? Symbol(value) : value;
    }
    function TThis(schema2, references, value) {
      return Visit((0, deref_1.Deref)(schema2, references), references, value);
    }
    function TTuple(schema2, references, value) {
      if ((0, guard_1.IsArray)(value) && !(0, guard_1.IsUndefined)(schema2.items)) {
        return value.map((value2, index2) => {
          return index2 < schema2.items.length ? Visit(schema2.items[index2], references, value2) : value2;
        });
      }
      return value;
    }
    function TUndefined(schema2, references, value) {
      return TryConvertUndefined(value);
    }
    function TUnion(schema2, references, value) {
      for (const subschema of schema2.anyOf) {
        const converted = Visit(subschema, references, value);
        if ((0, check_1.Check)(subschema, references, converted)) {
          return converted;
        }
      }
      return value;
    }
    function Visit(schema2, references, value) {
      const references_ = (0, guard_1.IsString)(schema2.$id) ? [...references, schema2] : references;
      const schema_ = schema2;
      switch (schema2[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "BigInt":
          return TBigInt(schema_, references_, value);
        case "Boolean":
          return TBoolean(schema_, references_, value);
        case "Date":
          return TDate(schema_, references_, value);
        case "Integer":
          return TInteger(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Literal":
          return TLiteral(schema_, references_, value);
        case "Null":
          return TNull(schema_, references_, value);
        case "Number":
          return TNumber(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "String":
          return TString(schema_, references_, value);
        case "Symbol":
          return TSymbol(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Undefined":
          return TUndefined(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Any":
        case "AsyncIterator":
        case "Constructor":
        case "Function":
        case "Iterator":
        case "Never":
        case "Promise":
        case "TemplateLiteral":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Default(value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new ValueConvertUnknownTypeError(schema_);
          return Default(value);
      }
    }
    function Convert(...args) {
      return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
    }
    exports.Convert = Convert;
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/transform.js
var require_transform = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/transform.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EncodeTransform = exports.DecodeTransform = exports.HasTransform = exports.TransformEncodeError = exports.TransformDecodeError = exports.TransformEncodeCheckError = exports.TransformDecodeCheckError = void 0;
    var guard_1 = require_guard();
    var deref_1 = require_deref();
    var check_1 = require_check();
    var Types = require_typebox();
    var TransformDecodeCheckError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`Unable to decode due to invalid value`);
        this.schema = schema2;
        this.value = value;
        this.error = error;
      }
    };
    exports.TransformDecodeCheckError = TransformDecodeCheckError;
    var TransformEncodeCheckError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`Unable to encode due to invalid value`);
        this.schema = schema2;
        this.value = value;
        this.error = error;
      }
    };
    exports.TransformEncodeCheckError = TransformEncodeCheckError;
    var TransformDecodeError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`${error instanceof Error ? error.message : "Unknown error"}`);
        this.schema = schema2;
        this.value = value;
      }
    };
    exports.TransformDecodeError = TransformDecodeError;
    var TransformEncodeError = class extends Types.TypeBoxError {
      constructor(schema2, value, error) {
        super(`${error instanceof Error ? error.message : "Unknown error"}`);
        this.schema = schema2;
        this.value = value;
      }
    };
    exports.TransformEncodeError = TransformEncodeError;
    var HasTransform;
    (function(HasTransform2) {
      function TArray(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.items, references);
      }
      function TAsyncIterator(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.items, references);
      }
      function TConstructor(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.returns, references) || schema2.parameters.some((schema3) => Visit(schema3, references));
      }
      function TFunction(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.returns, references) || schema2.parameters.some((schema3) => Visit(schema3, references));
      }
      function TIntersect(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Types.TypeGuard.TTransform(schema2.unevaluatedProperties) || schema2.allOf.some((schema3) => Visit(schema3, references));
      }
      function TIterator(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.items, references);
      }
      function TNot(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.not, references);
      }
      function TObject(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Object.values(schema2.properties).some((schema3) => Visit(schema3, references)) || Types.TypeGuard.TSchema(schema2.additionalProperties) && Visit(schema2.additionalProperties, references);
      }
      function TPromise(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || Visit(schema2.item, references);
      }
      function TRecord(schema2, references) {
        const pattern3 = Object.getOwnPropertyNames(schema2.patternProperties)[0];
        const property = schema2.patternProperties[pattern3];
        return Types.TypeGuard.TTransform(schema2) || Visit(property, references) || Types.TypeGuard.TSchema(schema2.additionalProperties) && Types.TypeGuard.TTransform(schema2.additionalProperties);
      }
      function TRef(schema2, references) {
        if (Types.TypeGuard.TTransform(schema2))
          return true;
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
      function TThis(schema2, references) {
        if (Types.TypeGuard.TTransform(schema2))
          return true;
        return Visit((0, deref_1.Deref)(schema2, references), references);
      }
      function TTuple(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || !(0, guard_1.IsUndefined)(schema2.items) && schema2.items.some((schema3) => Visit(schema3, references));
      }
      function TUnion(schema2, references) {
        return Types.TypeGuard.TTransform(schema2) || schema2.anyOf.some((schema3) => Visit(schema3, references));
      }
      function Visit(schema2, references) {
        const references_ = (0, guard_1.IsString)(schema2.$id) ? [...references, schema2] : references;
        const schema_ = schema2;
        if (schema2.$id && visited.has(schema2.$id))
          return false;
        if (schema2.$id)
          visited.add(schema2.$id);
        switch (schema2[Types.Kind]) {
          case "Array":
            return TArray(schema_, references_);
          case "AsyncIterator":
            return TAsyncIterator(schema_, references_);
          case "Constructor":
            return TConstructor(schema_, references_);
          case "Function":
            return TFunction(schema_, references_);
          case "Intersect":
            return TIntersect(schema_, references_);
          case "Iterator":
            return TIterator(schema_, references_);
          case "Not":
            return TNot(schema_, references_);
          case "Object":
            return TObject(schema_, references_);
          case "Promise":
            return TPromise(schema_, references_);
          case "Record":
            return TRecord(schema_, references_);
          case "Ref":
            return TRef(schema_, references_);
          case "This":
            return TThis(schema_, references_);
          case "Tuple":
            return TTuple(schema_, references_);
          case "Union":
            return TUnion(schema_, references_);
          default:
            return Types.TypeGuard.TTransform(schema2);
        }
      }
      const visited = /* @__PURE__ */ new Set();
      function Has(schema2, references) {
        visited.clear();
        return Visit(schema2, references);
      }
      HasTransform2.Has = Has;
    })(HasTransform || (exports.HasTransform = HasTransform = {}));
    var DecodeTransform;
    (function(DecodeTransform2) {
      function Default(schema2, value) {
        try {
          return Types.TypeGuard.TTransform(schema2) ? schema2[Types.Transform].Decode(value) : value;
        } catch (error) {
          throw new TransformDecodeError(schema2, value, error);
        }
      }
      function TArray(schema2, references, value) {
        return (0, guard_1.IsArray)(value) ? Default(schema2, value.map((value2) => Visit(schema2.items, references, value2))) : Default(schema2, value);
      }
      function TIntersect(schema2, references, value) {
        if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
          return Default(schema2, value);
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, { includePatterns: false });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in value2 ? { ...value2, [key]: Visit(Types.IndexedAccessor.Resolve(schema2, [key]), references, value2[key]) } : value2;
        }, value);
        if (!Types.TypeGuard.TTransform(schema2.unevaluatedProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const unevaluatedProperties = schema2.unevaluatedProperties;
        const unknownProperties = unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key) ? { ...value2, [key]: Default(unevaluatedProperties, value2[key]) } : value2;
        }, knownProperties);
        return Default(schema2, unknownProperties);
      }
      function TNot(schema2, references, value) {
        return Default(schema2, Visit(schema2.not, references, value));
      }
      function TObject(schema2, references, value) {
        if (!(0, guard_1.IsPlainObject)(value))
          return Default(schema2, value);
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, { includePatterns: false });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in value2 ? { ...value2, [key]: Visit(schema2.properties[key], references, value2[key]) } : value2;
        }, value);
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        const unknownProperties = unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
        }, knownProperties);
        return Default(schema2, unknownProperties);
      }
      function TRecord(schema2, references, value) {
        if (!(0, guard_1.IsPlainObject)(value))
          return Default(schema2, value);
        const pattern3 = Object.getOwnPropertyNames(schema2.patternProperties)[0];
        const knownKeys = new RegExp(pattern3);
        const knownProperties = Object.getOwnPropertyNames(value).reduce((value2, key) => {
          return knownKeys.test(key) ? { ...value2, [key]: Visit(schema2.patternProperties[pattern3], references, value2[key]) } : value2;
        }, value);
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        const unknownProperties = unknownKeys.reduce((value2, key) => {
          return !knownKeys.test(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
        }, knownProperties);
        return Default(schema2, unknownProperties);
      }
      function TRef(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        return Default(schema2, Visit(target, references, value));
      }
      function TThis(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        return Default(schema2, Visit(target, references, value));
      }
      function TTuple(schema2, references, value) {
        return (0, guard_1.IsArray)(value) && (0, guard_1.IsArray)(schema2.items) ? Default(schema2, schema2.items.map((schema3, index2) => Visit(schema3, references, value[index2]))) : Default(schema2, value);
      }
      function TUnion(schema2, references, value) {
        const defaulted = Default(schema2, value);
        for (const subschema of schema2.anyOf) {
          if (!(0, check_1.Check)(subschema, references, defaulted))
            continue;
          return Visit(subschema, references, defaulted);
        }
        return defaulted;
      }
      function Visit(schema2, references, value) {
        const references_ = typeof schema2.$id === "string" ? [...references, schema2] : references;
        const schema_ = schema2;
        switch (schema2[Types.Kind]) {
          case "Array":
            return TArray(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Not":
            return TNot(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "Symbol":
            return Default(schema_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          default:
            return Default(schema_, value);
        }
      }
      function Decode(schema2, references, value) {
        return Visit(schema2, references, value);
      }
      DecodeTransform2.Decode = Decode;
    })(DecodeTransform || (exports.DecodeTransform = DecodeTransform = {}));
    var EncodeTransform;
    (function(EncodeTransform2) {
      function Default(schema2, value) {
        try {
          return Types.TypeGuard.TTransform(schema2) ? schema2[Types.Transform].Encode(value) : value;
        } catch (error) {
          throw new TransformEncodeError(schema2, value, error);
        }
      }
      function TArray(schema2, references, value) {
        const defaulted = Default(schema2, value);
        return (0, guard_1.IsArray)(defaulted) ? defaulted.map((value2) => Visit(schema2.items, references, value2)) : defaulted;
      }
      function TIntersect(schema2, references, value) {
        const defaulted = Default(schema2, value);
        if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
          return defaulted;
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, { includePatterns: false });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in defaulted ? { ...value2, [key]: Visit(Types.IndexedAccessor.Resolve(schema2, [key]), references, value2[key]) } : value2;
        }, defaulted);
        if (!Types.TypeGuard.TTransform(schema2.unevaluatedProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const unevaluatedProperties = schema2.unevaluatedProperties;
        return unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key) ? { ...value2, [key]: Default(unevaluatedProperties, value2[key]) } : value2;
        }, knownProperties);
      }
      function TNot(schema2, references, value) {
        return Default(schema2.not, Default(schema2, value));
      }
      function TObject(schema2, references, value) {
        const defaulted = Default(schema2, value);
        if (!(0, guard_1.IsPlainObject)(value))
          return defaulted;
        const knownKeys = Types.KeyResolver.ResolveKeys(schema2, { includePatterns: false });
        const knownProperties = knownKeys.reduce((value2, key) => {
          return key in value2 ? { ...value2, [key]: Visit(schema2.properties[key], references, value2[key]) } : value2;
        }, defaulted);
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return knownProperties;
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        return unknownKeys.reduce((value2, key) => {
          return !knownKeys.includes(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
        }, knownProperties);
      }
      function TRecord(schema2, references, value) {
        const defaulted = Default(schema2, value);
        if (!(0, guard_1.IsPlainObject)(value))
          return defaulted;
        const pattern3 = Object.getOwnPropertyNames(schema2.patternProperties)[0];
        const knownKeys = new RegExp(pattern3);
        const knownProperties = Object.getOwnPropertyNames(value).reduce((value2, key) => {
          return knownKeys.test(key) ? { ...value2, [key]: Visit(schema2.patternProperties[pattern3], references, value2[key]) } : value2;
        }, defaulted);
        if (!Types.TypeGuard.TSchema(schema2.additionalProperties)) {
          return Default(schema2, knownProperties);
        }
        const unknownKeys = Object.getOwnPropertyNames(knownProperties);
        const additionalProperties = schema2.additionalProperties;
        return unknownKeys.reduce((value2, key) => {
          return !knownKeys.test(key) ? { ...value2, [key]: Default(additionalProperties, value2[key]) } : value2;
        }, knownProperties);
      }
      function TRef(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        const resolved = Visit(target, references, value);
        return Default(schema2, resolved);
      }
      function TThis(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        const resolved = Visit(target, references, value);
        return Default(schema2, resolved);
      }
      function TTuple(schema2, references, value) {
        const value1 = Default(schema2, value);
        return (0, guard_1.IsArray)(schema2.items) ? schema2.items.map((schema3, index2) => Visit(schema3, references, value1[index2])) : [];
      }
      function TUnion(schema2, references, value) {
        for (const subschema of schema2.anyOf) {
          if (!(0, check_1.Check)(subschema, references, value))
            continue;
          const value1 = Visit(subschema, references, value);
          return Default(schema2, value1);
        }
        for (const subschema of schema2.anyOf) {
          const value1 = Visit(subschema, references, value);
          if (!(0, check_1.Check)(schema2, references, value1))
            continue;
          return Default(schema2, value1);
        }
        return Default(schema2, value);
      }
      function Visit(schema2, references, value) {
        const references_ = typeof schema2.$id === "string" ? [...references, schema2] : references;
        const schema_ = schema2;
        switch (schema2[Types.Kind]) {
          case "Array":
            return TArray(schema_, references_, value);
          case "Intersect":
            return TIntersect(schema_, references_, value);
          case "Not":
            return TNot(schema_, references_, value);
          case "Object":
            return TObject(schema_, references_, value);
          case "Record":
            return TRecord(schema_, references_, value);
          case "Ref":
            return TRef(schema_, references_, value);
          case "This":
            return TThis(schema_, references_, value);
          case "Tuple":
            return TTuple(schema_, references_, value);
          case "Union":
            return TUnion(schema_, references_, value);
          default:
            return Default(schema_, value);
        }
      }
      function Encode(schema2, references, value) {
        return Visit(schema2, references, value);
      }
      EncodeTransform2.Encode = Encode;
    })(EncodeTransform || (exports.EncodeTransform = EncodeTransform = {}));
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/value.js
var require_value = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/value.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = void 0;
    var ValueErrors = require_errors2();
    var ValueMutate = require_mutate();
    var ValueHash = require_hash();
    var ValueEqual = require_equal();
    var ValueCast = require_cast();
    var ValueClone = require_clone();
    var ValueConvert = require_convert();
    var ValueCreate = require_create();
    var ValueCheck = require_check();
    var ValueDelta = require_delta();
    var ValueTransform = require_transform();
    var Value3;
    (function(Value4) {
      function Cast(...args) {
        return ValueCast.Cast.apply(ValueCast, args);
      }
      Value4.Cast = Cast;
      function Create(...args) {
        return ValueCreate.Create.apply(ValueCreate, args);
      }
      Value4.Create = Create;
      function Check(...args) {
        return ValueCheck.Check.apply(ValueCheck, args);
      }
      Value4.Check = Check;
      function Convert(...args) {
        return ValueConvert.Convert.apply(ValueConvert, args);
      }
      Value4.Convert = Convert;
      function Clone(value) {
        return ValueClone.Clone(value);
      }
      Value4.Clone = Clone;
      function Decode(...args) {
        const [schema2, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
        if (!Check(schema2, references, value))
          throw new ValueTransform.TransformDecodeCheckError(schema2, value, Errors2(schema2, references, value).First());
        return ValueTransform.DecodeTransform.Decode(schema2, references, value);
      }
      Value4.Decode = Decode;
      function Encode(...args) {
        const [schema2, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
        const encoded = ValueTransform.EncodeTransform.Encode(schema2, references, value);
        if (!Check(schema2, references, encoded))
          throw new ValueTransform.TransformEncodeCheckError(schema2, value, Errors2(schema2, references, value).First());
        return encoded;
      }
      Value4.Encode = Encode;
      function Errors2(...args) {
        return ValueErrors.Errors.apply(ValueErrors, args);
      }
      Value4.Errors = Errors2;
      function Equal(left, right) {
        return ValueEqual.Equal(left, right);
      }
      Value4.Equal = Equal;
      function Diff(current, next) {
        return ValueDelta.Diff(current, next);
      }
      Value4.Diff = Diff;
      function Hash2(value) {
        return ValueHash.Hash(value);
      }
      Value4.Hash = Hash2;
      function Patch(current, edits) {
        return ValueDelta.Patch(current, edits);
      }
      Value4.Patch = Patch;
      function Mutate(current, next) {
        ValueMutate.Mutate(current, next);
      }
      Value4.Mutate = Mutate;
    })(Value3 || (exports.Value = Value3 = {}));
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/index.js
var require_value2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/value/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
      return index_1.ValueErrorType;
    } });
    Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
      return index_1.ValueErrorIterator;
    } });
    var delta_1 = require_delta();
    Object.defineProperty(exports, "Edit", { enumerable: true, get: function() {
      return delta_1.Edit;
    } });
    Object.defineProperty(exports, "Insert", { enumerable: true, get: function() {
      return delta_1.Insert;
    } });
    Object.defineProperty(exports, "Update", { enumerable: true, get: function() {
      return delta_1.Update;
    } });
    Object.defineProperty(exports, "Delete", { enumerable: true, get: function() {
      return delta_1.Delete;
    } });
    var pointer_1 = require_pointer();
    Object.defineProperty(exports, "ValuePointer", { enumerable: true, get: function() {
      return pointer_1.ValuePointer;
    } });
    var value_1 = require_value();
    Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
      return value_1.Value;
    } });
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/compiler.js
var require_compiler = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/compiler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;
    var transform_1 = require_transform();
    var guard_1 = require_guard();
    var errors_1 = require_errors();
    var index_1 = require_system2();
    var deref_1 = require_deref();
    var hash_1 = require_hash();
    var Types = require_typebox();
    var TypeCheck = class {
      constructor(schema2, references, checkFunc, code) {
        this.schema = schema2;
        this.references = references;
        this.checkFunc = checkFunc;
        this.code = code;
        this.hasTransform = transform_1.HasTransform.Has(schema2, references);
      }
      /** Returns the generated assertion code used to validate this type. */
      Code() {
        return this.code;
      }
      /** Returns an iterator for each error in this value. */
      Errors(value) {
        return (0, errors_1.Errors)(this.schema, this.references, value);
      }
      /** Returns true if the value matches the compiled type. */
      Check(value) {
        return this.checkFunc(value);
      }
      /** Decodes a value or throws if error */
      Decode(value) {
        if (!this.checkFunc(value))
          throw new transform_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
        return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value) : value;
      }
      /** Encodes a value or throws if error */
      Encode(value) {
        const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value) : value;
        if (!this.checkFunc(encoded))
          throw new transform_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
        return encoded;
      }
    };
    exports.TypeCheck = TypeCheck;
    var Character;
    (function(Character2) {
      function DollarSign(code) {
        return code === 36;
      }
      Character2.DollarSign = DollarSign;
      function IsUnderscore(code) {
        return code === 95;
      }
      Character2.IsUnderscore = IsUnderscore;
      function IsAlpha(code) {
        return code >= 65 && code <= 90 || code >= 97 && code <= 122;
      }
      Character2.IsAlpha = IsAlpha;
      function IsNumeric(code) {
        return code >= 48 && code <= 57;
      }
      Character2.IsNumeric = IsNumeric;
    })(Character || (Character = {}));
    var MemberExpression;
    (function(MemberExpression2) {
      function IsFirstCharacterNumeric(value) {
        if (value.length === 0)
          return false;
        return Character.IsNumeric(value.charCodeAt(0));
      }
      function IsAccessor(value) {
        if (IsFirstCharacterNumeric(value))
          return false;
        for (let i4 = 0; i4 < value.length; i4++) {
          const code = value.charCodeAt(i4);
          const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
          if (!check)
            return false;
        }
        return true;
      }
      function EscapeHyphen(key) {
        return key.replace(/'/g, "\\'");
      }
      function Encode(object, key) {
        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
      }
      MemberExpression2.Encode = Encode;
    })(MemberExpression || (MemberExpression = {}));
    var Identifier;
    (function(Identifier2) {
      function Encode($id) {
        const buffer = [];
        for (let i4 = 0; i4 < $id.length; i4++) {
          const code = $id.charCodeAt(i4);
          if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
            buffer.push($id.charAt(i4));
          } else {
            buffer.push(`_${code}_`);
          }
        }
        return buffer.join("").replace(/__/g, "_");
      }
      Identifier2.Encode = Encode;
    })(Identifier || (Identifier = {}));
    var LiteralString;
    (function(LiteralString2) {
      function Escape(content) {
        return content.replace(/'/g, "\\'");
      }
      LiteralString2.Escape = Escape;
    })(LiteralString || (LiteralString = {}));
    var TypeCompilerUnknownTypeError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Unknown type");
        this.schema = schema2;
      }
    };
    exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
    var TypeCompilerTypeGuardError = class extends Types.TypeBoxError {
      constructor(schema2) {
        super("Preflight validation check failed to guard for the given schema");
        this.schema = schema2;
      }
    };
    exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
    var Policy;
    (function(Policy2) {
      function IsExactOptionalProperty(value, key, expression) {
        return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
      }
      Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(value) {
        return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
      }
      Policy2.IsObjectLike = IsObjectLike;
      function IsRecordLike(value) {
        return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
      }
      Policy2.IsRecordLike = IsRecordLike;
      function IsNumberLike(value) {
        return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;
      }
      Policy2.IsNumberLike = IsNumberLike;
      function IsVoidLike(value) {
        return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
      }
      Policy2.IsVoidLike = IsVoidLike;
    })(Policy || (exports.Policy = Policy = {}));
    var TypeCompiler4;
    (function(TypeCompiler5) {
      function IsAnyOrUnknown(schema2) {
        return schema2[Types.Kind] === "Any" || schema2[Types.Kind] === "Unknown";
      }
      function* TAny(schema2, references, value) {
        yield "true";
      }
      function* TArray(schema2, references, value) {
        yield `Array.isArray(${value})`;
        const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
        if ((0, guard_1.IsNumber)(schema2.maxItems))
          yield `${value}.length <= ${schema2.maxItems}`;
        if ((0, guard_1.IsNumber)(schema2.minItems))
          yield `${value}.length >= ${schema2.minItems}`;
        const elementExpression = CreateExpression(schema2.items, references, "value");
        yield `${value}.every((${parameter}) => ${elementExpression})`;
        if (Types.TypeGuard.TSchema(schema2.contains) || (0, guard_1.IsNumber)(schema2.minContains) || (0, guard_1.IsNumber)(schema2.maxContains)) {
          const containsSchema = Types.TypeGuard.TSchema(schema2.contains) ? schema2.contains : Types.Type.Never();
          const checkExpression = CreateExpression(containsSchema, references, "value");
          const checkMinContains = (0, guard_1.IsNumber)(schema2.minContains) ? [`(count >= ${schema2.minContains})`] : [];
          const checkMaxContains = (0, guard_1.IsNumber)(schema2.maxContains) ? [`(count <= ${schema2.maxContains})`] : [];
          const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
          const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
          yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
        }
        if (schema2.uniqueItems === true) {
          const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
          const block = `const set = new Set(); for(const element of value) { ${check} }`;
          yield `((${parameter}) => { ${block} )(${value})`;
        }
      }
      function* TAsyncIterator(schema2, references, value) {
        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
      }
      function* TBigInt(schema2, references, value) {
        yield `(typeof ${value} === 'bigint')`;
        if ((0, guard_1.IsBigInt)(schema2.exclusiveMaximum))
          yield `${value} < BigInt(${schema2.exclusiveMaximum})`;
        if ((0, guard_1.IsBigInt)(schema2.exclusiveMinimum))
          yield `${value} > BigInt(${schema2.exclusiveMinimum})`;
        if ((0, guard_1.IsBigInt)(schema2.maximum))
          yield `${value} <= BigInt(${schema2.maximum})`;
        if ((0, guard_1.IsBigInt)(schema2.minimum))
          yield `${value} >= BigInt(${schema2.minimum})`;
        if ((0, guard_1.IsBigInt)(schema2.multipleOf))
          yield `(${value} % BigInt(${schema2.multipleOf})) === 0`;
      }
      function* TBoolean(schema2, references, value) {
        yield `(typeof ${value} === 'boolean')`;
      }
      function* TConstructor(schema2, references, value) {
        yield* Visit(schema2.returns, references, `${value}.prototype`);
      }
      function* TDate(schema2, references, value) {
        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMaximumTimestamp))
          yield `${value}.getTime() < ${schema2.exclusiveMaximumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMinimumTimestamp))
          yield `${value}.getTime() > ${schema2.exclusiveMinimumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.maximumTimestamp))
          yield `${value}.getTime() <= ${schema2.maximumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.minimumTimestamp))
          yield `${value}.getTime() >= ${schema2.minimumTimestamp}`;
        if ((0, guard_1.IsNumber)(schema2.multipleOfTimestamp))
          yield `(${value}.getTime() % ${schema2.multipleOfTimestamp}) === 0`;
      }
      function* TFunction(schema2, references, value) {
        yield `(typeof ${value} === 'function')`;
      }
      function* TInteger(schema2, references, value) {
        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMaximum))
          yield `${value} < ${schema2.exclusiveMaximum}`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMinimum))
          yield `${value} > ${schema2.exclusiveMinimum}`;
        if ((0, guard_1.IsNumber)(schema2.maximum))
          yield `${value} <= ${schema2.maximum}`;
        if ((0, guard_1.IsNumber)(schema2.minimum))
          yield `${value} >= ${schema2.minimum}`;
        if ((0, guard_1.IsNumber)(schema2.multipleOf))
          yield `(${value} % ${schema2.multipleOf}) === 0`;
      }
      function* TIntersect(schema2, references, value) {
        const check1 = schema2.allOf.map((schema3) => CreateExpression(schema3, references, value)).join(" && ");
        if (schema2.unevaluatedProperties === false) {
          const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema2))};`);
          const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
          yield `(${check1} && ${check2})`;
        } else if (Types.TypeGuard.TSchema(schema2.unevaluatedProperties)) {
          const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema2))};`);
          const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema2.unevaluatedProperties, references, `${value}[key]`)})`;
          yield `(${check1} && ${check2})`;
        } else {
          yield `(${check1})`;
        }
      }
      function* TIterator(schema2, references, value) {
        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
      }
      function* TLiteral(schema2, references, value) {
        if (typeof schema2.const === "number" || typeof schema2.const === "boolean") {
          yield `(${value} === ${schema2.const})`;
        } else {
          yield `(${value} === '${LiteralString.Escape(schema2.const)}')`;
        }
      }
      function* TNever(schema2, references, value) {
        yield `false`;
      }
      function* TNot(schema2, references, value) {
        const expression = CreateExpression(schema2.not, references, value);
        yield `(!${expression})`;
      }
      function* TNull(schema2, references, value) {
        yield `(${value} === null)`;
      }
      function* TNumber(schema2, references, value) {
        yield Policy.IsNumberLike(value);
        if ((0, guard_1.IsNumber)(schema2.exclusiveMaximum))
          yield `${value} < ${schema2.exclusiveMaximum}`;
        if ((0, guard_1.IsNumber)(schema2.exclusiveMinimum))
          yield `${value} > ${schema2.exclusiveMinimum}`;
        if ((0, guard_1.IsNumber)(schema2.maximum))
          yield `${value} <= ${schema2.maximum}`;
        if ((0, guard_1.IsNumber)(schema2.minimum))
          yield `${value} >= ${schema2.minimum}`;
        if ((0, guard_1.IsNumber)(schema2.multipleOf))
          yield `(${value} % ${schema2.multipleOf}) === 0`;
      }
      function* TObject(schema2, references, value) {
        yield Policy.IsObjectLike(value);
        if ((0, guard_1.IsNumber)(schema2.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema2.minProperties}`;
        if ((0, guard_1.IsNumber)(schema2.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema2.maxProperties}`;
        const knownKeys = Object.getOwnPropertyNames(schema2.properties);
        for (const knownKey of knownKeys) {
          const memberExpression = MemberExpression.Encode(value, knownKey);
          const property = schema2.properties[knownKey];
          if (schema2.required && schema2.required.includes(knownKey)) {
            yield* Visit(property, references, memberExpression);
            if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property))
              yield `('${knownKey}' in ${value})`;
          } else {
            const expression = CreateExpression(property, references, memberExpression);
            yield Policy.IsExactOptionalProperty(value, knownKey, expression);
          }
        }
        if (schema2.additionalProperties === false) {
          if (schema2.required && schema2.required.length === knownKeys.length) {
            yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
          } else {
            const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
            yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
          }
        }
        if (typeof schema2.additionalProperties === "object") {
          const expression = CreateExpression(schema2.additionalProperties, references, `${value}[key]`);
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
        }
      }
      function* TPromise(schema2, references, value) {
        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
      }
      function* TRecord(schema2, references, value) {
        yield Policy.IsRecordLike(value);
        if ((0, guard_1.IsNumber)(schema2.minProperties))
          yield `Object.getOwnPropertyNames(${value}).length >= ${schema2.minProperties}`;
        if ((0, guard_1.IsNumber)(schema2.maxProperties))
          yield `Object.getOwnPropertyNames(${value}).length <= ${schema2.maxProperties}`;
        const [patternKey, patternSchema] = Object.entries(schema2.patternProperties)[0];
        const variable = CreateVariable(`${new RegExp(patternKey)}`);
        const check1 = CreateExpression(patternSchema, references, "value");
        const check2 = Types.TypeGuard.TSchema(schema2.additionalProperties) ? CreateExpression(schema2.additionalProperties, references, value) : schema2.additionalProperties === false ? "false" : "true";
        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
      }
      function* TRef(schema2, references, value) {
        const target = (0, deref_1.Deref)(schema2, references);
        if (state.functions.has(schema2.$ref))
          return yield `${CreateFunctionName(schema2.$ref)}(${value})`;
        yield* Visit(target, references, value);
      }
      function* TString(schema2, references, value) {
        yield `(typeof ${value} === 'string')`;
        if ((0, guard_1.IsNumber)(schema2.maxLength))
          yield `${value}.length <= ${schema2.maxLength}`;
        if ((0, guard_1.IsNumber)(schema2.minLength))
          yield `${value}.length >= ${schema2.minLength}`;
        if (schema2.pattern !== void 0) {
          const variable = CreateVariable(`${new RegExp(schema2.pattern)};`);
          yield `${variable}.test(${value})`;
        }
        if (schema2.format !== void 0) {
          yield `format('${schema2.format}', ${value})`;
        }
      }
      function* TSymbol(schema2, references, value) {
        yield `(typeof ${value} === 'symbol')`;
      }
      function* TTemplateLiteral(schema2, references, value) {
        yield `(typeof ${value} === 'string')`;
        const variable = CreateVariable(`${new RegExp(schema2.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      function* TThis(schema2, references, value) {
        yield `${CreateFunctionName(schema2.$ref)}(${value})`;
      }
      function* TTuple(schema2, references, value) {
        yield `Array.isArray(${value})`;
        if (schema2.items === void 0)
          return yield `${value}.length === 0`;
        yield `(${value}.length === ${schema2.maxItems})`;
        for (let i4 = 0; i4 < schema2.items.length; i4++) {
          const expression = CreateExpression(schema2.items[i4], references, `${value}[${i4}]`);
          yield `${expression}`;
        }
      }
      function* TUndefined(schema2, references, value) {
        yield `${value} === undefined`;
      }
      function* TUnion(schema2, references, value) {
        const expressions = schema2.anyOf.map((schema3) => CreateExpression(schema3, references, value));
        yield `(${expressions.join(" || ")})`;
      }
      function* TUint8Array(schema2, references, value) {
        yield `${value} instanceof Uint8Array`;
        if ((0, guard_1.IsNumber)(schema2.maxByteLength))
          yield `(${value}.length <= ${schema2.maxByteLength})`;
        if ((0, guard_1.IsNumber)(schema2.minByteLength))
          yield `(${value}.length >= ${schema2.minByteLength})`;
      }
      function* TUnknown(schema2, references, value) {
        yield "true";
      }
      function* TVoid(schema2, references, value) {
        yield Policy.IsVoidLike(value);
      }
      function* TKind(schema2, references, value) {
        const instance = state.instances.size;
        state.instances.set(instance, schema2);
        yield `kind('${schema2[Types.Kind]}', ${instance}, ${value})`;
      }
      function* Visit(schema2, references, value, useHoisting = true) {
        const references_ = (0, guard_1.IsString)(schema2.$id) ? [...references, schema2] : references;
        const schema_ = schema2;
        if (useHoisting && (0, guard_1.IsString)(schema2.$id)) {
          const functionName = CreateFunctionName(schema2.$id);
          if (state.functions.has(functionName)) {
            return yield `${functionName}(${value})`;
          } else {
            const functionCode = CreateFunction(functionName, schema2, references, "value", false);
            state.functions.set(functionName, functionCode);
            return yield `${functionName}(${value})`;
          }
        }
        switch (schema_[Types.Kind]) {
          case "Any":
            return yield* TAny(schema_, references_, value);
          case "Array":
            return yield* TArray(schema_, references_, value);
          case "AsyncIterator":
            return yield* TAsyncIterator(schema_, references_, value);
          case "BigInt":
            return yield* TBigInt(schema_, references_, value);
          case "Boolean":
            return yield* TBoolean(schema_, references_, value);
          case "Constructor":
            return yield* TConstructor(schema_, references_, value);
          case "Date":
            return yield* TDate(schema_, references_, value);
          case "Function":
            return yield* TFunction(schema_, references_, value);
          case "Integer":
            return yield* TInteger(schema_, references_, value);
          case "Intersect":
            return yield* TIntersect(schema_, references_, value);
          case "Iterator":
            return yield* TIterator(schema_, references_, value);
          case "Literal":
            return yield* TLiteral(schema_, references_, value);
          case "Never":
            return yield* TNever(schema_, references_, value);
          case "Not":
            return yield* TNot(schema_, references_, value);
          case "Null":
            return yield* TNull(schema_, references_, value);
          case "Number":
            return yield* TNumber(schema_, references_, value);
          case "Object":
            return yield* TObject(schema_, references_, value);
          case "Promise":
            return yield* TPromise(schema_, references_, value);
          case "Record":
            return yield* TRecord(schema_, references_, value);
          case "Ref":
            return yield* TRef(schema_, references_, value);
          case "String":
            return yield* TString(schema_, references_, value);
          case "Symbol":
            return yield* TSymbol(schema_, references_, value);
          case "TemplateLiteral":
            return yield* TTemplateLiteral(schema_, references_, value);
          case "This":
            return yield* TThis(schema_, references_, value);
          case "Tuple":
            return yield* TTuple(schema_, references_, value);
          case "Undefined":
            return yield* TUndefined(schema_, references_, value);
          case "Union":
            return yield* TUnion(schema_, references_, value);
          case "Uint8Array":
            return yield* TUint8Array(schema_, references_, value);
          case "Unknown":
            return yield* TUnknown(schema_, references_, value);
          case "Void":
            return yield* TVoid(schema_, references_, value);
          default:
            if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
              throw new TypeCompilerUnknownTypeError(schema2);
            return yield* TKind(schema_, references_, value);
        }
      }
      const state = {
        language: "javascript",
        functions: /* @__PURE__ */ new Map(),
        variables: /* @__PURE__ */ new Map(),
        instances: /* @__PURE__ */ new Map()
        // exterior kind instances
      };
      function CreateExpression(schema2, references, value, useHoisting = true) {
        return `(${[...Visit(schema2, references, value, useHoisting)].join(" && ")})`;
      }
      function CreateFunctionName($id) {
        return `check_${Identifier.Encode($id)}`;
      }
      function CreateVariable(expression) {
        const variableName = `local_${state.variables.size}`;
        state.variables.set(variableName, `const ${variableName} = ${expression}`);
        return variableName;
      }
      function CreateFunction(name, schema2, references, value, useHoisting = true) {
        const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
        const parameter = CreateParameter("value", "any");
        const returns = CreateReturns("boolean");
        const expression = [...Visit(schema2, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
      }
      function CreateParameter(name, type) {
        const annotation = state.language === "typescript" ? `: ${type}` : "";
        return `${name}${annotation}`;
      }
      function CreateReturns(type) {
        return state.language === "typescript" ? `: ${type}` : "";
      }
      function Build(schema2, references, options) {
        const functionCode = CreateFunction("check", schema2, references, "value");
        const parameter = CreateParameter("value", "any");
        const returns = CreateReturns("boolean");
        const functions = [...state.functions.values()];
        const variables = [...state.variables.values()];
        const checkFunction = (0, guard_1.IsString)(schema2.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema2.$id)}(value)
}` : `return ${functionCode}`;
        return [...variables, ...functions, checkFunction].join("\n");
      }
      function Code(...args) {
        const defaults = { language: "javascript" };
        const [schema2, references, options] = args.length === 2 && (0, guard_1.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, guard_1.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
        state.language = options.language;
        state.variables.clear();
        state.functions.clear();
        state.instances.clear();
        if (!Types.TypeGuard.TSchema(schema2))
          throw new TypeCompilerTypeGuardError(schema2);
        for (const schema3 of references)
          if (!Types.TypeGuard.TSchema(schema3))
            throw new TypeCompilerTypeGuardError(schema3);
        return Build(schema2, references, options);
      }
      TypeCompiler5.Code = Code;
      function Compile(schema2, references = []) {
        const generatedCode = Code(schema2, references, { language: "javascript" });
        const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
        const instances = new Map(state.instances);
        function typeRegistryFunction(kind, instance, value) {
          if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))
            return false;
          const checkFunc = Types.TypeRegistry.Get(kind);
          const schema3 = instances.get(instance);
          return checkFunc(schema3, value);
        }
        function formatRegistryFunction(format, value) {
          if (!Types.FormatRegistry.Has(format))
            return false;
          const checkFunc = Types.FormatRegistry.Get(format);
          return checkFunc(value);
        }
        function hashFunction(value) {
          return (0, hash_1.Hash)(value);
        }
        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
        return new TypeCheck(schema2, references, checkFunction, generatedCode);
      }
      TypeCompiler5.Compile = Compile;
    })(TypeCompiler4 || (exports.TypeCompiler = TypeCompiler4 = {}));
  }
});

// ../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/index.js
var require_compiler2 = __commonJS({
  "../../../node_modules/.pnpm/@sinclair+typebox@0.31.28/node_modules/@sinclair/typebox/compiler/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o5, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o5, k22, desc);
    } : function(o5, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o5[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueErrorIterator = exports.ValueErrorType = void 0;
    var index_1 = require_errors2();
    Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
      return index_1.ValueErrorType;
    } });
    Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
      return index_1.ValueErrorIterator;
    } });
    __exportStar(require_compiler(), exports);
  }
});

// ../../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h4 = m2 * 60;
    var d2 = h4 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n5 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n5 * y2;
        case "weeks":
        case "week":
        case "w":
          return n5 * w2;
        case "days":
        case "day":
        case "d":
          return n5 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n5 * h4;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n5 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n5 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n5;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h4) {
        return Math.round(ms / h4) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms / s2) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h4) {
        return plural(ms, msAbs, h4, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms, msAbs, s2, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n5, name) {
      var isPlural = msAbs >= n5 * 1.5;
      return Math.round(ms / n5) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../../node_modules/.pnpm/debug@4.3.6_supports-color@8.1.1/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../../node_modules/.pnpm/debug@4.3.6_supports-color@8.1.1/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i4);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug9(...args) {
          if (!debug9.enabled) {
            return;
          }
          const self = debug9;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index2];
              match = formatter.call(self, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug9.namespace = namespace;
        debug9.useColors = createDebug.useColors();
        debug9.color = createDebug.selectColor(namespace);
        debug9.extend = extend;
        debug9.destroy = createDebug.destroy;
        Object.defineProperty(debug9, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug9);
        }
        return debug9;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i4;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i4;
        let len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../../node_modules/.pnpm/debug@4.3.6_supports-color@8.1.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../../node_modules/.pnpm/debug@4.3.6_supports-color@8.1.1/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c4 = "color: " + this.color;
      args.splice(1, 0, c4, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c4);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r6;
      try {
        r6 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r6 && typeof process !== "undefined" && "env" in process) {
        r6 = process.env.DEBUG;
      }
      return r6;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../../lix/packages/fs/dist/errors/FilesystemError.js
var init_FilesystemError = __esm({
  "../../../lix/packages/fs/dist/errors/FilesystemError.js"() {
    "use strict";
  }
});

// ../../../lix/packages/fs/dist/utilities/helpers.js
var init_helpers = __esm({
  "../../../lix/packages/fs/dist/utilities/helpers.js"() {
    "use strict";
  }
});

// ../../../lix/packages/fs/dist/memoryFs.js
var init_memoryFs = __esm({
  "../../../lix/packages/fs/dist/memoryFs.js"() {
    "use strict";
    init_FilesystemError();
    init_helpers();
  }
});

// ../../../lix/packages/fs/dist/index.js
var init_dist = __esm({
  "../../../lix/packages/fs/dist/index.js"() {
    "use strict";
    init_memoryFs();
    init_helpers();
  }
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/lib/murmurHash3js.js"(exports, module) {
    (function(root, undefined2) {
      "use strict";
      var library2 = {
        "version": "3.0.1",
        "x86": {},
        "x64": {}
      };
      function _x86Multiply(m2, n5) {
        return (m2 & 65535) * n5 + (((m2 >>> 16) * n5 & 65535) << 16);
      }
      function _x86Rotl(m2, n5) {
        return m2 << n5 | m2 >>> 32 - n5;
      }
      function _x86Fmix(h4) {
        h4 ^= h4 >>> 16;
        h4 = _x86Multiply(h4, 2246822507);
        h4 ^= h4 >>> 13;
        h4 = _x86Multiply(h4, 3266489909);
        h4 ^= h4 >>> 16;
        return h4;
      }
      function _x64Add(m2, n5) {
        m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
        n5 = [n5[0] >>> 16, n5[0] & 65535, n5[1] >>> 16, n5[1] & 65535];
        var o5 = [0, 0, 0, 0];
        o5[3] += m2[3] + n5[3];
        o5[2] += o5[3] >>> 16;
        o5[3] &= 65535;
        o5[2] += m2[2] + n5[2];
        o5[1] += o5[2] >>> 16;
        o5[2] &= 65535;
        o5[1] += m2[1] + n5[1];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[0] += m2[0] + n5[0];
        o5[0] &= 65535;
        return [o5[0] << 16 | o5[1], o5[2] << 16 | o5[3]];
      }
      function _x64Multiply(m2, n5) {
        m2 = [m2[0] >>> 16, m2[0] & 65535, m2[1] >>> 16, m2[1] & 65535];
        n5 = [n5[0] >>> 16, n5[0] & 65535, n5[1] >>> 16, n5[1] & 65535];
        var o5 = [0, 0, 0, 0];
        o5[3] += m2[3] * n5[3];
        o5[2] += o5[3] >>> 16;
        o5[3] &= 65535;
        o5[2] += m2[2] * n5[3];
        o5[1] += o5[2] >>> 16;
        o5[2] &= 65535;
        o5[2] += m2[3] * n5[2];
        o5[1] += o5[2] >>> 16;
        o5[2] &= 65535;
        o5[1] += m2[1] * n5[3];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[1] += m2[2] * n5[2];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[1] += m2[3] * n5[1];
        o5[0] += o5[1] >>> 16;
        o5[1] &= 65535;
        o5[0] += m2[0] * n5[3] + m2[1] * n5[2] + m2[2] * n5[1] + m2[3] * n5[0];
        o5[0] &= 65535;
        return [o5[0] << 16 | o5[1], o5[2] << 16 | o5[3]];
      }
      function _x64Rotl(m2, n5) {
        n5 %= 64;
        if (n5 === 32) {
          return [m2[1], m2[0]];
        } else if (n5 < 32) {
          return [m2[0] << n5 | m2[1] >>> 32 - n5, m2[1] << n5 | m2[0] >>> 32 - n5];
        } else {
          n5 -= 32;
          return [m2[1] << n5 | m2[0] >>> 32 - n5, m2[0] << n5 | m2[1] >>> 32 - n5];
        }
      }
      function _x64LeftShift(m2, n5) {
        n5 %= 64;
        if (n5 === 0) {
          return m2;
        } else if (n5 < 32) {
          return [m2[0] << n5 | m2[1] >>> 32 - n5, m2[1] << n5];
        } else {
          return [m2[1] << n5 - 32, 0];
        }
      }
      function _x64Xor(m2, n5) {
        return [m2[0] ^ n5[0], m2[1] ^ n5[1]];
      }
      function _x64Fmix(h4) {
        h4 = _x64Xor(h4, [0, h4[0] >>> 1]);
        h4 = _x64Multiply(h4, [4283543511, 3981806797]);
        h4 = _x64Xor(h4, [0, h4[0] >>> 1]);
        h4 = _x64Multiply(h4, [3301882366, 444984403]);
        h4 = _x64Xor(h4, [0, h4[0] >>> 1]);
        return h4;
      }
      library2.x86.hash32 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 4;
        var bytes = key.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c22 = 461845907;
        for (var i4 = 0; i4 < bytes; i4 = i4 + 4) {
          k1 = key.charCodeAt(i4) & 255 | (key.charCodeAt(i4 + 1) & 255) << 8 | (key.charCodeAt(i4 + 2) & 255) << 16 | (key.charCodeAt(i4 + 3) & 255) << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= (key.charCodeAt(i4 + 2) & 255) << 16;
          case 2:
            k1 ^= (key.charCodeAt(i4 + 1) & 255) << 8;
          case 1:
            k1 ^= key.charCodeAt(i4) & 255;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library2.x86.hash128 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = seed;
        var h22 = seed;
        var h32 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c22 = 2869860233;
        var c32 = 951274213;
        var c4 = 2716044179;
        for (var i4 = 0; i4 < bytes; i4 = i4 + 16) {
          k1 = key.charCodeAt(i4) & 255 | (key.charCodeAt(i4 + 1) & 255) << 8 | (key.charCodeAt(i4 + 2) & 255) << 16 | (key.charCodeAt(i4 + 3) & 255) << 24;
          k2 = key.charCodeAt(i4 + 4) & 255 | (key.charCodeAt(i4 + 5) & 255) << 8 | (key.charCodeAt(i4 + 6) & 255) << 16 | (key.charCodeAt(i4 + 7) & 255) << 24;
          k3 = key.charCodeAt(i4 + 8) & 255 | (key.charCodeAt(i4 + 9) & 255) << 8 | (key.charCodeAt(i4 + 10) & 255) << 16 | (key.charCodeAt(i4 + 11) & 255) << 24;
          k4 = key.charCodeAt(i4 + 12) & 255 | (key.charCodeAt(i4 + 13) & 255) << 8 | (key.charCodeAt(i4 + 14) & 255) << 16 | (key.charCodeAt(i4 + 15) & 255) << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c22);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h22;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c22);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c32);
          h22 ^= k2;
          h22 = _x86Rotl(h22, 17);
          h22 += h32;
          h22 = _x86Multiply(h22, 5) + 197830471;
          k3 = _x86Multiply(k3, c32);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h32 ^= k3;
          h32 = _x86Rotl(h32, 15);
          h32 += h4;
          h32 = _x86Multiply(h32, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= key.charCodeAt(i4 + 14) << 16;
          case 14:
            k4 ^= key.charCodeAt(i4 + 13) << 8;
          case 13:
            k4 ^= key.charCodeAt(i4 + 12);
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= key.charCodeAt(i4 + 11) << 24;
          case 11:
            k3 ^= key.charCodeAt(i4 + 10) << 16;
          case 10:
            k3 ^= key.charCodeAt(i4 + 9) << 8;
          case 9:
            k3 ^= key.charCodeAt(i4 + 8);
            k3 = _x86Multiply(k3, c32);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h32 ^= k3;
          case 8:
            k2 ^= key.charCodeAt(i4 + 7) << 24;
          case 7:
            k2 ^= key.charCodeAt(i4 + 6) << 16;
          case 6:
            k2 ^= key.charCodeAt(i4 + 5) << 8;
          case 5:
            k2 ^= key.charCodeAt(i4 + 4);
            k2 = _x86Multiply(k2, c22);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c32);
            h22 ^= k2;
          case 4:
            k1 ^= key.charCodeAt(i4 + 3) << 24;
          case 3:
            k1 ^= key.charCodeAt(i4 + 2) << 16;
          case 2:
            k1 ^= key.charCodeAt(i4 + 1) << 8;
          case 1:
            k1 ^= key.charCodeAt(i4);
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c22);
            h1 ^= k1;
        }
        h1 ^= key.length;
        h22 ^= key.length;
        h32 ^= key.length;
        h4 ^= key.length;
        h1 += h22;
        h1 += h32;
        h1 += h4;
        h22 += h1;
        h32 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h22 = _x86Fmix(h22);
        h32 = _x86Fmix(h32);
        h4 = _x86Fmix(h4);
        h1 += h22;
        h1 += h32;
        h1 += h4;
        h22 += h1;
        h32 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h22 >>> 0).toString(16)).slice(-8) + ("00000000" + (h32 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library2.x64.hash128 = function(key, seed) {
        key = key || "";
        seed = seed || 0;
        var remainder = key.length % 16;
        var bytes = key.length - remainder;
        var h1 = [0, seed];
        var h22 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c22 = [1291169091, 658871167];
        for (var i4 = 0; i4 < bytes; i4 = i4 + 16) {
          k1 = [key.charCodeAt(i4 + 4) & 255 | (key.charCodeAt(i4 + 5) & 255) << 8 | (key.charCodeAt(i4 + 6) & 255) << 16 | (key.charCodeAt(i4 + 7) & 255) << 24, key.charCodeAt(i4) & 255 | (key.charCodeAt(i4 + 1) & 255) << 8 | (key.charCodeAt(i4 + 2) & 255) << 16 | (key.charCodeAt(i4 + 3) & 255) << 24];
          k2 = [key.charCodeAt(i4 + 12) & 255 | (key.charCodeAt(i4 + 13) & 255) << 8 | (key.charCodeAt(i4 + 14) & 255) << 16 | (key.charCodeAt(i4 + 15) & 255) << 24, key.charCodeAt(i4 + 8) & 255 | (key.charCodeAt(i4 + 9) & 255) << 8 | (key.charCodeAt(i4 + 10) & 255) << 16 | (key.charCodeAt(i4 + 11) & 255) << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c22);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h22);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c22);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h22 = _x64Xor(h22, k2);
          h22 = _x64Rotl(h22, 31);
          h22 = _x64Add(h22, h1);
          h22 = _x64Add(_x64Multiply(h22, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i4 + 14)], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i4 + 13)], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i4 + 12)], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i4 + 11)], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i4 + 10)], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i4 + 9)], 8));
          case 9:
            k2 = _x64Xor(k2, [0, key.charCodeAt(i4 + 8)]);
            k2 = _x64Multiply(k2, c22);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h22 = _x64Xor(h22, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 7)], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 6)], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 5)], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 4)], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 3)], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 2)], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i4 + 1)], 8));
          case 1:
            k1 = _x64Xor(k1, [0, key.charCodeAt(i4)]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c22);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, key.length]);
        h22 = _x64Xor(h22, [0, key.length]);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        h1 = _x64Fmix(h1);
        h22 = _x64Fmix(h22);
        h1 = _x64Add(h1, h22);
        h22 = _x64Add(h22, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h22[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = library2;
        }
        exports.murmurHash3 = library2;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library2;
        });
      } else {
        library2._murmurHash3 = root.murmurHash3;
        library2.noConflict = function() {
          root.murmurHash3 = library2._murmurHash3;
          library2._murmurHash3 = undefined2;
          library2.noConflict = undefined2;
          return library2;
        };
        root.murmurHash3 = library2;
      }
    })(exports);
  }
});

// ../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js
var require_murmurhash3js = __commonJS({
  "../../../node_modules/.pnpm/murmurhash3js@3.0.1/node_modules/murmurhash3js/index.js"(exports, module) {
    module.exports = require_murmurHash3js();
  }
});

// ../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/lib/index.js"(exports, module) {
    "use strict";
    var AsyncLock2 = function(opts) {
      opts = opts || {};
      this.Promise = opts.Promise || Promise;
      this.queues = /* @__PURE__ */ Object.create(null);
      this.domainReentrant = opts.domainReentrant || false;
      if (this.domainReentrant) {
        if (typeof process === "undefined" || typeof process.domain === "undefined") {
          throw new Error(
            "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
          );
        }
        this.domains = /* @__PURE__ */ Object.create(null);
      }
      this.timeout = opts.timeout || AsyncLock2.DEFAULT_TIMEOUT;
      this.maxOccupationTime = opts.maxOccupationTime || AsyncLock2.DEFAULT_MAX_OCCUPATION_TIME;
      this.maxExecutionTime = opts.maxExecutionTime || AsyncLock2.DEFAULT_MAX_EXECUTION_TIME;
      if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= 0) {
        this.maxPending = opts.maxPending;
      } else {
        this.maxPending = AsyncLock2.DEFAULT_MAX_PENDING;
      }
    };
    AsyncLock2.DEFAULT_TIMEOUT = 0;
    AsyncLock2.DEFAULT_MAX_OCCUPATION_TIME = 0;
    AsyncLock2.DEFAULT_MAX_EXECUTION_TIME = 0;
    AsyncLock2.DEFAULT_MAX_PENDING = 1e3;
    AsyncLock2.prototype.acquire = function(key, fn, cb, opts) {
      if (Array.isArray(key)) {
        return this._acquireBatch(key, fn, cb, opts);
      }
      if (typeof fn !== "function") {
        throw new Error("You must pass a function to execute");
      }
      var deferredResolve = null;
      var deferredReject = null;
      var deferred = null;
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
        deferred = new this.Promise(function(resolve, reject) {
          deferredResolve = resolve;
          deferredReject = reject;
        });
      }
      opts = opts || {};
      var resolved = false;
      var timer = null;
      var occupationTimer = null;
      var executionTimer = null;
      var self = this;
      var done = function(locked, err, ret) {
        if (occupationTimer) {
          clearTimeout(occupationTimer);
          occupationTimer = null;
        }
        if (executionTimer) {
          clearTimeout(executionTimer);
          executionTimer = null;
        }
        if (locked) {
          if (!!self.queues[key] && self.queues[key].length === 0) {
            delete self.queues[key];
          }
          if (self.domainReentrant) {
            delete self.domains[key];
          }
        }
        if (!resolved) {
          if (!deferred) {
            if (typeof cb === "function") {
              cb(err, ret);
            }
          } else {
            if (err) {
              deferredReject(err);
            } else {
              deferredResolve(ret);
            }
          }
          resolved = true;
        }
        if (locked) {
          if (!!self.queues[key] && self.queues[key].length > 0) {
            self.queues[key].shift()();
          }
        }
      };
      var exec = function(locked) {
        if (resolved) {
          return done(locked);
        }
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        if (self.domainReentrant && locked) {
          self.domains[key] = process.domain;
        }
        var maxExecutionTime = opts.maxExecutionTime || self.maxExecutionTime;
        if (maxExecutionTime) {
          executionTimer = setTimeout(function() {
            if (!!self.queues[key]) {
              done(locked, new Error("Maximum execution time is exceeded " + key));
            }
          }, maxExecutionTime);
        }
        if (fn.length === 1) {
          var called = false;
          try {
            fn(function(err, ret) {
              if (!called) {
                called = true;
                done(locked, err, ret);
              }
            });
          } catch (err) {
            if (!called) {
              called = true;
              done(locked, err);
            }
          }
        } else {
          self._promiseTry(function() {
            return fn();
          }).then(function(ret) {
            done(locked, void 0, ret);
          }, function(error) {
            done(locked, error);
          });
        }
      };
      if (self.domainReentrant && !!process.domain) {
        exec = process.domain.bind(exec);
      }
      var maxPending = opts.maxPending || self.maxPending;
      if (!self.queues[key]) {
        self.queues[key] = [];
        exec(true);
      } else if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {
        exec(false);
      } else if (self.queues[key].length >= maxPending) {
        done(false, new Error("Too many pending tasks in queue " + key));
      } else {
        var taskFn = function() {
          exec(true);
        };
        if (opts.skipQueue) {
          self.queues[key].unshift(taskFn);
        } else {
          self.queues[key].push(taskFn);
        }
        var timeout = opts.timeout || self.timeout;
        if (timeout) {
          timer = setTimeout(function() {
            timer = null;
            done(false, new Error("async-lock timed out in queue " + key));
          }, timeout);
        }
      }
      var maxOccupationTime = opts.maxOccupationTime || self.maxOccupationTime;
      if (maxOccupationTime) {
        occupationTimer = setTimeout(function() {
          if (!!self.queues[key]) {
            done(false, new Error("Maximum occupation time is exceeded in queue " + key));
          }
        }, maxOccupationTime);
      }
      if (deferred) {
        return deferred;
      }
    };
    AsyncLock2.prototype._acquireBatch = function(keys, fn, cb, opts) {
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
      }
      var self = this;
      var getFn = function(key, fn2) {
        return function(cb2) {
          self.acquire(key, fn2, cb2, opts);
        };
      };
      var fnx = keys.reduceRight(function(prev, key) {
        return getFn(key, prev);
      }, fn);
      if (typeof cb === "function") {
        fnx(cb);
      } else {
        return new this.Promise(function(resolve, reject) {
          if (fnx.length === 1) {
            fnx(function(err, ret) {
              if (err) {
                reject(err);
              } else {
                resolve(ret);
              }
            });
          } else {
            resolve(fnx());
          }
        });
      }
    };
    AsyncLock2.prototype.isBusy = function(key) {
      if (!key) {
        return Object.keys(this.queues).length > 0;
      } else {
        return !!this.queues[key];
      }
    };
    AsyncLock2.prototype._promiseTry = function(fn) {
      try {
        return this.Promise.resolve(fn());
      } catch (e6) {
        return this.Promise.reject(e6);
      }
    };
    module.exports = AsyncLock2;
  }
});

// ../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/index.js
var require_async_lock = __commonJS({
  "../../../node_modules/.pnpm/async-lock@1.4.1/node_modules/async-lock/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// ../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup2 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i4 = 0, len = code.length; i4 < len; ++i4) {
      lookup2[i4] = code[i4];
      revLookup[code.charCodeAt(i4)] = i4;
    }
    var i4;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i5;
      for (i5 = 0; i5 < len2; i5 += 4) {
        tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num3) {
      return lookup2[num3 >> 18 & 63] + lookup2[num3 >> 12 & 63] + lookup2[num3 >> 6 & 63] + lookup2[num3 & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i5 = start; i5 < end; i5 += 3) {
        tmp = (uint8[i5] << 16 & 16711680) + (uint8[i5 + 1] << 8 & 65280) + (uint8[i5 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset3, isLE, mLen, nBytes) {
      var e6, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i4 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer[offset3 + i4];
      i4 += d2;
      e6 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e6 = e6 * 256 + buffer[offset3 + i4], i4 += d2, nBits -= 8) {
      }
      m2 = e6 & (1 << -nBits) - 1;
      e6 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset3 + i4], i4 += d2, nBits -= 8) {
      }
      if (e6 === 0) {
        e6 = 1 - eBias;
      } else if (e6 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e6 = e6 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e6 - mLen);
    };
    exports.write = function(buffer, value, offset3, isLE, mLen, nBytes) {
      var e6, m2, c4;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i4 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e6 = eMax;
      } else {
        e6 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c4 = Math.pow(2, -e6)) < 1) {
          e6--;
          c4 *= 2;
        }
        if (e6 + eBias >= 1) {
          value += rt2 / c4;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c4 >= 2) {
          e6++;
          c4 /= 2;
        }
        if (e6 + eBias >= eMax) {
          m2 = 0;
          e6 = eMax;
        } else if (e6 + eBias >= 1) {
          m2 = (value * c4 - 1) * Math.pow(2, mLen);
          e6 = e6 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e6 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset3 + i4] = m2 & 255, i4 += d2, m2 /= 256, mLen -= 8) {
      }
      e6 = e6 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset3 + i4] = e6 & 255, i4 += d2, e6 /= 256, eLen -= 8) {
      }
      buffer[offset3 + i4 - d2] |= s2 * 128;
    };
  }
});

// ../../../node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../../node_modules/.pnpm/buffer@5.7.1/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e6) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b2 = fromObject(value);
      if (b2)
        return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size3) {
      if (typeof size3 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size3 < 0) {
        throw new RangeError('The value "' + size3 + '" is invalid for option "size"');
      }
    }
    function alloc(size3, fill, encoding) {
      assertSize(size3);
      if (size3 <= 0) {
        return createBuffer(size3);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size3).fill(fill, encoding) : createBuffer(size3).fill(fill);
      }
      return createBuffer(size3);
    }
    Buffer2.alloc = function(size3, fill, encoding) {
      return alloc(size3, fill, encoding);
    };
    function allocUnsafe(size3) {
      assertSize(size3);
      return createBuffer(size3 < 0 ? 0 : checked(size3) | 0);
    }
    Buffer2.allocUnsafe = function(size3) {
      return allocUnsafe(size3);
    };
    Buffer2.allocUnsafeSlow = function(size3) {
      return allocUnsafe(size3);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i4 = 0; i4 < length; i4 += 1) {
        buf[i4] = array[i4] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a2, b2) {
      if (isInstance(a2, Uint8Array))
        a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array))
        b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2)
        return 0;
      var x2 = a2.length;
      var y2 = b2.length;
      for (var i4 = 0, len = Math.min(x2, y2); i4 < len; ++i4) {
        if (a2[i4] !== b2[i4]) {
          x2 = a2[i4];
          y2 = b2[i4];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i4;
      if (length === void 0) {
        length = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length += list[i4].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        var buf = list[i4];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n5, m2) {
      var i4 = b2[n5];
      b2[n5] = b2[m2];
      b2[m2] = i4;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 2) {
        swap(this, i4, i4 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 4) {
        swap(this, i4, i4 + 3);
        swap(this, i4 + 1, i4 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i4 = 0; i4 < len; i4 += 8) {
        swap(this, i4, i4 + 7);
        swap(this, i4 + 1, i4 + 6);
        swap(this, i4 + 2, i4 + 5);
        swap(this, i4 + 3, i4 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2))
        throw new TypeError("Argument must be a Buffer");
      if (this === b2)
        return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max6 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max6).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max6)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x2 = thisEnd - thisStart;
      var y2 = end - start;
      var len = Math.min(x2, y2);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i4 = 0; i4 < len; ++i4) {
        if (thisCopy[i4] !== targetCopy[i4]) {
          x2 = thisCopy[i4];
          y2 = targetCopy[i4];
          break;
        }
      }
      if (x2 < y2)
        return -1;
      if (y2 < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i5) {
        if (indexSize === 1) {
          return buf[i5];
        } else {
          return buf.readUInt16BE(i5 * indexSize);
        }
      }
      var i4;
      if (dir) {
        var foundIndex = -1;
        for (i4 = byteOffset; i4 < arrLength; i4++) {
          if (read(arr, i4) === read(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i4;
            if (i4 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i4 -= i4 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i4 = byteOffset; i4 >= 0; i4--) {
          var found = true;
          for (var j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i4 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found)
            return i4;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset3, length) {
      offset3 = Number(offset3) || 0;
      var remaining = buf.length - offset3;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i4 = 0; i4 < length; ++i4) {
        var parsed = parseInt(string.substr(i4 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i4;
        buf[offset3 + i4] = parsed;
      }
      return i4;
    }
    function utf8Write(buf, string, offset3, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset3), buf, offset3, length);
    }
    function asciiWrite(buf, string, offset3, length) {
      return blitBuffer(asciiToBytes(string), buf, offset3, length);
    }
    function base64Write(buf, string, offset3, length) {
      return blitBuffer(base64ToBytes(string), buf, offset3, length);
    }
    function ucs2Write(buf, string, offset3, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset3), buf, offset3, length);
    }
    Buffer2.prototype.write = function write(string, offset3, length, encoding) {
      if (offset3 === void 0) {
        encoding = "utf8";
        length = this.length;
        offset3 = 0;
      } else if (length === void 0 && typeof offset3 === "string") {
        encoding = offset3;
        length = this.length;
        offset3 = 0;
      } else if (isFinite(offset3)) {
        offset3 = offset3 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset3;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset3 < 0) || offset3 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset3, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset3, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset3, length);
          case "base64":
            return base64Write(this, string, offset3, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset3, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i4 = start;
      while (i4 < end) {
        var firstByte = buf[i4];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i4 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i4 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              fourthByte = buf[i4 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i4 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i4 = 0;
      while (i4 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i4 = start; i4 < end; ++i4) {
        ret += String.fromCharCode(buf[i4] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i4 = start; i4 < end; ++i4) {
        ret += String.fromCharCode(buf[i4]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i4 = start; i4 < end; ++i4) {
        out += hexSliceLookupTable[buf[i4]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i4 = 0; i4 < bytes.length - 1; i4 += 2) {
        res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset3, ext, length) {
      if (offset3 % 1 !== 0 || offset3 < 0)
        throw new RangeError("offset is not uint");
      if (offset3 + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset3, byteLength2, this.length);
      var val = this[offset3];
      var mul = 1;
      var i4 = 0;
      while (++i4 < byteLength2 && (mul *= 256)) {
        val += this[offset3 + i4] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset3, byteLength2, this.length);
      }
      var val = this[offset3 + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset3 + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 1, this.length);
      return this[offset3];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      return this[offset3] | this[offset3 + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      return this[offset3] << 8 | this[offset3 + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset3, byteLength2, this.length);
      var val = this[offset3];
      var mul = 1;
      var i4 = 0;
      while (++i4 < byteLength2 && (mul *= 256)) {
        val += this[offset3 + i4] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset3, byteLength2, this.length);
      var i4 = byteLength2;
      var mul = 1;
      var val = this[offset3 + --i4];
      while (i4 > 0 && (mul *= 256)) {
        val += this[offset3 + --i4] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 1, this.length);
      if (!(this[offset3] & 128))
        return this[offset3];
      return (255 - this[offset3] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      var val = this[offset3] | this[offset3 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      var val = this[offset3 + 1] | this[offset3] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return ieee754.read(this, offset3, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return ieee754.read(this, offset3, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 8, this.length);
      return ieee754.read(this, offset3, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 8, this.length);
      return ieee754.read(this, offset3, false, 52, 8);
    };
    function checkInt(buf, value, offset3, ext, max6, min6) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max6 || value < min6)
        throw new RangeError('"value" argument is out of bounds');
      if (offset3 + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset3, byteLength2, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset3, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i4 = 0;
      this[offset3] = value & 255;
      while (++i4 < byteLength2 && (mul *= 256)) {
        this[offset3 + i4] = value / mul & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset3, byteLength2, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset3, byteLength2, maxBytes, 0);
      }
      var i4 = byteLength2 - 1;
      var mul = 1;
      this[offset3 + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        this[offset3 + i4] = value / mul & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 1, 255, 0);
      this[offset3] = value & 255;
      return offset3 + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 2, 65535, 0);
      this[offset3] = value & 255;
      this[offset3 + 1] = value >>> 8;
      return offset3 + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 2, 65535, 0);
      this[offset3] = value >>> 8;
      this[offset3 + 1] = value & 255;
      return offset3 + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 4, 4294967295, 0);
      this[offset3 + 3] = value >>> 24;
      this[offset3 + 2] = value >>> 16;
      this[offset3 + 1] = value >>> 8;
      this[offset3] = value & 255;
      return offset3 + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 4, 4294967295, 0);
      this[offset3] = value >>> 24;
      this[offset3 + 1] = value >>> 16;
      this[offset3 + 2] = value >>> 8;
      this[offset3 + 3] = value & 255;
      return offset3 + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset3, byteLength2, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset3, byteLength2, limit - 1, -limit);
      }
      var i4 = 0;
      var mul = 1;
      var sub = 0;
      this[offset3] = value & 255;
      while (++i4 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset3 + i4 - 1] !== 0) {
          sub = 1;
        }
        this[offset3 + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset3, byteLength2, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset3, byteLength2, limit - 1, -limit);
      }
      var i4 = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset3 + i4] = value & 255;
      while (--i4 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset3 + i4 + 1] !== 0) {
          sub = 1;
        }
        this[offset3 + i4] = (value / mul >> 0) - sub & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset3] = value & 255;
      return offset3 + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 2, 32767, -32768);
      this[offset3] = value & 255;
      this[offset3 + 1] = value >>> 8;
      return offset3 + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 2, 32767, -32768);
      this[offset3] = value >>> 8;
      this[offset3 + 1] = value & 255;
      return offset3 + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 4, 2147483647, -2147483648);
      this[offset3] = value & 255;
      this[offset3 + 1] = value >>> 8;
      this[offset3 + 2] = value >>> 16;
      this[offset3 + 3] = value >>> 24;
      return offset3 + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset3, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value, offset3, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset3] = value >>> 24;
      this[offset3 + 1] = value >>> 16;
      this[offset3 + 2] = value >>> 8;
      this[offset3 + 3] = value & 255;
      return offset3 + 4;
    };
    function checkIEEE754(buf, value, offset3, ext, max6, min6) {
      if (offset3 + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset3 < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset3, littleEndian, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset3, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset3, littleEndian, 23, 4);
      return offset3 + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset3, noAssert) {
      return writeFloat(this, value, offset3, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset3, noAssert) {
      return writeFloat(this, value, offset3, false, noAssert);
    };
    function writeDouble(buf, value, offset3, littleEndian, noAssert) {
      value = +value;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset3, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset3, littleEndian, 52, 8);
      return offset3 + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset3, noAssert) {
      return writeDouble(this, value, offset3, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset3, noAssert) {
      return writeDouble(this, value, offset3, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i4;
      if (typeof val === "number") {
        for (i4 = start; i4 < end; ++i4) {
          this[i4] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i4 = 0; i4 < end - start; ++i4) {
          this[i4 + start] = bytes[i4 % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i4 = 0; i4 < length; ++i4) {
        codePoint = string.charCodeAt(i4);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i4 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i4 = 0; i4 < str.length; ++i4) {
        byteArray.push(str.charCodeAt(i4) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c4, hi, lo;
      var byteArray = [];
      for (var i4 = 0; i4 < str.length; ++i4) {
        if ((units -= 2) < 0)
          break;
        c4 = str.charCodeAt(i4);
        hi = c4 >> 8;
        lo = c4 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset3, length) {
      for (var i4 = 0; i4 < length; ++i4) {
        if (i4 + offset3 >= dst.length || i4 >= src.length)
          break;
        dst[i4 + offset3] = src[i4];
      }
      return i4;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i4 = 0; i4 < 16; ++i4) {
        var i16 = i4 * 16;
        for (var j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i4] + alphabet[j2];
        }
      }
      return table;
    }();
  }
});

// ../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size3, fill, encoding) {
      if (typeof size3 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size3);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size3) {
      if (typeof size3 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size3);
    };
    SafeBuffer.allocUnsafeSlow = function(size3) {
      if (typeof size3 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size3);
    };
  }
});

// ../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js
var require_hash2 = __commonJS({
  "../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js"(exports, module) {
    var Buffer2 = require_safe_buffer().Buffer;
    function Hash2(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash2.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf8";
        data = Buffer2.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset3 = 0; offset3 < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset3, blockSize - assigned);
        for (var i4 = 0; i4 < remainder; i4++) {
          block[assigned + i4] = data[offset3 + i4];
        }
        accum += remainder;
        offset3 += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash2.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash2 = this._hash();
      return enc ? hash2.toString(enc) : hash2;
    };
    Hash2.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash2;
  }
});

// ../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "../../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash2 = require_hash2();
    var Buffer2 = require_safe_buffer().Buffer;
    var K2 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash2.call(this, 64, 56);
    }
    inherits(Sha1, Hash2);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num3) {
      return num3 << 1 | num3 >>> 31;
    }
    function rotl5(num3) {
      return num3 << 5 | num3 >>> 27;
    }
    function rotl30(num3) {
      return num3 << 30 | num3 >>> 2;
    }
    function ft(s2, b2, c4, d2) {
      if (s2 === 0)
        return b2 & c4 | ~b2 & d2;
      if (s2 === 2)
        return b2 & c4 | b2 & d2 | c4 & d2;
      return b2 ^ c4 ^ d2;
    }
    Sha1.prototype._update = function(M2) {
      var W2 = this._w;
      var a2 = this._a | 0;
      var b2 = this._b | 0;
      var c4 = this._c | 0;
      var d2 = this._d | 0;
      var e6 = this._e | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W2[i4] = M2.readInt32BE(i4 * 4);
      for (; i4 < 80; ++i4)
        W2[i4] = rotl1(W2[i4 - 3] ^ W2[i4 - 8] ^ W2[i4 - 14] ^ W2[i4 - 16]);
      for (var j2 = 0; j2 < 80; ++j2) {
        var s2 = ~~(j2 / 20);
        var t5 = rotl5(a2) + ft(s2, b2, c4, d2) + e6 + W2[j2] + K2[s2] | 0;
        e6 = d2;
        d2 = c4;
        c4 = rotl30(b2);
        b2 = a2;
        a2 = t5;
      }
      this._a = a2 + this._a | 0;
      this._b = b2 + this._b | 0;
      this._c = c4 + this._c | 0;
      this._d = d2 + this._d | 0;
      this._e = e6 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  }
});

// ../../../node_modules/.pnpm/crc-32@1.2.2/node_modules/crc-32/crc32.js
var require_crc32 = __commonJS({
  "../../../node_modules/.pnpm/crc-32@1.2.2/node_modules/crc-32/crc32.js"(exports) {
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module2 = {};
            factory(module2);
            return module2;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.2";
      function signed_crc_table() {
        var c4 = 0, table = new Array(256);
        for (var n5 = 0; n5 != 256; ++n5) {
          c4 = n5;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          c4 = c4 & 1 ? -306674912 ^ c4 >>> 1 : c4 >>> 1;
          table[n5] = c4;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T10) {
        var c4 = 0, v2 = 0, n5 = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n5 = 0; n5 != 256; ++n5)
          table[n5] = T10[n5];
        for (n5 = 0; n5 != 256; ++n5) {
          v2 = T10[n5];
          for (c4 = 256 + n5; c4 < 4096; c4 += 256)
            v2 = table[c4] = v2 >>> 8 ^ T10[v2 & 255];
        }
        var out = [];
        for (n5 = 1; n5 != 16; ++n5)
          out[n5 - 1] = typeof Int32Array !== "undefined" ? table.subarray(n5 * 256, n5 * 256 + 256) : table.slice(n5 * 256, n5 * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te2 = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i4 = 0, L = bstr.length; i4 < L; )
          C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i4++)) & 255];
        return ~C;
      }
      function crc32_buf(B2, seed) {
        var C = seed ^ -1, L = B2.length - 15, i4 = 0;
        for (; i4 < L; )
          C = Tf[B2[i4++] ^ C & 255] ^ Te2[B2[i4++] ^ C >> 8 & 255] ^ Td[B2[i4++] ^ C >> 16 & 255] ^ Tc[B2[i4++] ^ C >>> 24] ^ Tb[B2[i4++]] ^ Ta[B2[i4++]] ^ T9[B2[i4++]] ^ T8[B2[i4++]] ^ T7[B2[i4++]] ^ T6[B2[i4++]] ^ T5[B2[i4++]] ^ T4[B2[i4++]] ^ T3[B2[i4++]] ^ T2[B2[i4++]] ^ T1[B2[i4++]] ^ T0[B2[i4++]];
        L += 15;
        while (i4 < L)
          C = C >>> 8 ^ T0[(C ^ B2[i4++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i4 = 0, L = str.length, c4 = 0, d2 = 0; i4 < L; ) {
          c4 = str.charCodeAt(i4++);
          if (c4 < 128) {
            C = C >>> 8 ^ T0[(C ^ c4) & 255];
          } else if (c4 < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c4 >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c4 & 63)) & 255];
          } else if (c4 >= 55296 && c4 < 57344) {
            c4 = (c4 & 1023) + 64;
            d2 = str.charCodeAt(i4++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c4 >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c4 >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d2 >> 6 & 15 | (c4 & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d2 & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c4 >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c4 >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c4 & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC322.table = T0;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
var require_common2 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size3) {
      if (buf.length === size3) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size3);
      }
      buf.length = size3;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i4 = 0; i4 < len; i4++) {
          dest[dest_offs + i4] = src[src_offs + i4];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i4, l2, len, pos, chunk, result;
        len = 0;
        for (i4 = 0, l2 = chunks.length; i4 < l2; i4++) {
          len += chunks[i4].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i4 = 0, l2 = chunks.length; i4 < l2; i4++) {
          chunk = chunks[i4];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i4 = 0; i4 < len; i4++) {
          dest[dest_offs + i4] = src[src_offs + i4];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common2();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s2, w2) {
      s2.pending_buf[s2.pending++] = w2 & 255;
      s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
    }
    function send_bits(s2, value, length) {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    }
    function send_code(s2, c4, tree) {
      send_bits(
        s2,
        tree[c4 * 2],
        tree[c4 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s2) {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h4;
      var n5, m2;
      var bits;
      var xbits;
      var f4;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h4 = s2.heap_max + 1; h4 < HEAP_SIZE; h4++) {
        n5 = s2.heap[h4];
        bits = tree[tree[n5 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n5 * 2 + 1] = bits;
        if (n5 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n5 >= base) {
          xbits = extra[n5 - base];
        }
        f4 = tree[n5 * 2];
        s2.opt_len += f4 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f4 * (stree[n5 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n5 = s2.bl_count[bits];
        while (n5 !== 0) {
          m2 = s2.heap[--h4];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n5--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n5;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n5 = 0; n5 <= max_code; n5++) {
        var len = tree[n5 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n5 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n5;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n5 = 0; n5 < 1 << extra_lbits[code]; n5++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n5 = 0; n5 < 1 << extra_dbits[code]; n5++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n5 = 0; n5 < 1 << extra_dbits[code] - 7; n5++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n5 = 0;
      while (n5 <= 143) {
        static_ltree[n5 * 2 + 1] = 8;
        n5++;
        bl_count[8]++;
      }
      while (n5 <= 255) {
        static_ltree[n5 * 2 + 1] = 9;
        n5++;
        bl_count[9]++;
      }
      while (n5 <= 279) {
        static_ltree[n5 * 2 + 1] = 7;
        n5++;
        bl_count[7]++;
      }
      while (n5 <= 287) {
        static_ltree[n5 * 2 + 1] = 8;
        n5++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n5 = 0; n5 < D_CODES; n5++) {
        static_dtree[n5 * 2 + 1] = 5;
        static_dtree[n5 * 2] = bi_reverse(n5, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s2) {
      var n5;
      for (n5 = 0; n5 < L_CODES; n5++) {
        s2.dyn_ltree[n5 * 2] = 0;
      }
      for (n5 = 0; n5 < D_CODES; n5++) {
        s2.dyn_dtree[n5 * 2] = 0;
      }
      for (n5 = 0; n5 < BL_CODES; n5++) {
        s2.bl_tree[n5 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup(s2) {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block(s2, buf, len, header) {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller(tree, n5, m2, depth) {
      var _n2 = n5 * 2;
      var _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n5] <= depth[m2];
    }
    function pqdownheap(s2, tree, k2) {
      var v2 = s2.heap[k2];
      var j2 = k2 << 1;
      while (j2 <= s2.heap_len) {
        if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
          j2++;
        }
        if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
          break;
        }
        s2.heap[k2] = s2.heap[j2];
        k2 = j2;
        j2 <<= 1;
      }
      s2.heap[k2] = v2;
    }
    function compress_block(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    }
    function build_tree(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n5, m2;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n5 = 0; n5 < elems; n5++) {
        if (tree[n5 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n5;
          s2.depth[n5] = 0;
        } else {
          tree[n5 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n5 = s2.heap_len >> 1; n5 >= 1; n5--) {
        pqdownheap(s2, tree, n5);
      }
      node = elems;
      do {
        n5 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n5;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n5 * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n5] >= s2.depth[m2] ? s2.depth[n5] : s2.depth[m2]) + 1;
        tree[n5 * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    }
    function scan_tree(s2, tree, max_code) {
      var n5;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n5 = 0; n5 <= max_code; n5++) {
        curlen = nextlen;
        nextlen = tree[(n5 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s2, tree, max_code) {
      var n5;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n5 = 0; n5 <= max_code; n5++) {
        curlen = nextlen;
        nextlen = tree[(n5 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s2) {
      var max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s2, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s2) {
      var black_mask = 4093624447;
      var n5;
      for (n5 = 0; n5 <= 31; n5++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n5 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n5 = 32; n5 < LITERALS; n5++) {
        if (s2.dyn_ltree[n5 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s2) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    }
    function _tr_stored_block(s2, buf, stored_len, last) {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    }
    function _tr_align(s2) {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    }
    function _tr_flush_block(s2, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    }
    function _tr_tally(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n5 = 0;
      while (len !== 0) {
        n5 = len > 2e3 ? 2e3 : len;
        len -= n5;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n5);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable() {
      var c4, table = [];
      for (var n5 = 0; n5 < 256; n5++) {
        c4 = n5;
        for (var k2 = 0; k2 < 8; k2++) {
          c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
        }
        table[n5] = c4;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc322(crc, buf, len, pos) {
      var t5 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i4 = pos; i4 < end; i4++) {
        crc = crc >>> 8 ^ t5[(crc ^ buf[i4]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc322;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common2();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc322 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f4) {
      return (f4 << 1) - (f4 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only(s2, last) {
      trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    }
    function put_byte(s2, b2) {
      s2.pending_buf[s2.pending++] = b2;
    }
    function putShortMSB(s2, b2) {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    }
    function read_buf(strm, buf, start, size3) {
      var len = strm.avail_in;
      if (len > size3) {
        len = size3;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window(s2) {
      var _w_size = s2.w_size;
      var p2, n5, m2, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n5 = s2.hash_size;
          p2 = n5;
          do {
            m2 = s2.head[--p2];
            s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n5);
          n5 = _w_size;
          p2 = n5;
          do {
            m2 = s2.prev[--p2];
            s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n5);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n5 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n5;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    }
    function deflate_stored(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s2) {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH;
      trees._tr_init(s2);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new utils.Buf8(s2.w_size * 2);
      s2.head = new utils.Buf16(s2.hash_size);
      s2.prev = new utils.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate2(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s2);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status3;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status3 = strm.state.status;
      if (status3 !== INIT_STATE && status3 !== EXTRA_STATE && status3 !== NAME_STATE && status3 !== COMMENT_STATE && status3 !== HCRC_STATE && status3 !== BUSY_STATE && status3 !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status3 === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n5;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils.Buf8(s2.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        str = s2.strstart;
        n5 = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n5);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common2();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q2 = 0; q2 < 256; q2++) {
      _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
    }
    var q2;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c4, c22, m_pos, i4, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c4 = str.charCodeAt(m_pos);
        if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c4 = 65536 + (c4 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c4 < 128 ? 1 : c4 < 2048 ? 2 : c4 < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i4 = 0, m_pos = 0; i4 < buf_len; m_pos++) {
        c4 = str.charCodeAt(m_pos);
        if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c4 = 65536 + (c4 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c4 < 128) {
          buf[i4++] = c4;
        } else if (c4 < 2048) {
          buf[i4++] = 192 | c4 >>> 6;
          buf[i4++] = 128 | c4 & 63;
        } else if (c4 < 65536) {
          buf[i4++] = 224 | c4 >>> 12;
          buf[i4++] = 128 | c4 >>> 6 & 63;
          buf[i4++] = 128 | c4 & 63;
        } else {
          buf[i4++] = 240 | c4 >>> 18;
          buf[i4++] = 128 | c4 >>> 12 & 63;
          buf[i4++] = 128 | c4 >>> 6 & 63;
          buf[i4++] = 128 | c4 & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i4 = 0; i4 < len; i4++) {
        result += String.fromCharCode(buf[i4]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i4 = 0, len = buf.length; i4 < len; i4++) {
        buf[i4] = str.charCodeAt(i4);
      }
      return buf;
    };
    exports.buf2string = function(buf, max6) {
      var i4, out, c4, c_len;
      var len = max6 || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i4 = 0; i4 < len; ) {
        c4 = buf[i4++];
        if (c4 < 128) {
          utf16buf[out++] = c4;
          continue;
        }
        c_len = _utf8len[c4];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i4 += c_len - 1;
          continue;
        }
        c4 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i4 < len) {
          c4 = c4 << 6 | buf[i4++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c4 < 65536) {
          utf16buf[out++] = c4;
        } else {
          c4 -= 65536;
          utf16buf[out++] = 55296 | c4 >> 10 & 1023;
          utf16buf[out++] = 56320 | c4 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max6) {
      var pos;
      max6 = max6 || buf.length;
      if (max6 > buf.length) {
        max6 = buf.length;
      }
      pos = max6 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max6;
      }
      if (pos === 0) {
        return max6;
      }
      return pos + _utf8len[buf[pos]] > max6 ? pos : max6;
    };
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common2();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status3 = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status3 !== Z_OK) {
        throw new Error(msg[status3]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status3 = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status3 !== Z_OK) {
          throw new Error(msg[status3]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status3, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status3 = zlib_deflate.deflate(strm, _mode);
        if (status3 !== Z_STREAM_END && status3 !== Z_OK) {
          this.onEnd(status3);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status3 !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status3 = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status3);
        this.ended = true;
        return status3 === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status3) {
      if (status3 === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status3;
      this.msg = this.strm.msg;
    };
    function deflate2(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate2(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate2(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate2;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils = require_common2();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min6 = 0, max6 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max6 = MAXBITS; max6 >= 1; max6--) {
        if (count[max6] !== 0) {
          break;
        }
      }
      if (root > max6) {
        root = max6;
      }
      if (max6 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min6 = 1; min6 < max6; min6++) {
        if (count[min6] !== 0) {
          break;
        }
      }
      if (root < min6) {
        root = min6;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max6 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min6;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min6 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max6) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min6;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max6) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common2();
    var adler32 = require_adler32();
    var crc322 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q2) {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate2(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n5;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc322(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc322(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc322(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc322(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc322(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc322(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc322(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc322(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n5 = here_bits + 2;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n5 = here_bits + 3;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n5 = here_bits + 7;
                    while (bits < n5) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n5 = state.extra;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n5 = state.extra;
                while (bits < n5) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc322(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc322(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common2();
    var strings = require_strings();
    var c4 = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status3 = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status3 !== c4.Z_OK) {
        throw new Error(msg[status3]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status3 = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status3 !== c4.Z_OK) {
            throw new Error(msg[status3]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status3, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c4.Z_FINISH : c4.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status3 = zlib_inflate.inflate(strm, c4.Z_NO_FLUSH);
        if (status3 === c4.Z_NEED_DICT && dictionary) {
          status3 = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status3 === c4.Z_BUF_ERROR && allowBufError === true) {
          status3 = c4.Z_OK;
          allowBufError = false;
        }
        if (status3 !== c4.Z_STREAM_END && status3 !== c4.Z_OK) {
          this.onEnd(status3);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status3 === c4.Z_STREAM_END || strm.avail_in === 0 && (_mode === c4.Z_FINISH || _mode === c4.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status3 !== c4.Z_STREAM_END);
      if (status3 === c4.Z_STREAM_END) {
        _mode = c4.Z_FINISH;
      }
      if (_mode === c4.Z_FINISH) {
        status3 = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status3);
        this.ended = true;
        return status3 === c4.Z_OK;
      }
      if (_mode === c4.Z_SYNC_FLUSH) {
        this.onEnd(c4.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status3) {
      if (status3 === c4.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status3;
      this.msg = this.strm.msg;
    };
    function inflate2(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate2(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate2;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate2;
  }
});

// ../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js
var require_pako = __commonJS({
  "../../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js"(exports, module) {
    "use strict";
    var assign = require_common2().assign;
    var deflate2 = require_deflate2();
    var inflate2 = require_inflate2();
    var constants = require_constants();
    var pako2 = {};
    assign(pako2, deflate2, inflate2, constants);
    module.exports = pako2;
  }
});

// ../../../node_modules/.pnpm/pify@5.0.0/node_modules/pify/index.js
var require_pify = __commonJS({
  "../../../node_modules/.pnpm/pify@5.0.0/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P2 = options.promiseModule;
      return new P2((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern3) => typeof pattern3 === "string" || typeof key === "symbol" ? key === pattern3 : pattern3.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// ../../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../../node_modules/.pnpm/ignore@5.3.1/node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to2) => from.charCodeAt(0) <= to2.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_2, index2, str) => index2 + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_2, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_2, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern3, ignoreCase) => {
      let source = regexCache[pattern3];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern3)),
          pattern3
        );
        regexCache[pattern3] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern3) => pattern3 && isString(pattern3) && !REGEX_TEST_BLANK_LINE.test(pattern3) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern3) && pattern3.indexOf("#") !== 0;
    var splitPattern = (pattern3) => pattern3.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern3, negative, regex) {
        this.origin = origin;
        this.pattern = pattern3;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern3, ignoreCase) => {
      const origin = pattern3;
      let negative = false;
      if (pattern3.indexOf("!") === 0) {
        negative = true;
        pattern3 = pattern3.substr(1);
      }
      pattern3 = pattern3.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern3, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern3,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r6 = "`path.relative()`d";
        return doThrow(
          `path should be a ${r6} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p2) => p2;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern3) {
        if (pattern3 && pattern3[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern3._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern3)) {
          const rule = createRule(pattern3, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern3) {
        this._added = false;
        makeArray(
          isString(pattern3) ? splitPattern(pattern3) : pattern3
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern3) {
        return this.add(pattern3);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});

// ../../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js"(exports, module) {
    "use strict";
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function replaceAll(str, search, replacement) {
      search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), "g");
      return str.replace(search, replacement);
    }
    var CleanGitRef = {
      clean: function clean(value) {
        if (typeof value !== "string") {
          throw new Error("Expected a string, received: " + value);
        }
        value = replaceAll(value, "./", "/");
        value = replaceAll(value, "..", ".");
        value = replaceAll(value, " ", "-");
        value = replaceAll(value, /^[~^:?*\\\-]/g, "");
        value = replaceAll(value, /[~^:?*\\]/g, "-");
        value = replaceAll(value, /[~^:?*\\\-]$/g, "");
        value = replaceAll(value, "@{", "-");
        value = replaceAll(value, /\.$/g, "");
        value = replaceAll(value, /\/$/g, "");
        value = replaceAll(value, /\.lock$/g, "");
        return value;
      }
    };
    module.exports = CleanGitRef;
  }
});

// ../../../lix/packages/client/vendored/diff3/onp.js
function onp_default(a_, b_) {
  var a2 = a_, b2 = b_, m2 = a2.length, n5 = b2.length, reverse = false, offset3 = m2 + 1, path = [], pathposi = [];
  var tmp1, tmp2;
  var init2 = function() {
    if (m2 >= n5) {
      tmp1 = a2;
      tmp2 = m2;
      a2 = b2;
      b2 = tmp1;
      m2 = n5;
      n5 = tmp2;
      reverse = true;
      offset3 = m2 + 1;
    }
  };
  var P2 = function(startX, startY, endX, endY, r6) {
    return {
      startX,
      startY,
      endX,
      endY,
      r: r6
    };
  };
  var snake = function(k2, p2, pp) {
    var r6, x2, y2, startX, startY;
    if (p2 > pp) {
      r6 = path[k2 - 1 + offset3];
    } else {
      r6 = path[k2 + 1 + offset3];
    }
    startY = y2 = Math.max(p2, pp);
    startX = x2 = y2 - k2;
    while (x2 < m2 && y2 < n5 && a2[x2] === b2[y2]) {
      ++x2;
      ++y2;
    }
    if (startX == x2 && startY == y2) {
      path[k2 + offset3] = r6;
    } else {
      path[k2 + offset3] = pathposi.length;
      pathposi[pathposi.length] = new P2(startX, startY, x2, y2, r6);
    }
    return y2;
  };
  init2();
  return {
    compose: function() {
      var delta, size3, fp, p2, r6, i4, k2, lastStartX, lastStartY, result;
      delta = n5 - m2;
      size3 = m2 + n5 + 3;
      fp = {};
      for (i4 = 0; i4 < size3; ++i4) {
        fp[i4] = -1;
        path[i4] = -1;
      }
      p2 = -1;
      do {
        ++p2;
        for (k2 = -p2; k2 <= delta - 1; ++k2) {
          fp[k2 + offset3] = snake(k2, fp[k2 - 1 + offset3] + 1, fp[k2 + 1 + offset3]);
        }
        for (k2 = delta + p2; k2 >= delta + 1; --k2) {
          fp[k2 + offset3] = snake(k2, fp[k2 - 1 + offset3] + 1, fp[k2 + 1 + offset3]);
        }
        fp[delta + offset3] = snake(delta, fp[delta - 1 + offset3] + 1, fp[delta + 1 + offset3]);
      } while (fp[delta + offset3] !== n5);
      r6 = path[delta + offset3];
      lastStartX = m2;
      lastStartY = n5;
      result = [];
      while (r6 !== -1) {
        let elem = pathposi[r6];
        if (m2 != elem.endX || n5 != elem.endY) {
          result.push({
            file1: [
              reverse ? elem.endY : elem.endX,
              reverse ? lastStartY - elem.endY : lastStartX - elem.endX
            ],
            file2: [
              reverse ? elem.endX : elem.endY,
              reverse ? lastStartX - elem.endX : lastStartY - elem.endY
            ]
          });
        }
        lastStartX = elem.startX;
        lastStartY = elem.startY;
        r6 = pathposi[r6].r;
      }
      if (lastStartX != 0 || lastStartY != 0) {
        result.push({
          file1: [0, reverse ? lastStartY : lastStartX],
          file2: [0, reverse ? lastStartX : lastStartY]
        });
      }
      result.reverse();
      return result;
    }
  };
}
var init_onp = __esm({
  "../../../lix/packages/client/vendored/diff3/onp.js"() {
    "use strict";
  }
});

// ../../../lix/packages/client/vendored/diff3/diff3.js
function diff3MergeIndices(a2, o5, b2) {
  var i4;
  var m1 = new onp_default(o5, a2).compose();
  var m2 = new onp_default(o5, b2).compose();
  var hunks = [];
  function addHunk(h4, side2) {
    hunks.push([h4.file1[0], side2, h4.file1[1], h4.file2[0], h4.file2[1]]);
  }
  for (i4 = 0; i4 < m1.length; i4++) {
    addHunk(m1[i4], 0);
  }
  for (i4 = 0; i4 < m2.length; i4++) {
    addHunk(m2[i4], 2);
  }
  hunks.sort(function(x2, y2) {
    return x2[0] - y2[0];
  });
  var result = [];
  var commonOffset = 0;
  function copyCommon(targetOffset) {
    if (targetOffset > commonOffset) {
      result.push([1, commonOffset, targetOffset - commonOffset]);
      commonOffset = targetOffset;
    }
  }
  for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
    var firstHunkIndex = hunkIndex;
    var hunk = hunks[hunkIndex];
    var regionLhs = hunk[0];
    var regionRhs = regionLhs + hunk[2];
    while (hunkIndex < hunks.length - 1) {
      var maybeOverlapping = hunks[hunkIndex + 1];
      var maybeLhs = maybeOverlapping[0];
      if (maybeLhs > regionRhs)
        break;
      regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
      hunkIndex++;
    }
    copyCommon(regionLhs);
    if (firstHunkIndex == hunkIndex) {
      if (hunk[4] > 0) {
        result.push([hunk[1], hunk[3], hunk[4]]);
      }
    } else {
      var regions = {
        0: [a2.length, -1, o5.length, -1],
        2: [b2.length, -1, o5.length, -1]
      };
      for (i4 = firstHunkIndex; i4 <= hunkIndex; i4++) {
        hunk = hunks[i4];
        var side = hunk[1];
        var r6 = regions[side];
        var oLhs = hunk[0];
        var oRhs = oLhs + hunk[2];
        var abLhs = hunk[3];
        var abRhs = abLhs + hunk[4];
        r6[0] = Math.min(abLhs, r6[0]);
        r6[1] = Math.max(abRhs, r6[1]);
        r6[2] = Math.min(oLhs, r6[2]);
        r6[3] = Math.max(oRhs, r6[3]);
      }
      var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
      var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
      var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
      var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
      result.push([
        -1,
        aLhs,
        aRhs - aLhs,
        regionLhs,
        regionRhs - regionLhs,
        bLhs,
        bRhs - bLhs
      ]);
    }
    commonOffset = regionRhs;
  }
  copyCommon(o5.length);
  return result;
}
function diff3Merge(a2, o5, b2) {
  var result = [];
  var files = [a2, o5, b2];
  var indices = diff3MergeIndices(a2, o5, b2);
  var okLines = [];
  function flushOk() {
    if (okLines.length) {
      result.push({
        ok: okLines
      });
    }
    okLines = [];
  }
  function pushOk(xs) {
    for (const x_ of xs) {
      okLines.push(x_);
    }
  }
  function isTrueConflict(rec) {
    if (rec[2] != rec[6])
      return true;
    var aoff = rec[1];
    var boff = rec[5];
    for (var j2 = 0; j2 < rec[2]; j2++) {
      if (a2[j2 + aoff] != b2[j2 + boff])
        return true;
    }
    return false;
  }
  for (var x2 of indices) {
    var side = x2[0];
    if (side == -1) {
      if (!isTrueConflict(x2)) {
        pushOk(files[0].slice(x2[1], x2[1] + x2[2]));
      } else {
        flushOk();
        result.push({
          conflict: {
            a: a2.slice(x2[1], x2[1] + x2[2]),
            aIndex: x2[1],
            o: o5.slice(x2[3], x2[3] + x2[4]),
            oIndex: x2[3],
            b: b2.slice(x2[5], x2[5] + x2[6]),
            bIndex: x2[5]
          }
        });
      }
    } else {
      pushOk(files[side].slice(x2[1], x2[1] + x2[2]));
    }
  }
  flushOk();
  return result;
}
var diff3_default;
var init_diff3 = __esm({
  "../../../lix/packages/client/vendored/diff3/diff3.js"() {
    "use strict";
    init_onp();
    diff3_default = diff3Merge;
  }
});

// ../../../lix/packages/client/vendored/isomorphic-git/index.js
function compareStrings(a2, b2) {
  return -(a2 < b2) || +(a2 > b2);
}
function comparePath(a2, b2) {
  return compareStrings(a2.path, b2.path);
}
function normalizeMode(mode) {
  let type = mode > 0 ? mode >> 12 : 0;
  if (type !== 4 && type !== 8 && type !== 10 && type !== 14) {
    type = 8;
  }
  let permissions = mode & 511;
  if (permissions & 73) {
    permissions = 493;
  } else {
    permissions = 420;
  }
  if (type !== 8)
    permissions = 0;
  return (type << 12) + permissions;
}
function SecondsNanoseconds(givenSeconds, givenNanoseconds, milliseconds, date) {
  if (givenSeconds !== void 0 && givenNanoseconds !== void 0) {
    return [givenSeconds, givenNanoseconds];
  }
  if (milliseconds === void 0) {
    milliseconds = date.valueOf();
  }
  const seconds = Math.floor(milliseconds / 1e3);
  const nanoseconds = (milliseconds - seconds * 1e3) * 1e6;
  return [seconds, nanoseconds];
}
function normalizeStats(e6) {
  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
    e6.ctimeSeconds,
    e6.ctimeNanoseconds,
    e6.ctimeMs,
    e6.ctime
  );
  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
    e6.mtimeSeconds,
    e6.mtimeNanoseconds,
    e6.mtimeMs,
    e6.mtime
  );
  return {
    ctimeSeconds: ctimeSeconds % MAX_UINT32,
    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
    mtimeSeconds: mtimeSeconds % MAX_UINT32,
    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
    dev: e6.dev % MAX_UINT32,
    ino: e6.ino % MAX_UINT32,
    mode: normalizeMode(e6.mode % MAX_UINT32),
    uid: e6.uid % MAX_UINT32,
    gid: e6.gid % MAX_UINT32,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e6.size > -1 ? e6.size % MAX_UINT32 : 0
  };
}
function toHex(buffer) {
  let hex = "";
  for (const byte of new Uint8Array(buffer)) {
    if (byte < 16)
      hex += "0";
    hex += byte.toString(16);
  }
  return hex;
}
async function shasum(buffer) {
  if (supportsSubtleSHA1 === null) {
    supportsSubtleSHA1 = await testSubtleSHA1();
  }
  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer);
}
function shasumSync(buffer) {
  return new import_sha1.default().update(buffer).digest("hex");
}
async function subtleSHA1(buffer) {
  const hash2 = await crypto.subtle.digest("SHA-1", buffer);
  return toHex(hash2);
}
async function testSubtleSHA1() {
  try {
    const hash2 = await subtleSHA1(new Uint8Array([]));
    if (hash2 === "da39a3ee5e6b4b0d3255bfef95601890afd80709")
      return true;
  } catch (_2) {
  }
  return false;
}
function parseCacheEntryFlags(bits) {
  return {
    assumeValid: Boolean(bits & 32768),
    extended: Boolean(bits & 16384),
    stage: (bits & 12288) >> 12,
    nameLength: bits & 4095
  };
}
function renderCacheEntryFlags(entry) {
  const flags = entry.flags;
  flags.extended = false;
  flags.nameLength = Math.min(Buffer.from(entry.path).length, 4095);
  return (flags.assumeValid ? 32768 : 0) + (flags.extended ? 16384 : 0) + ((flags.stage & 3) << 12) + (flags.nameLength & 4095);
}
function compareStats(entry, stats) {
  const e6 = normalizeStats(entry);
  const s2 = normalizeStats(stats);
  const staleness = e6.mode !== s2.mode || e6.mtimeSeconds !== s2.mtimeSeconds || e6.ctimeSeconds !== s2.ctimeSeconds || e6.uid !== s2.uid || e6.gid !== s2.gid || e6.ino !== s2.ino || e6.size !== s2.size;
  return staleness;
}
function createCache() {
  return {
    map: /* @__PURE__ */ new Map(),
    stats: /* @__PURE__ */ new Map()
  };
}
async function updateCachedIndexFile(fs, filepath, cache) {
  const stat = await fs.lstat(filepath);
  const rawIndexFile = await fs.read(filepath);
  const index2 = await GitIndex.from(rawIndexFile);
  cache.map.set(filepath, index2);
  cache.stats.set(filepath, stat);
}
async function isIndexStale(fs, filepath, cache) {
  const savedStats = cache.stats.get(filepath);
  if (savedStats === void 0)
    return true;
  const currStats = await fs.lstat(filepath);
  if (savedStats === null)
    return false;
  if (currStats === null)
    return false;
  return compareStats(savedStats, currStats);
}
function basename(path) {
  const last = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last > -1) {
    path = path.slice(last + 1);
  }
  return path;
}
function dirname(path) {
  const last = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last === -1)
    return ".";
  if (last === 0)
    return "/";
  return path.slice(0, last);
}
function flatFileListToDirectoryStructure(files) {
  const inodes = /* @__PURE__ */ new Map();
  const mkdir = function(name) {
    if (!inodes.has(name)) {
      const dir = {
        type: "tree",
        fullpath: name,
        basename: basename(name),
        metadata: {},
        children: []
      };
      inodes.set(name, dir);
      dir.parent = mkdir(dirname(name));
      if (dir.parent && dir.parent !== dir)
        dir.parent.children.push(dir);
    }
    return inodes.get(name);
  };
  const mkfile = function(name, metadata) {
    if (!inodes.has(name)) {
      const file = {
        type: "blob",
        fullpath: name,
        basename: basename(name),
        metadata,
        // This recursively generates any missing parent folders.
        parent: mkdir(dirname(name)),
        children: []
      };
      if (file.parent)
        file.parent.children.push(file);
      inodes.set(name, file);
    }
    return inodes.get(name);
  };
  mkdir(".");
  for (const file of files) {
    mkfile(file.path, file);
  }
  return inodes;
}
function mode2type(mode) {
  switch (mode) {
    case 16384:
      return "tree";
    case 33188:
      return "blob";
    case 33261:
      return "blob";
    case 40960:
      return "blob";
    case 57344:
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`);
}
function STAGE() {
  const o5 = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o5, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerIndex({ fs, gitdir, cache });
    }
  });
  Object.freeze(o5);
  return o5;
}
function compareRefNames(a2, b2) {
  const _a = a2.replace(/\^\{\}$/, "");
  const _b = b2.replace(/\^\{\}$/, "");
  const tmp = -(_a < _b) || +(_a > _b);
  if (tmp === 0) {
    return a2.endsWith("^{}") ? 1 : -1;
  }
  return tmp;
}
function normalizePath2(path) {
  let normalizedPath = memo.get(path);
  if (!normalizedPath) {
    normalizedPath = normalizePathInternal(path);
    memo.set(path, normalizedPath);
  }
  return normalizedPath;
}
function normalizePathInternal(path) {
  path = path.split("/./").join("/").replace(/\/{2,}/g, "/");
  if (path === "/.")
    return "/";
  if (path === "./")
    return ".";
  if (path.startsWith("./"))
    path = path.slice(2);
  if (path.endsWith("/."))
    path = path.slice(0, -2);
  if (path.length > 1 && path.endsWith("/"))
    path = path.slice(0, -1);
  if (path === "")
    return ".";
  return path;
}
function join(...parts) {
  return normalizePath2(parts.map(normalizePath2).join("/"));
}
async function acquireLock(ref, callback) {
  if (lock$1 === void 0)
    lock$1 = new import_async_lock.default();
  return lock$1.acquire(ref, callback);
}
function compareTreeEntryPath(a2, b2) {
  return compareStrings(appendSlashIfDir(a2), appendSlashIfDir(b2));
}
function appendSlashIfDir(entry) {
  return entry.mode === "040000" ? entry.path + "/" : entry.path;
}
function mode2type$1(mode) {
  switch (mode) {
    case "040000":
      return "tree";
    case "100644":
      return "blob";
    case "100755":
      return "blob";
    case "120000":
      return "blob";
    case "160000":
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);
}
function parseBuffer(buffer) {
  const _entries = [];
  let cursor = 0;
  while (cursor < buffer.length) {
    const space = buffer.indexOf(32, cursor);
    if (space === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
      );
    }
    const nullchar = buffer.indexOf(0, cursor);
    if (nullchar === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
      );
    }
    let mode = buffer.slice(cursor, space).toString("utf8");
    if (mode === "40000")
      mode = "040000";
    const type = mode2type$1(mode);
    const path = buffer.slice(space + 1, nullchar).toString("utf8");
    if (path.includes("\\") || path.includes("/")) {
      throw new UnsafeFilepathError(path);
    }
    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString("hex");
    cursor = nullchar + 21;
    _entries.push({ mode, path, oid, type });
  }
  return _entries;
}
function limitModeToAllowed(mode) {
  if (typeof mode === "number") {
    mode = mode.toString(8);
  }
  if (mode.match(/^0?4.*/))
    return "040000";
  if (mode.match(/^1006.*/))
    return "100644";
  if (mode.match(/^1007.*/))
    return "100755";
  if (mode.match(/^120.*/))
    return "120000";
  if (mode.match(/^160.*/))
    return "160000";
  throw new InternalError(`Could not understand file mode: ${mode}`);
}
function nudgeIntoShape(entry) {
  if (!entry.oid && entry.sha) {
    entry.oid = entry.sha;
  }
  entry.mode = limitModeToAllowed(entry.mode);
  if (!entry.type) {
    entry.type = mode2type$1(entry.mode);
  }
  return entry;
}
async function readObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const file = await fs.read(`${gitdir}/${source}`);
  if (!file) {
    return null;
  }
  return { object: file, format: "deflated", source };
}
function applyDelta(delta, source) {
  const reader = new BufferCursor(delta);
  const sourceSize = readVarIntLE(reader);
  if (sourceSize !== source.byteLength) {
    throw new InternalError(
      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
    );
  }
  const targetSize = readVarIntLE(reader);
  let target;
  const firstOp = readOp(reader, source);
  if (firstOp.byteLength === targetSize) {
    target = firstOp;
  } else {
    target = Buffer.alloc(targetSize);
    const writer = new BufferCursor(target);
    writer.copy(firstOp);
    while (!reader.eof()) {
      writer.copy(readOp(reader, source));
    }
    const tell = writer.tell();
    if (targetSize !== tell) {
      throw new InternalError(
        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
      );
    }
  }
  return target;
}
function readVarIntLE(reader) {
  let result = 0;
  let shift3 = 0;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 127) << shift3;
    shift3 += 7;
  } while (byte & 128);
  return result;
}
function readCompactLE(reader, flags, size3) {
  let result = 0;
  let shift3 = 0;
  while (size3--) {
    if (flags & 1) {
      result |= reader.readUInt8() << shift3;
    }
    flags >>= 1;
    shift3 += 8;
  }
  return result;
}
function readOp(reader, source) {
  const byte = reader.readUInt8();
  const COPY = 128;
  const OFFS = 15;
  const SIZE = 112;
  if (byte & COPY) {
    const offset3 = readCompactLE(reader, byte & OFFS, 4);
    let size3 = readCompactLE(reader, (byte & SIZE) >> 4, 3);
    if (size3 === 0)
      size3 = 65536;
    return source.slice(offset3, offset3 + size3);
  } else {
    return reader.slice(byte);
  }
}
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue(iterable);
}
function lengthBuffers(buffers) {
  return buffers.reduce((acc, buffer) => acc + buffer.length, 0);
}
async function listpack(stream, onData) {
  const reader = new StreamReader(stream);
  let PACK = await reader.read(4);
  PACK = PACK.toString("utf8");
  if (PACK !== "PACK") {
    throw new InternalError(`Invalid PACK header '${PACK}'`);
  }
  let version3 = await reader.read(4);
  version3 = version3.readUInt32BE(0);
  if (version3 !== 2) {
    throw new InternalError(`Invalid packfile version: ${version3}`);
  }
  let numObjects = await reader.read(4);
  numObjects = numObjects.readUInt32BE(0);
  if (numObjects < 1)
    return;
  while (!reader.eof() && numObjects--) {
    const offset3 = reader.tell();
    const { type, length, ofs, reference } = await parseHeader(reader);
    const inflator = new import_pako.default.Inflate();
    while (!inflator.result) {
      const chunk = await reader.chunk();
      if (!chunk)
        break;
      inflator.push(chunk, false);
      if (inflator.err) {
        throw new InternalError(`Pako error: ${inflator.msg}`);
      }
      if (inflator.result) {
        if (inflator.result.length !== length) {
          throw new InternalError(
            `Inflated object size is different from that stated in packfile.`
          );
        }
        await reader.undo();
        await reader.read(chunk.length - inflator.strm.avail_in);
        const end = reader.tell();
        await onData({
          data: inflator.result,
          type,
          num: numObjects,
          offset: offset3,
          end,
          reference,
          ofs
        });
      }
    }
  }
}
async function parseHeader(reader) {
  let byte = await reader.byte();
  const type = byte >> 4 & 7;
  let length = byte & 15;
  if (byte & 128) {
    let shift3 = 4;
    do {
      byte = await reader.byte();
      length |= (byte & 127) << shift3;
      shift3 += 7;
    } while (byte & 128);
  }
  let ofs;
  let reference;
  if (type === 6) {
    let shift3 = 0;
    ofs = 0;
    const bytes = [];
    do {
      byte = await reader.byte();
      ofs |= (byte & 127) << shift3;
      shift3 += 7;
      bytes.push(byte);
    } while (byte & 128);
    reference = Buffer.from(bytes);
  }
  if (type === 7) {
    const buf = await reader.read(20);
    reference = buf;
  }
  return { type, length, ofs, reference };
}
async function inflate(buffer) {
  if (supportsDecompressionStream === null) {
    supportsDecompressionStream = testDecompressionStream();
  }
  return supportsDecompressionStream ? browserInflate(buffer) : import_pako.default.inflate(buffer);
}
async function browserInflate(buffer) {
  const ds = new DecompressionStream("deflate");
  const d2 = new Blob([buffer]).stream().pipeThrough(ds);
  return new Uint8Array(await new Response(d2).arrayBuffer());
}
function testDecompressionStream() {
  try {
    const ds = new DecompressionStream("deflate");
    if (ds)
      return true;
  } catch (_2) {
  }
  return false;
}
function decodeVarInt(reader) {
  const bytes = [];
  let byte = 0;
  let multibyte = 0;
  do {
    byte = reader.readUInt8();
    const lastSeven = byte & 127;
    bytes.push(lastSeven);
    multibyte = byte & 128;
  } while (multibyte);
  return bytes.reduce((a2, b2) => a2 + 1 << 7 | b2, -1);
}
function otherVarIntDecode(reader, startWith) {
  let result = startWith;
  let shift3 = 4;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 127) << shift3;
    shift3 += 7;
  } while (byte & 128);
  return result;
}
async function loadPackIndex({
  fs,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix
}) {
  const idx = await fs.read(filename);
  return GitPackIndex.fromIdx({ idx, getExternalRefDelta });
}
function readPackIndex({
  fs,
  cache,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix
}) {
  if (!cache[PackfileCache])
    cache[PackfileCache] = /* @__PURE__ */ new Map();
  let p2 = cache[PackfileCache].get(filename);
  if (!p2) {
    p2 = loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    });
    cache[PackfileCache].set(filename, p2);
  }
  return p2;
}
async function readObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  format = "content",
  getExternalRefDelta
}) {
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x2) => x2.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p2 = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p2.error)
      throw new InternalError(p2.error);
    if (p2.offsets.has(oid)) {
      if (!p2.pack) {
        const packFile = indexFile.replace(/idx$/, "pack");
        p2.pack = fs.read(packFile);
      }
      const result = await p2.read({ oid, getExternalRefDelta });
      result.format = "content";
      result.source = `objects/pack/${filename.replace(/idx$/, "pack")}`;
      return result;
    }
  }
  return null;
}
async function _readObject({
  fs,
  cache,
  gitdir,
  oid,
  format = "content"
}) {
  const getExternalRefDelta = (oid2) => _readObject({ fs, cache, gitdir, oid: oid2 });
  let result;
  if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
    result = { format: "wrapped", object: Buffer.from(`tree 0\0`) };
  }
  if (!result) {
    result = await readObjectLoose({ fs, gitdir, oid });
  }
  if (!result) {
    result = await readObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta
    });
  }
  if (!result) {
    throw new NotFoundError(oid);
  }
  if (format === "deflated") {
    return result;
  }
  if (result.format === "deflated") {
    result.object = Buffer.from(await inflate(result.object));
    result.format = "wrapped";
  }
  if (result.format === "wrapped") {
    if (format === "wrapped" && result.format === "wrapped") {
      return result;
    }
    const sha = await shasum(result.object);
    if (sha !== oid) {
      throw new InternalError(
        `SHA check failed! Expected ${oid}, computed ${sha}`
      );
    }
    const { object, type } = GitObject.unwrap(result.object);
    result.type = type;
    result.object = object;
    result.format = "content";
  }
  if (result.format === "content") {
    if (format === "content")
      return result;
    return;
  }
  throw new InternalError(`invalid format "${result.format}"`);
}
function formatAuthor({ name, email, timestamp, timezoneOffset }) {
  timezoneOffset = formatTimezoneOffset(timezoneOffset);
  return `${name} <${email}> ${timestamp} ${timezoneOffset}`;
}
function formatTimezoneOffset(minutes) {
  const sign3 = simpleSign(negateExceptForZero(minutes));
  minutes = Math.abs(minutes);
  const hours = Math.floor(minutes / 60);
  minutes -= hours * 60;
  let strHours = String(hours);
  let strMinutes = String(minutes);
  if (strHours.length < 2)
    strHours = "0" + strHours;
  if (strMinutes.length < 2)
    strMinutes = "0" + strMinutes;
  return (sign3 === -1 ? "-" : "+") + strHours + strMinutes;
}
function simpleSign(n5) {
  return Math.sign(n5) || (Object.is(n5, -0) ? -1 : 1);
}
function negateExceptForZero(n5) {
  return n5 === 0 ? n5 : -n5;
}
function normalizeNewlines(str) {
  str = str.replace(/\r/g, "");
  str = str.replace(/^\n+/, "");
  str = str.replace(/\n+$/, "") + "\n";
  return str;
}
function parseAuthor(author) {
  const [, name, email, timestamp, offset3] = author.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name,
    email,
    timestamp: Number(timestamp),
    timezoneOffset: parseTimezoneOffset(offset3)
  };
}
function parseTimezoneOffset(offset3) {
  let [, sign3, hours, minutes] = offset3.match(/(\+|-)(\d\d)(\d\d)/);
  minutes = (sign3 === "+" ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
  return negateExceptForZero$1(minutes);
}
function negateExceptForZero$1(n5) {
  return n5 === 0 ? n5 : -n5;
}
function indent(str) {
  return str.trim().split("\n").map((x2) => " " + x2).join("\n") + "\n";
}
function outdent(str) {
  return str.split("\n").map((x2) => x2.replace(/^ /, "")).join("\n");
}
async function resolveTree({ fs, cache, gitdir, oid }) {
  if (oid === "4b825dc642cb6eb9a060e54bf8d69288fbee4904") {
    return { tree: GitTree.from([]), oid };
  }
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveTree({ fs, cache, gitdir, oid });
  }
  if (type === "commit") {
    oid = GitCommit.from(object).parse().tree;
    return resolveTree({ fs, cache, gitdir, oid });
  }
  if (type !== "tree") {
    throw new ObjectTypeError(oid, type, "tree");
  }
  return { tree: GitTree.from(object), oid };
}
function TREE({ ref = "HEAD" } = {}) {
  const o5 = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o5, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerRepo({ fs, gitdir, ref, cache });
    }
  });
  Object.freeze(o5);
  return o5;
}
function WORKDIR() {
  const o5 = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(o5, GitWalkSymbol, {
    value: function({ fs, dir, gitdir, cache }) {
      return new GitWalkerFs({ fs, dir, gitdir, cache });
    }
  });
  Object.freeze(o5);
  return o5;
}
function arrayRange(start, end) {
  const length = end - start;
  return Array.from({ length }, (_2, i4) => start + i4);
}
function* unionOfIterators(sets) {
  const min6 = new RunningMinimum();
  let minimum;
  const heads = [];
  const numsets = sets.length;
  for (let i4 = 0; i4 < numsets; i4++) {
    heads[i4] = sets[i4].next().value;
    if (heads[i4] !== void 0) {
      min6.consider(heads[i4]);
    }
  }
  if (min6.value === null)
    return;
  while (true) {
    const result = [];
    minimum = min6.value;
    min6.reset();
    for (let i4 = 0; i4 < numsets; i4++) {
      if (heads[i4] !== void 0 && heads[i4] === minimum) {
        result[i4] = heads[i4];
        heads[i4] = sets[i4].next().value;
      } else {
        result[i4] = null;
      }
      if (heads[i4] !== void 0) {
        min6.consider(heads[i4]);
      }
    }
    yield result;
    if (min6.value === null)
      return;
  }
}
async function _walk({
  fs,
  cache,
  dir,
  gitdir,
  trees,
  // @ts-ignore
  map = async (_2, entry) => entry,
  // The default reducer is a flatmap that filters out undefineds.
  reduce = async (parent, children) => {
    const flatten = flat(children);
    if (parent !== void 0)
      flatten.unshift(parent);
    return flatten;
  },
  // The default iterate function walks all children concurrently
  iterate = (walk3, children) => Promise.all([...children].map(walk3))
}) {
  const walkers = trees.map(
    (proxy) => proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })
  );
  const root = new Array(walkers.length).fill(".");
  const range = arrayRange(0, walkers.length);
  const unionWalkerFromReaddir = async (entries) => {
    range.map((i4) => {
      entries[i4] = entries[i4] && new walkers[i4].ConstructEntry(entries[i4]);
    });
    const subdirs = await Promise.all(
      range.map((i4) => entries[i4] ? walkers[i4].readdir(entries[i4]) : [])
    );
    const iterators = subdirs.map((array) => array === null ? [] : array).map((array) => array[Symbol.iterator]());
    return {
      entries,
      children: unionOfIterators(iterators)
    };
  };
  const walk3 = async (root2) => {
    const { entries, children } = await unionWalkerFromReaddir(root2);
    const fullpath = entries.find((entry) => entry && entry._fullpath)._fullpath;
    const parent = await map(fullpath, entries);
    if (parent !== null) {
      let walkedChildren = await iterate(walk3, children);
      walkedChildren = walkedChildren.filter((x2) => x2 !== void 0);
      return reduce(parent, walkedChildren);
    }
  };
  return walk3(root);
}
async function rmRecursive(fs, filepath) {
  const entries = await fs.readdir(filepath);
  if (entries == null) {
    await fs.rm(filepath);
  } else if (entries.length) {
    await Promise.all(
      entries.map((entry) => {
        const subpath = join(filepath, entry);
        return fs.lstat(subpath).then((stat) => {
          if (!stat)
            return;
          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath);
        });
      })
    ).then(() => fs.rmdir(filepath));
  } else {
    await fs.rmdir(filepath);
  }
}
function isPromiseLike(obj) {
  return isObject(obj) && isFunction(obj.then) && isFunction(obj.catch);
}
function isObject(obj) {
  return obj && typeof obj === "object";
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isPromiseFs(fs) {
  const test = (targetFs) => {
    try {
      return targetFs.readFile().catch((e6) => e6);
    } catch (e6) {
      return e6;
    }
  };
  return isPromiseLike(test(fs));
}
function bindFs(target, fs) {
  if (isPromiseFs(fs)) {
    for (const command of commands) {
      target[`_${command}`] = fs[command].bind(fs);
    }
  } else {
    for (const command of commands) {
      target[`_${command}`] = (0, import_pify.default)(fs[command].bind(fs));
    }
  }
  if (isPromiseFs(fs)) {
    if (fs.rm)
      target._rm = fs.rm.bind(fs);
    else if (fs.rmdir.length > 1)
      target._rm = fs.rmdir.bind(fs);
    else
      target._rm = rmRecursive.bind(null, target);
  } else {
    if (fs.rm)
      target._rm = (0, import_pify.default)(fs.rm.bind(fs));
    else if (fs.rmdir.length > 2)
      target._rm = (0, import_pify.default)(fs.rmdir.bind(fs));
    else
      target._rm = rmRecursive.bind(null, target);
  }
}
function assertParameter(name, value) {
  if (value === void 0) {
    throw new MissingParameterError(name);
  }
}
async function modified(entry, base) {
  if (!entry && !base)
    return false;
  if (entry && !base)
    return true;
  if (!entry && base)
    return true;
  if (await entry.type() === "tree" && await base.type() === "tree") {
    return false;
  }
  if (await entry.type() === await base.type() && await entry.mode() === await base.mode() && await entry.oid() === await base.oid()) {
    return false;
  }
  return true;
}
async function abortMerge({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  commit: commit3 = "HEAD",
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const trees = [TREE({ ref: commit3 }), WORKDIR(), STAGE()];
    let unmergedPaths = [];
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      unmergedPaths = index2.unmergedPaths;
    });
    const results = await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees,
      map: async function(path, [head, workdir, index2]) {
        const staged = !await modified(workdir, index2);
        const unmerged = unmergedPaths.includes(path);
        const unmodified = !await modified(index2, head);
        if (staged || unmerged) {
          return head ? {
            path,
            mode: await head.mode(),
            oid: await head.oid(),
            type: await head.type(),
            content: await head.content()
          } : void 0;
        }
        if (unmodified)
          return false;
        else
          throw new IndexResetError(path);
      }
    });
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      for (const entry of results) {
        if (entry === false)
          continue;
        if (!entry) {
          await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });
          index2.delete({ filepath: entry.path });
          continue;
        }
        if (entry.type === "blob") {
          const content = new TextDecoder().decode(entry.content);
          await fs.write(`${dir}/${entry.path}`, content, { mode: entry.mode });
          index2.insert({
            filepath: entry.path,
            oid: entry.oid,
            stage: 0
          });
        }
      }
    });
  } catch (err) {
    err.caller = "git.abortMerge";
    throw err;
  }
}
async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
  if (format !== "deflated") {
    throw new InternalError(
      "GitObjectStoreLoose expects objects to write to be in deflated format"
    );
  }
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const filepath = `${gitdir}/${source}`;
  if (!await fs.exists(filepath))
    await fs.write(filepath, object);
}
async function deflate(buffer) {
  if (supportsCompressionStream === null) {
    supportsCompressionStream = testCompressionStream();
  }
  return supportsCompressionStream ? browserDeflate(buffer) : import_pako.default.deflate(buffer);
}
async function browserDeflate(buffer) {
  const cs = new CompressionStream("deflate");
  const c4 = new Blob([buffer]).stream().pipeThrough(cs);
  return new Uint8Array(await new Response(c4).arrayBuffer());
}
function testCompressionStream() {
  try {
    const cs = new CompressionStream("deflate");
    cs.writable.close();
    const stream = new Blob([]).stream();
    stream.cancel();
    return true;
  } catch (_2) {
    return false;
  }
}
async function _writeObject({
  fs,
  gitdir,
  type,
  object,
  format = "content",
  oid = void 0,
  dryRun = false
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
    object = Buffer.from(await deflate(object));
  }
  if (!dryRun) {
    await writeObjectLoose({ fs, gitdir, object, format: "deflated", oid });
  }
  return oid;
}
function posixifyPathBuffer(buffer) {
  let idx;
  while (~(idx = buffer.indexOf(92)))
    buffer[idx] = 47;
  return buffer;
}
async function add({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {},
  force = false,
  parallel = true
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    await GitIndexManager.acquire({ fs, gitdir, cache }, async (index2) => {
      return addToIndex({
        dir,
        gitdir,
        fs,
        filepath,
        index: index2,
        force,
        parallel
      });
    });
  } catch (err) {
    err.caller = "git.add";
    throw err;
  }
}
async function addToIndex({
  dir,
  gitdir,
  fs,
  filepath,
  index: index2,
  force,
  parallel
}) {
  filepath = Array.isArray(filepath) ? filepath : [filepath];
  const promises = filepath.map(async (currentFilepath) => {
    if (!force) {
      const ignored = await GitIgnoreManager.isIgnored({
        fs,
        dir,
        gitdir,
        filepath: currentFilepath
      });
      if (ignored)
        return;
    }
    const stats = await fs.lstat(join(dir, currentFilepath));
    if (!stats)
      throw new NotFoundError(currentFilepath);
    if (stats.isDirectory()) {
      const children = await fs.readdir(join(dir, currentFilepath));
      if (parallel) {
        const promises2 = children.map(
          (child) => addToIndex({
            dir,
            gitdir,
            fs,
            filepath: [join(currentFilepath, child)],
            index: index2,
            force,
            parallel
          })
        );
        await Promise.all(promises2);
      } else {
        for (const child of children) {
          await addToIndex({
            dir,
            gitdir,
            fs,
            filepath: [join(currentFilepath, child)],
            index: index2,
            force,
            parallel
          });
        }
      }
    } else {
      const object = stats.isSymbolicLink() ? await fs.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer) : await fs.read(join(dir, currentFilepath));
      if (object === null)
        throw new NotFoundError(currentFilepath);
      const oid = await _writeObject({ fs, gitdir, type: "blob", object });
      index2.insert({ filepath: currentFilepath, stats, oid });
    }
  });
  const settledPromises = await Promise.allSettled(promises);
  const rejectedPromises = settledPromises.filter((settle) => settle.status === "rejected").map((settle) => settle.reason);
  if (rejectedPromises.length > 1) {
    throw new MultipleGitError(rejectedPromises);
  }
  if (rejectedPromises.length === 1) {
    throw rejectedPromises[0];
  }
  const fulfilledPromises = settledPromises.filter((settle) => settle.status === "fulfilled" && settle.value).map((settle) => settle.value);
  return fulfilledPromises;
}
async function _commit({
  fs,
  cache,
  onSign,
  gitdir,
  message,
  author,
  committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree
}) {
  if (!ref) {
    ref = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: "HEAD",
      depth: 2
    });
  }
  return GitIndexManager.acquire(
    { fs, gitdir, cache, allowUnmerged: false },
    async function(index2) {
      const inodes = flatFileListToDirectoryStructure(index2.entries);
      const inode = inodes.get(".");
      if (!tree) {
        tree = await constructTree({ fs, gitdir, inode, dryRun });
      }
      if (!parent) {
        try {
          parent = [
            await GitRefManager.resolve({
              fs,
              gitdir,
              ref
            })
          ];
        } catch (err) {
          parent = [];
        }
      } else {
        parent = await Promise.all(
          parent.map((p2) => {
            return GitRefManager.resolve({ fs, gitdir, ref: p2 });
          })
        );
      }
      let comm = GitCommit.from({
        tree,
        parent,
        author,
        committer,
        message
      });
      if (signingKey) {
        comm = await GitCommit.sign(comm, onSign, signingKey);
      }
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "commit",
        object: comm.toObject(),
        dryRun
      });
      if (!noUpdateBranch && !dryRun) {
        await GitRefManager.writeRef({
          fs,
          gitdir,
          ref,
          value: oid
        });
      }
      return oid;
    }
  );
}
async function constructTree({ fs, gitdir, inode, dryRun }) {
  const children = inode.children;
  for (const inode2 of children) {
    if (inode2.type === "tree") {
      inode2.metadata.mode = "040000";
      inode2.metadata.oid = await constructTree({ fs, gitdir, inode: inode2, dryRun });
    }
  }
  const entries = children.map((inode2) => ({
    mode: inode2.metadata.mode,
    path: inode2.basename,
    oid: inode2.metadata.oid,
    type: inode2.type
  }));
  const tree = GitTree.from(entries);
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object: tree.toObject(),
    dryRun
  });
  return oid;
}
async function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {
  if (filepath.startsWith("/")) {
    throw new InvalidFilepathError("leading-slash");
  } else if (filepath.endsWith("/")) {
    throw new InvalidFilepathError("trailing-slash");
  }
  const _oid = oid;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (filepath === "") {
    oid = result.oid;
  } else {
    const pathArray = filepath.split("/");
    oid = await _resolveFilepath({
      fs,
      cache,
      gitdir,
      tree,
      pathArray,
      oid: _oid,
      filepath
    });
  }
  return oid;
}
async function _resolveFilepath({
  fs,
  cache,
  gitdir,
  tree,
  pathArray,
  oid,
  filepath
}) {
  const name = pathArray.shift();
  for (const entry of tree) {
    if (entry.path === name) {
      if (pathArray.length === 0) {
        return entry.oid;
      } else {
        const { type, object } = await _readObject({
          fs,
          cache,
          gitdir,
          oid: entry.oid
        });
        if (type !== "tree") {
          throw new ObjectTypeError(oid, type, "tree", filepath);
        }
        tree = GitTree.from(object);
        return _resolveFilepath({
          fs,
          cache,
          gitdir,
          tree,
          pathArray,
          oid,
          filepath
        });
      }
    }
  }
  throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`);
}
async function _readTree({
  fs,
  cache,
  gitdir,
  oid,
  filepath = void 0
}) {
  if (filepath !== void 0) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });
  const result = {
    oid: treeOid,
    tree: tree.entries()
  };
  return result;
}
async function _writeTree({ fs, gitdir, tree }) {
  const object = GitTree.from(tree).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object,
    format: "content"
  });
  return oid;
}
async function _addNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  oid,
  note,
  force,
  author,
  committer,
  signingKey
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err;
    }
  }
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
  });
  let tree = result.tree;
  if (force) {
    tree = tree.filter((entry) => entry.path !== oid);
  } else {
    for (const entry of tree) {
      if (entry.path === oid) {
        throw new AlreadyExistsError("note", oid);
      }
    }
  }
  if (typeof note === "string") {
    note = Buffer.from(note, "utf8");
  }
  const noteOid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: note,
    format: "content"
  });
  tree.push({ mode: "100644", path: oid, oid: noteOid, type: "blob" });
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree
  });
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note added by 'isomorphic-git addNote'
`,
    author,
    committer,
    signingKey
  });
  return commitOid;
}
async function _getConfig({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.get(path);
}
async function normalizeAuthorObject({ fs, gitdir, author = {} }) {
  let { name, email, timestamp, timezoneOffset } = author;
  name = name || await _getConfig({ fs, gitdir, path: "user.name" });
  email = email || await _getConfig({ fs, gitdir, path: "user.email" }) || "";
  if (name === void 0) {
    return void 0;
  }
  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1e3);
  timezoneOffset = timezoneOffset != null ? timezoneOffset : new Date(timestamp * 1e3).getTimezoneOffset();
  return { name, email, timestamp, timezoneOffset };
}
async function normalizeCommitterObject({
  fs,
  gitdir,
  author,
  committer
}) {
  committer = Object.assign({}, committer || author);
  if (author) {
    committer.timestamp = committer.timestamp || author.timestamp;
    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;
  }
  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });
  return committer;
}
async function addNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  note,
  force,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("note", note);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _addNote({
      fs: new FileSystem(fs),
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey
    });
  } catch (err) {
    err.caller = "git.addNote";
    throw err;
  }
}
async function _addRemote({ fs, gitdir, remote, url, force }) {
  if (remote !== import_clean_git_ref.default.clean(remote)) {
    throw new InvalidRefNameError(remote, import_clean_git_ref.default.clean(remote));
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  if (!force) {
    const remoteNames = await config.getSubsections("remote");
    if (remoteNames.includes(remote)) {
      if (url !== await config.get(`remote.${remote}.url`)) {
        throw new AlreadyExistsError("remote", remote);
      }
    }
  }
  await config.set(`remote.${remote}.url`, url);
  await config.set(
    `remote.${remote}.fetch`,
    `+refs/heads/*:refs/remotes/${remote}/*`
  );
  await GitConfigManager.save({ fs, gitdir, config });
}
async function addRemote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote,
  url,
  force = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("remote", remote);
    assertParameter("url", url);
    return await _addRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
      url,
      force
    });
  } catch (err) {
    err.caller = "git.addRemote";
    throw err;
  }
}
async function _annotatedTag({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false
}) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
    throw new AlreadyExistsError("tag", ref);
  }
  const oid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: object || "HEAD"
  });
  const { type } = await _readObject({ fs, cache, gitdir, oid });
  let tagObject = GitAnnotatedTag.from({
    object: oid,
    type,
    tag: ref.replace("refs/tags/", ""),
    tagger,
    message,
    gpgsig
  });
  if (signingKey) {
    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
  }
  const value = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object: tagObject.toObject()
  });
  await GitRefManager.writeRef({ fs, gitdir, ref, value });
}
async function annotatedTag({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  tagger: _tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
    if (!tagger)
      throw new MissingNameError("tagger");
    return await _annotatedTag({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message,
      gpgsig,
      object,
      signingKey,
      force
    });
  } catch (err) {
    err.caller = "git.annotatedTag";
    throw err;
  }
}
async function _branch({
  fs,
  gitdir,
  ref,
  object,
  checkout: checkout3 = false,
  force = false
}) {
  if (ref !== import_clean_git_ref.default.clean(ref)) {
    throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
  }
  const fullref = `refs/heads/${ref}`;
  if (!force) {
    const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
    if (exist) {
      throw new AlreadyExistsError("branch", ref, false);
    }
  }
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: object || "HEAD" });
  } catch (e6) {
  }
  if (oid) {
    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
  }
  if (checkout3) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullref
    });
  }
}
async function branch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  object,
  checkout: checkout3 = false,
  force = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _branch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      object,
      checkout: checkout3,
      force
    });
  } catch (err) {
    err.caller = "git.branch";
    throw err;
  }
}
async function _checkout({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  remote,
  ref,
  filepaths,
  noCheckout,
  noUpdateHead,
  dryRun,
  force,
  track = true
}) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
  } catch (err) {
    if (ref === "HEAD")
      throw err;
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef
    });
    if (track) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`branch.${ref}.remote`, remote);
      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid
    });
  }
  if (!noCheckout) {
    let ops;
    try {
      ops = await analyze({
        fs,
        cache,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths
      });
    } catch (err) {
      if (err instanceof NotFoundError && err.data.what === oid) {
        throw new CommitNotFetchedError(ref, oid);
      } else {
        throw err;
      }
    }
    const conflicts = ops.filter(([method]) => method === "conflict").map(([method, fullpath]) => fullpath);
    if (conflicts.length > 0) {
      throw new CheckoutConflictError(conflicts);
    }
    const errors = ops.filter(([method]) => method === "error").map(([method, fullpath]) => fullpath);
    if (errors.length > 0) {
      throw new InternalError(errors.join(", "));
    }
    if (dryRun) {
      return;
    }
    let count = 0;
    const total = ops.length;
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      await Promise.all(
        ops.filter(
          ([method]) => method === "delete" || method === "delete-index"
        ).map(async function([method, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          if (method === "delete") {
            await fs.rm(filepath);
          }
          index2.delete({ filepath: fullpath });
          if (onProgress) {
            await onProgress({
              phase: "Updating workdir",
              loaded: ++count,
              total
            });
          }
        })
      );
    });
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      for (const [method, fullpath] of ops) {
        if (method === "rmdir" || method === "rmdir-index") {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method === "rmdir-index") {
              index2.delete({ filepath: fullpath });
            }
            await fs.rmdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e6) {
            if (e6.code === "ENOTEMPTY") {
              console.log(
                `Did not delete ${fullpath} because directory is not empty`
              );
            } else {
              throw e6;
            }
          }
        }
      }
    });
    await Promise.all(
      ops.filter(([method]) => method === "mkdir" || method === "mkdir-index").map(async function([_2, fullpath]) {
        const filepath = `${dir}/${fullpath}`;
        await fs.mkdir(filepath);
        if (onProgress) {
          await onProgress({
            phase: "Updating workdir",
            loaded: ++count,
            total
          });
        }
      })
    );
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      await Promise.all(
        ops.filter(
          ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
        ).map(async function([method, fullpath, oid2, mode, chmod]) {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method !== "create-index" && method !== "mkdir-index") {
              const { object } = await _readObject({ fs, cache, gitdir, oid: oid2 });
              if (chmod) {
                await fs.rm(filepath);
              }
              if (mode === 33188) {
                await fs.write(filepath, object);
              } else if (mode === 33261) {
                await fs.write(filepath, object, { mode: 511 });
              } else if (mode === 40960) {
                await fs.writelink(filepath, object);
              } else {
                throw new InternalError(
                  `Invalid mode 0o${mode.toString(8)} detected in blob ${oid2}`
                );
              }
            }
            const stats = await fs.lstat(filepath);
            if (mode === 33261) {
              stats.mode = 493;
            }
            if (method === "mkdir-index") {
              stats.mode = 57344;
            }
            index2.insert({
              filepath: fullpath,
              stats,
              oid: oid2
            });
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e6) {
            console.log(e6);
          }
        })
      );
    });
  }
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith("refs/heads")) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: "HEAD",
        value: fullRef
      });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: oid });
    }
  }
}
async function analyze({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  ref,
  force,
  filepaths
}) {
  let count = 0;
  return _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [TREE({ ref }), WORKDIR(), STAGE()],
    map: async function(fullpath, [commit3, workdir, stage]) {
      if (fullpath === ".")
        return;
      if (filepaths && !filepaths.some((base) => worthWalking(fullpath, base))) {
        return null;
      }
      if (onProgress) {
        await onProgress({ phase: "Analyzing workdir", loaded: ++count });
      }
      const key = [!!stage, !!commit3, !!workdir].map(Number).join("");
      switch (key) {
        case "000":
          return;
        case "001":
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ["delete", fullpath];
          }
          return;
        case "010": {
          switch (await commit3.type()) {
            case "tree": {
              return ["mkdir", fullpath];
            }
            case "blob": {
              return [
                "create",
                fullpath,
                await commit3.oid(),
                await commit3.mode()
              ];
            }
            case "commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit3.oid(),
                await commit3.mode()
              ];
            }
            default: {
              return [
                "error",
                `new entry Unhandled type ${await commit3.type()}`
              ];
            }
          }
        }
        case "011": {
          switch (`${await commit3.type()}-${await workdir.type()}`) {
            case "tree-tree": {
              return;
            }
            case "tree-blob":
            case "blob-tree": {
              return ["conflict", fullpath];
            }
            case "blob-blob": {
              if (await commit3.oid() !== await workdir.oid()) {
                if (force) {
                  return [
                    "update",
                    fullpath,
                    await commit3.oid(),
                    await commit3.mode(),
                    await commit3.mode() !== await workdir.mode()
                  ];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                if (await commit3.mode() !== await workdir.mode()) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit3.oid(),
                      await commit3.mode(),
                      true
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                } else {
                  return [
                    "create-index",
                    fullpath,
                    await commit3.oid(),
                    await commit3.mode()
                  ];
                }
              }
            }
            case "commit-tree": {
              return;
            }
            case "commit-blob": {
              return ["conflict", fullpath];
            }
            default: {
              return ["error", `new entry Unhandled type ${commit3.type}`];
            }
          }
        }
        case "100": {
          return ["delete-index", fullpath];
        }
        case "101": {
          switch (await stage.type()) {
            case "tree": {
              return ["rmdir", fullpath];
            }
            case "blob": {
              if (await stage.oid() !== await workdir.oid()) {
                if (force) {
                  return ["delete", fullpath];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                return ["delete", fullpath];
              }
            }
            case "commit": {
              return ["rmdir-index", fullpath];
            }
            default: {
              return [
                "error",
                `delete entry Unhandled type ${await stage.type()}`
              ];
            }
          }
        }
        case "110":
        case "111": {
          switch (`${await stage.type()}-${await commit3.type()}`) {
            case "tree-tree": {
              return;
            }
            case "blob-blob": {
              if (await stage.oid() === await commit3.oid() && await stage.mode() === await commit3.mode() && !force) {
                return;
              }
              if (workdir) {
                if (await workdir.oid() !== await stage.oid() && await workdir.oid() !== await commit3.oid()) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit3.oid(),
                      await commit3.mode(),
                      await commit3.mode() !== await workdir.mode()
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                }
              } else if (force) {
                return [
                  "update",
                  fullpath,
                  await commit3.oid(),
                  await commit3.mode(),
                  await commit3.mode() !== await stage.mode()
                ];
              }
              if (await commit3.mode() !== await stage.mode()) {
                return [
                  "update",
                  fullpath,
                  await commit3.oid(),
                  await commit3.mode(),
                  true
                ];
              }
              if (await commit3.oid() !== await stage.oid()) {
                return [
                  "update",
                  fullpath,
                  await commit3.oid(),
                  await commit3.mode(),
                  false
                ];
              } else {
                return;
              }
            }
            case "tree-blob": {
              return ["update-dir-to-blob", fullpath, await commit3.oid()];
            }
            case "blob-tree": {
              return ["update-blob-to-tree", fullpath];
            }
            case "commit-commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit3.oid(),
                await commit3.mode()
              ];
            }
            default: {
              return [
                "error",
                `update entry Unhandled type ${await stage.type()}-${await commit3.type()}`
              ];
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function(parent, children) {
      children = flat(children);
      if (!parent) {
        return children;
      } else if (parent && parent[0] === "rmdir") {
        children.push(parent);
        return children;
      } else {
        children.unshift(parent);
        return children;
      }
    }
  });
}
async function checkout({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, ".git"),
  remote = "origin",
  ref: _ref,
  filepaths,
  noCheckout = false,
  noUpdateHead = _ref === void 0,
  dryRun = false,
  force = false,
  track = true,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const ref = _ref || "HEAD";
    return await _checkout({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track
    });
  } catch (err) {
    err.caller = "git.checkout";
    throw err;
  }
}
function abbreviateRef(ref) {
  const match = abbreviateRx.exec(ref);
  if (match) {
    if (match[1] === "remotes/" && ref.endsWith("/HEAD")) {
      return match[2].slice(0, -5);
    } else {
      return match[2];
    }
  }
  return ref;
}
async function _currentBranch({
  fs,
  gitdir,
  fullname = false,
  test = false
}) {
  const ref = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: "HEAD",
    depth: 2
  });
  if (test) {
    try {
      await GitRefManager.resolve({ fs, gitdir, ref });
    } catch (_2) {
      return;
    }
  }
  if (!ref.startsWith("refs/"))
    return;
  return fullname ? ref : abbreviateRef(ref);
}
function translateSSHtoHTTP(url) {
  url = url.replace(/^git@([^:]+):/, "https://$1/");
  url = url.replace(/^ssh:\/\//, "https://");
  return url;
}
function calculateBasicAuthHeader({ username = "", password = "" }) {
  return `Basic ${Buffer.from(`${username}:${password}`).toString("base64")}`;
}
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value)
      await cb(value);
    if (done)
      break;
  }
  if (iter.return)
    iter.return();
}
async function collect(iterable) {
  let size3 = 0;
  const buffers = [];
  await forAwait(iterable, (value) => {
    buffers.push(value);
    size3 += value.byteLength;
  });
  const result = new Uint8Array(size3);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}
function extractAuthFromUrl(url) {
  let userpass = url.match(/^https?:\/\/([^/]+)@/);
  if (userpass == null)
    return { url, auth: {} };
  userpass = userpass[1];
  const [username, password] = userpass.split(":");
  url = url.replace(`${userpass}@`, "");
  return { url, auth: { username, password } };
}
function padHex(b2, n5) {
  const s2 = n5.toString(16);
  return "0".repeat(b2 - s2.length) + s2;
}
async function parseCapabilitiesV2(read) {
  const capabilities2 = {};
  let line;
  while (true) {
    line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    line = line.toString("utf8").replace(/\n$/, "");
    const i4 = line.indexOf("=");
    if (i4 > -1) {
      const key = line.slice(0, i4);
      const value = line.slice(i4 + 1);
      capabilities2[key] = value;
    } else {
      capabilities2[line] = true;
    }
  }
  return { protocolVersion: 2, capabilities2 };
}
async function parseRefsAdResponse(stream, { service }) {
  const capabilities = /* @__PURE__ */ new Set();
  const refs = /* @__PURE__ */ new Map();
  const symrefs = /* @__PURE__ */ new Map();
  const read = GitPktLine.streamReader(stream);
  let lineOne = await read();
  while (lineOne === null)
    lineOne = await read();
  if (lineOne === true)
    throw new EmptyServerResponseError();
  if (lineOne.includes("version 2")) {
    return parseCapabilitiesV2(read);
  }
  if (lineOne.toString("utf8").replace(/\n$/, "") !== `# service=${service}`) {
    throw new ParseError(`# service=${service}\\n`, lineOne.toString("utf8"));
  }
  let lineTwo = await read();
  while (lineTwo === null)
    lineTwo = await read();
  if (lineTwo === true)
    return { capabilities, refs, symrefs };
  lineTwo = lineTwo.toString("utf8");
  if (lineTwo.includes("version 2")) {
    return parseCapabilitiesV2(read);
  }
  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, "\0", "\\x00");
  capabilitiesLine.split(" ").map((x2) => capabilities.add(x2));
  const [ref, name] = splitAndAssert(firstRef, " ", " ");
  refs.set(name, ref);
  while (true) {
    const line = await read();
    if (line === true)
      break;
    if (line !== null) {
      const [ref2, name2] = splitAndAssert(line.toString("utf8"), " ", " ");
      refs.set(name2, ref2);
    }
  }
  for (const cap of capabilities) {
    if (cap.startsWith("symref=")) {
      const m2 = cap.match(/symref=([^:]+):(.*)/);
      if (m2.length === 3) {
        symrefs.set(m2[1], m2[2]);
      }
    }
  }
  return { protocolVersion: 1, capabilities, refs, symrefs };
}
function splitAndAssert(line, sep, expected) {
  const split = line.trim().split(sep);
  if (split.length !== 2) {
    throw new ParseError(
      `Two strings separated by '${expected}'`,
      line.toString("utf8")
    );
  }
  return split;
}
function parseRemoteUrl({ url }) {
  if (url.startsWith("git@")) {
    return {
      transport: "ssh",
      address: url
    };
  }
  const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
  if (matches === null)
    return;
  if (matches[2] === "://") {
    return {
      transport: matches[1],
      address: matches[0]
    };
  }
  if (matches[2] === "::") {
    return {
      transport: matches[1],
      address: matches[3]
    };
  }
}
async function hasObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  return fs.exists(`${gitdir}/${source}`);
}
async function hasObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  getExternalRefDelta
}) {
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x2) => x2.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p2 = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p2.error)
      throw new InternalError(p2.error);
    if (p2.offsets.has(oid)) {
      return true;
    }
  }
  return false;
}
async function hasObject({
  fs,
  cache,
  gitdir,
  oid,
  format = "content"
}) {
  const getExternalRefDelta = (oid2) => _readObject({ fs, cache, gitdir, oid: oid2 });
  let result = await hasObjectLoose({ fs, gitdir, oid });
  if (!result) {
    result = await hasObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta
    });
  }
  return result;
}
function emptyPackfile(pack) {
  const pheader = "5041434b";
  const version3 = "00000002";
  const obCount = "00000000";
  const header = pheader + version3 + obCount;
  return pack.slice(0, 12).toString("hex") === header;
}
function filterCapabilities(server, client) {
  const serverNames = server.map((cap) => cap.split("=", 1)[0]);
  return client.filter((cap) => {
    const name = cap.split("=", 1)[0];
    return serverNames.includes(name);
  });
}
function findSplit(str) {
  const r6 = str.indexOf("\r");
  const n5 = str.indexOf("\n");
  if (r6 === -1 && n5 === -1)
    return -1;
  if (r6 === -1)
    return n5 + 1;
  if (n5 === -1)
    return r6 + 1;
  if (n5 === r6 + 1)
    return n5 + 1;
  return Math.min(r6, n5) + 1;
}
function splitLines(input) {
  const output = new FIFO();
  let tmp = "";
  (async () => {
    await forAwait(input, (chunk) => {
      chunk = chunk.toString("utf8");
      tmp += chunk;
      while (true) {
        const i4 = findSplit(tmp);
        if (i4 === -1)
          break;
        output.write(tmp.slice(0, i4));
        tmp = tmp.slice(i4);
      }
    });
    if (tmp.length > 0) {
      output.write(tmp);
    }
    output.end();
  })();
  return output;
}
async function parseUploadPackResponse(stream) {
  const { packetlines, packfile, progress } = GitSideBand.demux(stream);
  const shallows = [];
  const unshallows = [];
  const acks = [];
  let nak = false;
  let done = false;
  return new Promise((resolve, reject) => {
    forAwait(packetlines, (data) => {
      const line = data.toString("utf8").trim();
      if (line.startsWith("shallow")) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        shallows.push(oid);
      } else if (line.startsWith("unshallow")) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        unshallows.push(oid);
      } else if (line.startsWith("ACK")) {
        const [, oid, status3] = line.split(" ");
        acks.push({ oid, status: status3 });
        if (!status3)
          done = true;
      } else if (line.startsWith("NAK")) {
        nak = true;
        done = true;
      } else {
        done = true;
        nak = true;
      }
      if (done) {
        stream.error ? reject(stream.error) : resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    }).finally(() => {
      if (!done) {
        stream.error ? reject(stream.error) : resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    });
  });
}
function writeUploadPackRequest({
  capabilities = [],
  wants = [],
  haves = [],
  shallows = [],
  depth = null,
  since = null,
  exclude = []
}) {
  const packstream = [];
  wants = [...new Set(wants)];
  let firstLineCapabilities = ` ${capabilities.join(" ")}`;
  for (const oid of wants) {
    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}
`));
    firstLineCapabilities = "";
  }
  for (const oid of shallows) {
    packstream.push(GitPktLine.encode(`shallow ${oid}
`));
  }
  if (depth !== null) {
    packstream.push(GitPktLine.encode(`deepen ${depth}
`));
  }
  if (since !== null) {
    packstream.push(
      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1e3)}
`)
    );
  }
  for (const oid of exclude) {
    packstream.push(GitPktLine.encode(`deepen-not ${oid}
`));
  }
  packstream.push(GitPktLine.flush());
  for (const oid of haves) {
    packstream.push(GitPktLine.encode(`have ${oid}
`));
  }
  packstream.push(GitPktLine.encode(`done
`));
  return packstream;
}
async function _fetch({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote: _remote,
  url: _url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false
}) {
  const ref = _ref || await _currentBranch({ fs, gitdir, test: true });
  const config = await GitConfigManager.get({ fs, gitdir });
  const remote = _remote || ref && await config.get(`branch.${ref}.remote`) || "origin";
  const url = _url || await config.get(`remote.${remote}.url`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || ref && await config.get(`branch.${ref}.merge`) || _ref || "HEAD";
  if (corsProxy === void 0) {
    corsProxy = await config.get("http.corsProxy");
  }
  const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
  const remoteHTTP = await GitRemoteHTTP2.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-upload-pack",
    url,
    headers,
    protocolVersion: 1
  });
  const auth = remoteHTTP.auth;
  const remoteRefs = remoteHTTP.refs;
  if (remoteRefs.size === 0) {
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null
    };
  }
  if (depth !== null && !remoteHTTP.capabilities.has("shallow")) {
    throw new RemoteCapabilityError("shallow", "depth");
  }
  if (since !== null && !remoteHTTP.capabilities.has("deepen-since")) {
    throw new RemoteCapabilityError("deepen-since", "since");
  }
  if (exclude.length > 0 && !remoteHTTP.capabilities.has("deepen-not")) {
    throw new RemoteCapabilityError("deepen-not", "exclude");
  }
  if (relative === true && !remoteHTTP.capabilities.has("deepen-relative")) {
    throw new RemoteCapabilityError("deepen-relative", "relative");
  }
  const { oid, fullref } = GitRefManager.resolveAgainstMap({
    ref: remoteRef,
    map: remoteRefs
  });
  for (const remoteRef2 of remoteRefs.keys()) {
    if (remoteRef2 === fullref || remoteRef2 === "HEAD" || remoteRef2.startsWith("refs/heads/") || tags && remoteRef2.startsWith("refs/tags/")) {
      continue;
    }
    remoteRefs.delete(remoteRef2);
  }
  const capabilities = filterCapabilities(
    [...remoteHTTP.capabilities],
    [
      "multi_ack_detailed",
      "no-done",
      "side-band-64k",
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      "ofs-delta",
      `agent=${pkg.agent}`
    ]
  );
  if (relative)
    capabilities.push("deepen-relative");
  const wants = singleBranch ? [oid] : remoteRefs.values();
  const haveRefs = singleBranch ? [ref] : await GitRefManager.listRefs({
    fs,
    gitdir,
    filepath: `refs`
  });
  let haves = [];
  for (let ref2 of haveRefs) {
    try {
      ref2 = await GitRefManager.expand({ fs, gitdir, ref: ref2 });
      const oid2 = await GitRefManager.resolve({ fs, gitdir, ref: ref2 });
      if (await hasObject({ fs, cache, gitdir, oid: oid2 })) {
        haves.push(oid2);
      }
    } catch (err) {
    }
  }
  haves = [...new Set(haves)];
  const oids = await GitShallowManager.read({ fs, gitdir });
  const shallows = remoteHTTP.capabilities.has("shallow") ? [...oids] : [];
  const packstream = writeUploadPackRequest({
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude
  });
  const packbuffer = Buffer.from(await collect(packstream));
  const raw = await GitRemoteHTTP2.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-upload-pack",
    url,
    auth,
    body: [packbuffer],
    headers
  });
  const response = await parseUploadPackResponse(raw.body);
  if (raw.headers) {
    response.headers = raw.headers;
  }
  for (const oid2 of response.shallows) {
    if (!oids.has(oid2)) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid: oid2 });
        const commit3 = new GitCommit(object);
        const hasParents = await Promise.all(
          commit3.headers().parent.map((oid3) => hasObject({ fs, cache, gitdir, oid: oid3 }))
        );
        const haveAllParents = hasParents.length === 0 || hasParents.every((has) => has);
        if (!haveAllParents) {
          oids.add(oid2);
        }
      } catch (err) {
        oids.add(oid2);
      }
    }
  }
  for (const oid2 of response.unshallows) {
    oids.delete(oid2);
  }
  await GitShallowManager.write({ fs, gitdir, oids });
  if (singleBranch) {
    const refs = /* @__PURE__ */ new Map([[fullref, oid]]);
    const symrefs = /* @__PURE__ */ new Map();
    let bail = 10;
    let key = fullref;
    while (bail--) {
      const value = remoteHTTP.symrefs.get(key);
      if (value === void 0)
        break;
      symrefs.set(key, value);
      key = value;
    }
    const realRef = remoteRefs.get(key);
    if (realRef) {
      refs.set(key, realRef);
    }
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs,
      symrefs,
      tags,
      prune
    });
    if (prune) {
      response.pruned = pruned;
    }
  } else {
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs: remoteRefs,
      symrefs: remoteHTTP.symrefs,
      tags,
      prune,
      pruneTags
    });
    if (prune) {
      response.pruned = pruned;
    }
  }
  response.HEAD = remoteHTTP.symrefs.get("HEAD");
  if (response.HEAD === void 0) {
    const { oid: oid2 } = GitRefManager.resolveAgainstMap({
      ref: "HEAD",
      map: remoteRefs
    });
    for (const [key, value] of remoteRefs.entries()) {
      if (key !== "HEAD" && value === oid2) {
        response.HEAD = key;
        break;
      }
    }
  }
  const noun = fullref.startsWith("refs/tags") ? "tag" : "branch";
  response.FETCH_HEAD = {
    oid,
    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`
  };
  if (onProgress || onMessage) {
    const lines = splitLines(response.progress);
    forAwait(lines, async (line) => {
      if (onMessage)
        await onMessage(line);
      if (onProgress) {
        const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
        if (matches) {
          await onProgress({
            phase: matches[1].trim(),
            loaded: parseInt(matches[2], 10),
            total: parseInt(matches[3], 10)
          });
        }
      }
    });
  }
  const packfile = Buffer.from(await collect(response.packfile));
  if (raw.body.error)
    throw raw.body.error;
  const packfileSha = packfile.slice(-20).toString("hex");
  const res = {
    defaultBranch: response.HEAD,
    fetchHead: response.FETCH_HEAD.oid,
    fetchHeadDescription: response.FETCH_HEAD.description
  };
  if (response.headers) {
    res.headers = response.headers;
  }
  if (prune) {
    res.pruned = response.pruned;
  }
  if (packfileSha !== "" && !emptyPackfile(packfile)) {
    res.packfile = `objects/pack/pack-${packfileSha}.pack`;
    const fullpath = join(gitdir, res.packfile);
    await fs.write(fullpath, packfile);
    const getExternalRefDelta = (oid2) => _readObject({ fs, cache, gitdir, oid: oid2 });
    const idx = await GitPackIndex.fromPack({
      pack: packfile,
      getExternalRefDelta,
      onProgress
    });
    await fs.write(fullpath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
  }
  return res;
}
async function _init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, ".git"),
  defaultBranch = "master"
}) {
  if (await fs.exists(gitdir + "/config"))
    return;
  let folders = [
    "hooks",
    "info",
    "objects/info",
    "objects/pack",
    "refs/heads",
    "refs/tags"
  ];
  folders = folders.map((dir2) => gitdir + "/" + dir2);
  for (const folder of folders) {
    await fs.mkdir(folder);
  }
  await fs.write(
    gitdir + "/config",
    `[core]
	repositoryformatversion = 0
	filemode = false
	bare = ${bare}
` + (bare ? "" : "	logallrefupdates = true\n") + "	symlinks = false\n	ignorecase = true\n"
  );
  await fs.write(gitdir + "/HEAD", `ref: refs/heads/${defaultBranch}
`);
}
async function _clone({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  url,
  corsProxy,
  ref,
  remote,
  depth,
  since,
  exclude,
  relative,
  singleBranch,
  noCheckout,
  noTags,
  headers
}) {
  try {
    await _init({ fs, gitdir });
    await _addRemote({ fs, gitdir, remote, url, force: false });
    if (corsProxy) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`http.corsProxy`, corsProxy);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    const { defaultBranch, fetchHead } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      headers,
      tags: !noTags
    });
    if (fetchHead === null)
      return;
    ref = ref || defaultBranch;
    ref = ref.replace("refs/heads/", "");
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout
    });
  } catch (err) {
    await fs.rmdir(gitdir, { recursive: true, maxRetries: 10 }).catch(() => void 0);
    throw err;
  }
}
async function clone({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  url,
  corsProxy = void 0,
  ref = void 0,
  remote = "origin",
  depth = void 0,
  since = void 0,
  exclude = [],
  relative = false,
  singleBranch = false,
  noCheckout = false,
  noTags = false,
  headers = {},
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    if (!noCheckout) {
      assertParameter("dir", dir);
    }
    assertParameter("url", url);
    return await _clone({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers
    });
  } catch (err) {
    err.caller = "git.clone";
    throw err;
  }
}
async function commit({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  message,
  author: _author,
  committer: _committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("message", message);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _commit({
      fs,
      cache,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
      ref,
      parent,
      tree
    });
  } catch (err) {
    err.caller = "git.commit";
    throw err;
  }
}
async function currentBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  fullname = false,
  test = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _currentBranch({
      fs: new FileSystem(fs),
      gitdir,
      fullname,
      test
    });
  } catch (err) {
    err.caller = "git.currentBranch";
    throw err;
  }
}
async function _deleteBranch({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/heads/") ? ref : `refs/heads/${ref}`;
  const exist = await GitRefManager.exists({ fs, gitdir, ref });
  if (!exist) {
    throw new NotFoundError(ref);
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
  if (fullRef === currentRef) {
    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
    await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value });
  }
  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
}
async function deleteBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.deleteBranch";
    throw err;
  }
}
async function deleteRef({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
  } catch (err) {
    err.caller = "git.deleteRef";
    throw err;
  }
}
async function _deleteRemote({ fs, gitdir, remote }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  await config.deleteSection("remote", remote);
  await GitConfigManager.save({ fs, gitdir, config });
}
async function deleteRemote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("remote", remote);
    return await _deleteRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote
    });
  } catch (err) {
    err.caller = "git.deleteRemote";
    throw err;
  }
}
async function _deleteTag({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  await GitRefManager.deleteRef({ fs, gitdir, ref });
}
async function deleteTag({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteTag({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.deleteTag";
    throw err;
  }
}
async function expandOidLoose({ fs, gitdir, oid: short }) {
  const prefix = short.slice(0, 2);
  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
  return objectsSuffixes.map((suffix) => `${prefix}${suffix}`).filter((_oid) => _oid.startsWith(short));
}
async function expandOidPacked({
  fs,
  cache,
  gitdir,
  oid: short,
  getExternalRefDelta
}) {
  const results = [];
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x2) => x2.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p2 = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p2.error)
      throw new InternalError(p2.error);
    for (const oid of p2.offsets.keys()) {
      if (oid.startsWith(short))
        results.push(oid);
    }
  }
  return results;
}
async function _expandOid({ fs, cache, gitdir, oid: short }) {
  const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid });
  const results = await expandOidLoose({ fs, gitdir, oid: short });
  const packedOids = await expandOidPacked({
    fs,
    cache,
    gitdir,
    oid: short,
    getExternalRefDelta
  });
  for (const packedOid of packedOids) {
    if (results.indexOf(packedOid) === -1) {
      results.push(packedOid);
    }
  }
  if (results.length === 1) {
    return results[0];
  }
  if (results.length > 1) {
    throw new AmbiguousError("oids", short, results);
  }
  throw new NotFoundError(`an object matching "${short}"`);
}
async function expandOid({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _expandOid({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid
    });
  } catch (err) {
    err.caller = "git.expandOid";
    throw err;
  }
}
async function expandRef({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await GitRefManager.expand({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.expandRef";
    throw err;
  }
}
async function _findMergeBase({ fs, cache, gitdir, oids }) {
  const visits = {};
  const passes = oids.length;
  let heads = oids.map((oid, index2) => ({ index: index2, oid }));
  while (heads.length) {
    const result = /* @__PURE__ */ new Set();
    for (const { oid, index: index2 } of heads) {
      if (!visits[oid])
        visits[oid] = /* @__PURE__ */ new Set();
      visits[oid].add(index2);
      if (visits[oid].size === passes) {
        result.add(oid);
      }
    }
    if (result.size > 0) {
      return [...result];
    }
    const newheads = /* @__PURE__ */ new Map();
    for (const { oid, index: index2 } of heads) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit3 = GitCommit.from(object);
        const { parent } = commit3.parseHeaders();
        for (const oid2 of parent) {
          if (!visits[oid2] || !visits[oid2].has(index2)) {
            newheads.set(oid2 + ":" + index2, { oid: oid2, index: index2 });
          }
        }
      } catch (err) {
      }
    }
    heads = Array.from(newheads.values());
  }
  return [];
}
function mergeFile({ branches, contents }) {
  const ourName = branches[1];
  const theirName = branches[2];
  const baseContent = contents[0];
  const ourContent = contents[1];
  const theirContent = contents[2];
  const ours = ourContent.match(LINEBREAKS);
  const base = baseContent.match(LINEBREAKS);
  const theirs = theirContent.match(LINEBREAKS);
  const result = diff3_default(ours, base, theirs);
  const markerSize = 7;
  let mergedText = "";
  let cleanMerge = true;
  for (const item of result) {
    if (item.ok) {
      mergedText += item.ok.join("");
    }
    if (item.conflict) {
      cleanMerge = false;
      mergedText += `${"<".repeat(markerSize)} ${ourName}
`;
      mergedText += item.conflict.a.join("");
      mergedText += `${"=".repeat(markerSize)}
`;
      mergedText += item.conflict.b.join("");
      mergedText += `${">".repeat(markerSize)} ${theirName}
`;
    }
  }
  return { cleanMerge, mergedText };
}
async function mergeTree({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  index: index2,
  ourOid,
  baseOid,
  theirOid,
  ourName = "ours",
  baseName = "base",
  theirName = "theirs",
  dryRun = false,
  abortOnConflict = true,
  mergeDriver
}) {
  const ourTree = TREE({ ref: ourOid });
  const baseTree = TREE({ ref: baseOid });
  const theirTree = TREE({ ref: theirOid });
  const unmergedFiles = [];
  const bothModified = [];
  const deleteByUs = [];
  const deleteByTheirs = [];
  const results = await _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [ourTree, baseTree, theirTree],
    map: async function(filepath, [ours, base, theirs]) {
      const path = basename(filepath);
      const ourChange = await modified(ours, base);
      const theirChange = await modified(theirs, base);
      switch (`${ourChange}-${theirChange}`) {
        case "false-false": {
          return {
            mode: await base.mode(),
            path,
            oid: await base.oid(),
            type: await base.type()
          };
        }
        case "false-true": {
          return theirs ? {
            mode: await theirs.mode(),
            path,
            oid: await theirs.oid(),
            type: await theirs.type()
          } : void 0;
        }
        case "true-false": {
          return ours ? {
            mode: await ours.mode(),
            path,
            oid: await ours.oid(),
            type: await ours.type()
          } : void 0;
        }
        case "true-true": {
          if (ours && base && theirs && await ours.type() === "blob" && await base.type() === "blob" && await theirs.type() === "blob") {
            return mergeBlobs({
              fs,
              gitdir,
              path,
              ours,
              base,
              theirs,
              ourName,
              baseName,
              theirName,
              mergeDriver
            }).then(async (r6) => {
              if (!r6.cleanMerge) {
                unmergedFiles.push(filepath);
                bothModified.push(filepath);
                if (!abortOnConflict) {
                  const baseOid2 = await base.oid();
                  const ourOid2 = await ours.oid();
                  const theirOid2 = await theirs.oid();
                  index2.delete({ filepath });
                  index2.insert({ filepath, oid: baseOid2, stage: 1 });
                  index2.insert({ filepath, oid: ourOid2, stage: 2 });
                  index2.insert({ filepath, oid: theirOid2, stage: 3 });
                }
              } else if (!abortOnConflict) {
                index2.insert({ filepath, oid: r6.mergeResult.oid, stage: 0 });
              }
              return r6.mergeResult;
            });
          }
          if (base && !ours && theirs && await base.type() === "blob" && await theirs.type() === "blob") {
            unmergedFiles.push(filepath);
            deleteByUs.push(filepath);
            if (!abortOnConflict) {
              const baseOid2 = await base.oid();
              const theirOid2 = await theirs.oid();
              index2.delete({ filepath });
              index2.insert({ filepath, oid: baseOid2, stage: 1 });
              index2.insert({ filepath, oid: theirOid2, stage: 3 });
            }
            return {
              mode: await theirs.mode(),
              oid: await theirs.oid(),
              type: "blob",
              path
            };
          }
          if (base && ours && !theirs && await base.type() === "blob" && await ours.type() === "blob") {
            unmergedFiles.push(filepath);
            deleteByTheirs.push(filepath);
            if (!abortOnConflict) {
              const baseOid2 = await base.oid();
              const ourOid2 = await ours.oid();
              index2.delete({ filepath });
              index2.insert({ filepath, oid: baseOid2, stage: 1 });
              index2.insert({ filepath, oid: ourOid2, stage: 2 });
            }
            return {
              mode: await ours.mode(),
              oid: await ours.oid(),
              type: "blob",
              path
            };
          }
          if (base && !ours && !theirs && await base.type() === "blob") {
            return void 0;
          }
          throw new MergeNotSupportedError();
        }
      }
    },
    /**
     * @param {TreeEntry} [parent]
     * @param {Array<TreeEntry>} children
     */
    reduce: unmergedFiles.length !== 0 && (!dir || abortOnConflict) ? void 0 : async (parent, children) => {
      const entries = children.filter(Boolean);
      if (!parent)
        return;
      if (parent && parent.type === "tree" && entries.length === 0)
        return;
      if (entries.length > 0) {
        const tree = new GitTree(entries);
        const object = tree.toObject();
        const oid = await _writeObject({
          fs,
          gitdir,
          type: "tree",
          object,
          dryRun
        });
        parent.oid = oid;
      }
      return parent;
    }
  });
  if (unmergedFiles.length !== 0) {
    if (dir && !abortOnConflict) {
      await _walk({
        fs,
        cache,
        dir,
        gitdir,
        trees: [TREE({ ref: results.oid })],
        map: async function(filepath, [entry]) {
          const path = `${dir}/${filepath}`;
          if (await entry.type() === "blob") {
            const mode = await entry.mode();
            const content = new TextDecoder().decode(await entry.content());
            await fs.write(path, content, { mode });
          }
          return true;
        }
      });
    }
    return new MergeConflictError(
      unmergedFiles,
      bothModified,
      deleteByUs,
      deleteByTheirs
    );
  }
  return results.oid;
}
async function mergeBlobs({
  fs,
  gitdir,
  path,
  ours,
  base,
  theirs,
  ourName,
  theirName,
  baseName,
  dryRun,
  mergeDriver = mergeFile
}) {
  const type = "blob";
  const mode = await base.mode() === await ours.mode() ? await theirs.mode() : await ours.mode();
  if (await ours.oid() === await theirs.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await ours.oid(), type }
    };
  }
  if (await ours.oid() === await base.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await theirs.oid(), type }
    };
  }
  if (await theirs.oid() === await base.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path, oid: await ours.oid(), type }
    };
  }
  const ourContent = Buffer.from(await ours.content()).toString("utf8");
  const baseContent = Buffer.from(await base.content()).toString("utf8");
  const theirContent = Buffer.from(await theirs.content()).toString("utf8");
  const { mergedText, cleanMerge } = await mergeDriver({
    branches: [baseName, ourName, theirName],
    contents: [baseContent, ourContent, theirContent],
    path
  });
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: Buffer.from(mergedText, "utf8"),
    dryRun
  });
  return { cleanMerge, mergeResult: { mode, path, oid, type } };
}
async function _merge({
  fs,
  cache,
  dir,
  gitdir,
  ours,
  theirs,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author,
  committer,
  signingKey,
  onSign,
  mergeDriver
}) {
  if (ours === void 0) {
    ours = await _currentBranch({ fs, gitdir, fullname: true });
  }
  ours = await GitRefManager.expand({
    fs,
    gitdir,
    ref: ours
  });
  theirs = await GitRefManager.expand({
    fs,
    gitdir,
    ref: theirs
  });
  const ourOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: ours
  });
  const theirOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: theirs
  });
  const baseOids = await _findMergeBase({
    fs,
    cache,
    gitdir,
    oids: [ourOid, theirOid]
  });
  if (baseOids.length !== 1) {
    throw new MergeNotSupportedError();
  }
  const baseOid = baseOids[0];
  if (baseOid === theirOid) {
    return {
      oid: ourOid,
      alreadyMerged: true
    };
  }
  if (fastForward2 && baseOid === ourOid) {
    if (!dryRun && !noUpdateBranch) {
      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
    }
    return {
      oid: theirOid,
      fastForward: true
    };
  } else {
    if (fastForwardOnly) {
      throw new FastForwardError();
    }
    const tree = await GitIndexManager.acquire(
      { fs, gitdir, cache, allowUnmerged: false },
      async (index2) => {
        return mergeTree({
          fs,
          cache,
          dir,
          gitdir,
          index: index2,
          ourOid,
          theirOid,
          baseOid,
          ourName: abbreviateRef(ours),
          baseName: "base",
          theirName: abbreviateRef(theirs),
          dryRun,
          abortOnConflict,
          mergeDriver
        });
      }
    );
    if (tree instanceof MergeConflictError)
      throw tree;
    if (!message) {
      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
        ours
      )}`;
    }
    const oid = await _commit({
      fs,
      cache,
      gitdir,
      message,
      ref: ours,
      tree,
      parent: [ourOid, theirOid],
      author,
      committer,
      signingKey,
      onSign,
      dryRun,
      noUpdateBranch
    });
    return {
      oid,
      tree,
      mergeCommit: true
    };
  }
}
async function _pull({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  ref,
  url,
  remote,
  remoteRef,
  prune,
  pruneTags,
  fastForward: fastForward2,
  fastForwardOnly,
  corsProxy,
  singleBranch,
  headers,
  author,
  committer,
  signingKey
}) {
  try {
    if (!ref) {
      const head = await _currentBranch({ fs, gitdir });
      if (!head) {
        throw new MissingParameterError("ref");
      }
      ref = head;
    }
    const { fetchHead, fetchHeadDescription } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      corsProxy,
      ref,
      url,
      remote,
      remoteRef,
      singleBranch,
      headers,
      prune,
      pruneTags
    });
    await _merge({
      fs,
      cache,
      gitdir,
      ours: ref,
      theirs: fetchHead,
      fastForward: fastForward2,
      fastForwardOnly,
      message: `Merge ${fetchHeadDescription}`,
      author,
      committer,
      signingKey,
      dryRun: false,
      noUpdateBranch: false
    });
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout: false
    });
  } catch (err) {
    err.caller = "git.pull";
    throw err;
  }
}
async function fastForward({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  corsProxy,
  singleBranch,
  headers = {},
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    const thisWillNotBeUsed = {
      name: "",
      email: "",
      timestamp: Date.now(),
      timezoneOffset: 0
    };
    return await _pull({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly: true,
      corsProxy,
      singleBranch,
      headers,
      author: thisWillNotBeUsed,
      committer: thisWillNotBeUsed
    });
  } catch (err) {
    err.caller = "git.fastForward";
    throw err;
  }
}
async function fetch2({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  remote,
  remoteRef,
  url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _fetch({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      tags,
      singleBranch,
      headers,
      prune,
      pruneTags
    });
  } catch (err) {
    err.caller = "git.fetch";
    throw err;
  }
}
async function findMergeBase({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oids,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _findMergeBase({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids
    });
  } catch (err) {
    err.caller = "git.findMergeBase";
    throw err;
  }
}
async function _findRoot({ fs, filepath }) {
  if (await fs.exists(join(filepath, ".git"))) {
    return filepath;
  } else {
    const parent = dirname(filepath);
    if (parent === filepath) {
      throw new NotFoundError(`git root for ${filepath}`);
    }
    return _findRoot({ fs, filepath: parent });
  }
}
async function findRoot({ fs, filepath }) {
  try {
    assertParameter("fs", fs);
    assertParameter("filepath", filepath);
    return await _findRoot({ fs: new FileSystem(fs), filepath });
  } catch (err) {
    err.caller = "git.findRoot";
    throw err;
  }
}
async function getConfig({ fs, dir, gitdir = join(dir, ".git"), path }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfig({
      fs: new FileSystem(fs),
      gitdir,
      path
    });
  } catch (err) {
    err.caller = "git.getConfig";
    throw err;
  }
}
async function _getConfigAll({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.getall(path);
}
async function getConfigAll({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  path
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfigAll({
      fs: new FileSystem(fs),
      gitdir,
      path
    });
  } catch (err) {
    err.caller = "git.getConfigAll";
    throw err;
  }
}
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP2.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion: 1
    });
    const result = {
      capabilities: [...remote.capabilities]
    };
    for (const [ref, oid] of remote.refs) {
      const parts = ref.split("/");
      const last = parts.pop();
      let o5 = result;
      for (const part of parts) {
        o5[part] = o5[part] || {};
        o5 = o5[part];
      }
      o5[last] = oid;
    }
    for (const [symref, ref] of remote.symrefs) {
      const parts = symref.split("/");
      const last = parts.pop();
      let o5 = result;
      for (const part of parts) {
        o5[part] = o5[part] || {};
        o5 = o5[part];
      }
      o5[last] = ref;
    }
    return result;
  } catch (err) {
    err.caller = "git.getRemoteInfo";
    throw err;
  }
}
function formatInfoRefs(remote, prefix, symrefs, peelTags) {
  const refs = [];
  for (const [key, value] of remote.refs) {
    if (prefix && !key.startsWith(prefix))
      continue;
    if (key.endsWith("^{}")) {
      if (peelTags) {
        const _key = key.replace("^{}", "");
        const last = refs[refs.length - 1];
        const r6 = last.ref === _key ? last : refs.find((x2) => x2.ref === _key);
        if (r6 === void 0) {
          throw new Error("I did not expect this to happen");
        }
        r6.peeled = value;
      }
      continue;
    }
    const ref = { ref: key, oid: value };
    if (symrefs) {
      if (remote.symrefs.has(key)) {
        ref.target = remote.symrefs.get(key);
      }
    }
    refs.push(ref);
  }
  return refs;
}
async function getRemoteInfo2({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP2.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion
    });
    if (remote.protocolVersion === 2) {
      return {
        protocolVersion: remote.protocolVersion,
        capabilities: remote.capabilities2
      };
    }
    const capabilities = {};
    for (const cap of remote.capabilities) {
      const [key, value] = cap.split("=");
      if (value) {
        capabilities[key] = value;
      } else {
        capabilities[key] = true;
      }
    }
    return {
      protocolVersion: 1,
      capabilities,
      refs: formatInfoRefs(remote, void 0, true, true)
    };
  } catch (err) {
    err.caller = "git.getRemoteInfo2";
    throw err;
  }
}
async function hashObject({
  type,
  object,
  format = "content",
  oid = void 0
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
  }
  return { oid, object };
}
async function hashBlob({ object }) {
  try {
    assertParameter("object", object);
    if (typeof object === "string") {
      object = Buffer.from(object, "utf8");
    } else {
      object = Buffer.from(object);
    }
    const type = "blob";
    const { oid, object: _object } = await hashObject({
      type: "blob",
      format: "content",
      object
    });
    return { oid, type, object: new Uint8Array(_object), format: "wrapped" };
  } catch (err) {
    err.caller = "git.hashBlob";
    throw err;
  }
}
async function _indexPack({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  filepath
}) {
  try {
    filepath = join(dir, filepath);
    const pack = await fs.read(filepath);
    const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack,
      getExternalRefDelta,
      onProgress
    });
    await fs.write(filepath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
    return {
      oids: [...idx.hashes]
    };
  } catch (err) {
    err.caller = "git.indexPack";
    throw err;
  }
}
async function indexPack({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", dir);
    assertParameter("filepath", filepath);
    return await _indexPack({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      filepath
    });
  } catch (err) {
    err.caller = "git.indexPack";
    throw err;
  }
}
async function init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, ".git"),
  defaultBranch = "master"
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    if (!bare) {
      assertParameter("dir", dir);
    }
    return await _init({
      fs: new FileSystem(fs),
      bare,
      dir,
      gitdir,
      defaultBranch
    });
  } catch (err) {
    err.caller = "git.init";
    throw err;
  }
}
async function _isDescendent({
  fs,
  cache,
  gitdir,
  oid,
  ancestor,
  depth
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  if (!oid) {
    throw new MissingParameterError("oid");
  }
  if (!ancestor) {
    throw new MissingParameterError("ancestor");
  }
  if (oid === ancestor)
    return false;
  const queue = [oid];
  const visited = /* @__PURE__ */ new Set();
  let searchdepth = 0;
  while (queue.length) {
    if (searchdepth++ === depth) {
      throw new MaxDepthError(depth);
    }
    const oid2 = queue.shift();
    const { type, object } = await _readObject({
      fs,
      cache,
      gitdir,
      oid: oid2
    });
    if (type !== "commit") {
      throw new ObjectTypeError(oid2, type, "commit");
    }
    const commit3 = GitCommit.from(object).parse();
    for (const parent of commit3.parent) {
      if (parent === ancestor)
        return true;
    }
    if (!shallows.has(oid2)) {
      for (const parent of commit3.parent) {
        if (!visited.has(parent)) {
          queue.push(parent);
          visited.add(parent);
        }
      }
    }
  }
  return false;
}
async function isDescendent({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  ancestor,
  depth = -1,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("ancestor", ancestor);
    return await _isDescendent({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      ancestor,
      depth
    });
  } catch (err) {
    err.caller = "git.isDescendent";
    throw err;
  }
}
async function isIgnored({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    return GitIgnoreManager.isIgnored({
      fs: new FileSystem(fs),
      dir,
      gitdir,
      filepath
    });
  } catch (err) {
    err.caller = "git.isIgnored";
    throw err;
  }
}
async function listBranches({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listBranches({
      fs: new FileSystem(fs),
      gitdir,
      remote
    });
  } catch (err) {
    err.caller = "git.listBranches";
    throw err;
  }
}
async function _listFiles({ fs, gitdir, ref, cache }) {
  if (ref) {
    const oid = await GitRefManager.resolve({ gitdir, fs, ref });
    const filenames = [];
    await accumulateFilesFromOid({
      fs,
      cache,
      gitdir,
      oid,
      filenames,
      prefix: ""
    });
    return filenames;
  } else {
    return GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      return index2.entries.map((x2) => x2.path);
    });
  }
}
async function accumulateFilesFromOid({
  fs,
  cache,
  gitdir,
  oid,
  filenames,
  prefix
}) {
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  for (const entry of tree) {
    if (entry.type === "tree") {
      await accumulateFilesFromOid({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
        filenames,
        prefix: join(prefix, entry.path)
      });
    } else {
      filenames.push(join(prefix, entry.path));
    }
  }
}
async function listFiles({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listFiles({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.listFiles";
    throw err;
  }
}
async function _listNotes({ fs, cache, gitdir, ref }) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (err instanceof NotFoundError) {
      return [];
    }
  }
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent
  });
  const notes = result.tree.map((entry) => ({
    target: entry.path,
    note: entry.oid
  }));
  return notes;
}
async function listNotes({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _listNotes({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.listNotes";
    throw err;
  }
}
async function _listRemotes({ fs, gitdir }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  const remoteNames = await config.getSubsections("remote");
  const remotes = Promise.all(
    remoteNames.map(async (remote) => {
      const url = await config.get(`remote.${remote}.url`);
      return { remote, url };
    })
  );
  return remotes;
}
async function listRemotes({ fs, dir, gitdir = join(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listRemotes({
      fs: new FileSystem(fs),
      gitdir
    });
  } catch (err) {
    err.caller = "git.listRemotes";
    throw err;
  }
}
async function parseListRefsResponse(stream) {
  const read = GitPktLine.streamReader(stream);
  const refs = [];
  let line;
  while (true) {
    line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    line = line.toString("utf8").replace(/\n$/, "");
    const [oid, ref, ...attrs] = line.split(" ");
    const r6 = { ref, oid };
    for (const attr of attrs) {
      const [name, value] = attr.split(":");
      if (name === "symref-target") {
        r6.target = value;
      } else if (name === "peeled") {
        r6.peeled = value;
      }
    }
    refs.push(r6);
  }
  return refs;
}
async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
  const packstream = [];
  packstream.push(GitPktLine.encode("command=ls-refs\n"));
  packstream.push(GitPktLine.encode(`agent=${pkg.agent}
`));
  if (peelTags || symrefs || prefix) {
    packstream.push(GitPktLine.delim());
  }
  if (peelTags)
    packstream.push(GitPktLine.encode("peel"));
  if (symrefs)
    packstream.push(GitPktLine.encode("symrefs"));
  if (prefix)
    packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function listServerRefs({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
  prefix,
  symrefs,
  peelTags
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion
    });
    if (remote.protocolVersion === 1) {
      return formatInfoRefs(remote, prefix, symrefs, peelTags);
    }
    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });
    const res = await GitRemoteHTTP.connect({
      http,
      auth: remote.auth,
      headers,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      body
    });
    return parseListRefsResponse(res.body);
  } catch (err) {
    err.caller = "git.listServerRefs";
    throw err;
  }
}
async function listTags({ fs, dir, gitdir = join(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir });
  } catch (err) {
    err.caller = "git.listTags";
    throw err;
  }
}
async function resolveCommit({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveCommit({ fs, cache, gitdir, oid });
  }
  if (type !== "commit") {
    throw new ObjectTypeError(oid, type, "commit");
  }
  return { commit: GitCommit.from(object), oid };
}
async function _readCommit({ fs, cache, gitdir, oid }) {
  const { commit: commit3, oid: commitOid } = await resolveCommit({
    fs,
    cache,
    gitdir,
    oid
  });
  const result = {
    oid: commitOid,
    commit: commit3.parse(),
    payload: commit3.withoutSignature()
  };
  return result;
}
function compareAge(a2, b2) {
  return a2.committer.timestamp - b2.committer.timestamp;
}
async function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {
  if (fileId === EMPTY_OID)
    return;
  const _oid = oid;
  let filepath;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (fileId === result.oid) {
    filepath = result.path;
  } else {
    filepath = await _resolveFileId({
      fs,
      cache,
      gitdir,
      tree,
      fileId,
      oid: _oid
    });
    if (Array.isArray(filepath)) {
      if (filepath.length === 0)
        filepath = void 0;
      else if (filepath.length === 1)
        filepath = filepath[0];
    }
  }
  return filepath;
}
async function _resolveFileId({
  fs,
  cache,
  gitdir,
  tree,
  fileId,
  oid,
  filepaths = [],
  parentPath = ""
}) {
  const walks = tree.entries().map(function(entry) {
    let result;
    if (entry.oid === fileId) {
      result = join(parentPath, entry.path);
      filepaths.push(result);
    } else if (entry.type === "tree") {
      result = _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid
      }).then(function({ object }) {
        return _resolveFileId({
          fs,
          cache,
          gitdir,
          tree: GitTree.from(object),
          fileId,
          oid,
          filepaths,
          parentPath: join(parentPath, entry.path)
        });
      });
    }
    return result;
  });
  await Promise.all(walks);
  return filepaths;
}
async function _log({
  fs,
  cache,
  gitdir,
  filepath,
  ref,
  depth,
  since,
  force,
  follow
}) {
  const sinceTimestamp = typeof since === "undefined" ? void 0 : Math.floor(since.valueOf() / 1e3);
  const commits = [];
  const shallowCommits = await GitShallowManager.read({ fs, gitdir });
  const oid = await GitRefManager.resolve({ fs, gitdir, ref });
  const tips = [await _readCommit({ fs, cache, gitdir, oid })];
  let lastFileOid;
  let lastCommit;
  let isOk;
  function endCommit(commit3) {
    if (isOk && filepath)
      commits.push(commit3);
  }
  while (tips.length > 0) {
    const commit3 = tips.pop();
    if (sinceTimestamp !== void 0 && commit3.commit.committer.timestamp <= sinceTimestamp) {
      break;
    }
    if (filepath) {
      let vFileOid;
      try {
        vFileOid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid: commit3.commit.tree,
          filepath
        });
        if (lastCommit && lastFileOid !== vFileOid) {
          commits.push(lastCommit);
        }
        lastFileOid = vFileOid;
        lastCommit = commit3;
        isOk = true;
      } catch (e6) {
        if (e6 instanceof NotFoundError) {
          let found = follow && lastFileOid;
          if (found) {
            found = await resolveFileIdInTree({
              fs,
              cache,
              gitdir,
              oid: commit3.commit.tree,
              fileId: lastFileOid
            });
            if (found) {
              if (Array.isArray(found)) {
                if (lastCommit) {
                  const lastFound = await resolveFileIdInTree({
                    fs,
                    cache,
                    gitdir,
                    oid: lastCommit.commit.tree,
                    fileId: lastFileOid
                  });
                  if (Array.isArray(lastFound)) {
                    found = found.filter((p2) => lastFound.indexOf(p2) === -1);
                    if (found.length === 1) {
                      found = found[0];
                      filepath = found;
                      if (lastCommit)
                        commits.push(lastCommit);
                    } else {
                      found = false;
                      if (lastCommit)
                        commits.push(lastCommit);
                      break;
                    }
                  }
                }
              } else {
                filepath = found;
                if (lastCommit)
                  commits.push(lastCommit);
              }
            }
          }
          if (!found) {
            if (isOk && lastFileOid) {
              commits.push(lastCommit);
              if (!force)
                break;
            }
            if (!force && !follow)
              throw e6;
          }
          lastCommit = commit3;
          isOk = false;
        } else
          throw e6;
      }
    } else {
      commits.push(commit3);
    }
    if (depth !== void 0 && commits.length === depth) {
      endCommit(commit3);
      break;
    }
    if (!shallowCommits.has(commit3.oid)) {
      for (const oid2 of commit3.commit.parent) {
        const commit4 = await _readCommit({ fs, cache, gitdir, oid: oid2 });
        if (!tips.map((commit5) => commit5.oid).includes(commit4.oid)) {
          tips.push(commit4);
        }
      }
    }
    if (tips.length === 0) {
      endCommit(commit3);
    }
    tips.sort((a2, b2) => compareAge(a2.commit, b2.commit));
  }
  return commits;
}
async function log({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  ref = "HEAD",
  depth,
  since,
  // Date
  force,
  follow,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _log({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow
    });
  } catch (err) {
    err.caller = "git.log";
    throw err;
  }
}
async function merge({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ours,
  theirs,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
  mergeDriver
}) {
  try {
    assertParameter("fs", _fs);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author && (!fastForwardOnly || !fastForward2)) {
      throw new MissingNameError("author");
    }
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer && (!fastForwardOnly || !fastForward2)) {
      throw new MissingNameError("committer");
    }
    return await _merge({
      fs,
      cache,
      dir,
      gitdir,
      ours,
      theirs,
      fastForward: fastForward2,
      fastForwardOnly,
      dryRun,
      noUpdateBranch,
      abortOnConflict,
      message,
      author,
      committer,
      signingKey,
      onSign,
      mergeDriver
    });
  } catch (err) {
    err.caller = "git.merge";
    throw err;
  }
}
async function _pack({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  oids
}) {
  const hash2 = new import_sha1.default();
  const outputStream = [];
  function write(chunk, enc) {
    const buff = Buffer.from(chunk, enc);
    outputStream.push(buff);
    hash2.update(buff);
  }
  async function writeObject2({ stype, object }) {
    const type = types[stype];
    let length = object.length;
    let multibyte = length > 15 ? 128 : 0;
    const lastFour = length & 15;
    length = length >>> 4;
    let byte = (multibyte | type | lastFour).toString(16);
    write(byte, "hex");
    while (multibyte) {
      multibyte = length > 127 ? 128 : 0;
      byte = multibyte | length & 127;
      write(padHex(2, byte), "hex");
      length = length >>> 7;
    }
    write(Buffer.from(await deflate(object)));
  }
  write("PACK");
  write("00000002", "hex");
  write(padHex(8, oids.length), "hex");
  for (const oid of oids) {
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    await writeObject2({ write, object, stype: type });
  }
  const digest = hash2.digest();
  outputStream.push(digest);
  return outputStream;
}
async function _packObjects({ fs, cache, gitdir, oids, write }) {
  const buffers = await _pack({ fs, cache, gitdir, oids });
  const packfile = Buffer.from(await collect(buffers));
  const packfileSha = packfile.slice(-20).toString("hex");
  const filename = `pack-${packfileSha}.pack`;
  if (write) {
    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);
    return { filename };
  }
  return {
    filename,
    packfile: new Uint8Array(packfile)
  };
}
async function packObjects({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oids,
  write = false,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _packObjects({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
      write
    });
  } catch (err) {
    err.caller = "git.packObjects";
    throw err;
  }
}
async function pull({
  fs: _fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  prune = false,
  pruneTags = false,
  fastForward: fastForward2 = true,
  fastForwardOnly = false,
  corsProxy,
  singleBranch,
  headers = {},
  author: _author,
  committer: _committer,
  signingKey,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _pull({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForward: fastForward2,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey,
      prune,
      pruneTags
    });
  } catch (err) {
    err.caller = "git.pull";
    throw err;
  }
}
async function listCommitsAndTags({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  start,
  finish
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  const startingSet = /* @__PURE__ */ new Set();
  const finishingSet = /* @__PURE__ */ new Set();
  for (const ref of start) {
    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
  }
  for (const ref of finish) {
    try {
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      finishingSet.add(oid);
    } catch (err) {
    }
  }
  const visited = /* @__PURE__ */ new Set();
  async function walk3(oid) {
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === "tag") {
      const tag2 = GitAnnotatedTag.from(object);
      const commit3 = tag2.headers().object;
      return walk3(commit3);
    }
    if (type !== "commit") {
      throw new ObjectTypeError(oid, type, "commit");
    }
    if (!shallows.has(oid)) {
      const commit3 = GitCommit.from(object);
      const parents = commit3.headers().parent;
      for (oid of parents) {
        if (!finishingSet.has(oid) && !visited.has(oid)) {
          await walk3(oid);
        }
      }
    }
  }
  for (const oid of startingSet) {
    await walk3(oid);
  }
  return visited;
}
async function listObjects({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  oids
}) {
  const visited = /* @__PURE__ */ new Set();
  async function walk3(oid) {
    if (visited.has(oid))
      return;
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === "tag") {
      const tag2 = GitAnnotatedTag.from(object);
      const obj = tag2.headers().object;
      await walk3(obj);
    } else if (type === "commit") {
      const commit3 = GitCommit.from(object);
      const tree = commit3.headers().tree;
      await walk3(tree);
    } else if (type === "tree") {
      const tree = GitTree.from(object);
      for (const entry of tree) {
        if (entry.type === "blob") {
          visited.add(entry.oid);
        }
        if (entry.type === "tree") {
          await walk3(entry.oid);
        }
      }
    }
  }
  for (const oid of oids) {
    await walk3(oid);
  }
  return visited;
}
async function parseReceivePackResponse(packfile) {
  const result = {};
  let response = "";
  const read = GitPktLine.streamReader(packfile);
  let line = await read();
  while (line !== true) {
    if (line !== null)
      response += line.toString("utf8") + "\n";
    line = await read();
  }
  const lines = response.toString("utf8").split("\n");
  line = lines.shift();
  if (!line.startsWith("unpack ")) {
    throw new ParseError('unpack ok" or "unpack [error message]', line);
  }
  result.ok = line === "unpack ok";
  if (!result.ok) {
    result.error = line.slice("unpack ".length);
  }
  result.refs = {};
  for (const line2 of lines) {
    if (line2.trim() === "")
      continue;
    const status3 = line2.slice(0, 2);
    const refAndMessage = line2.slice(3);
    let space = refAndMessage.indexOf(" ");
    if (space === -1)
      space = refAndMessage.length;
    const ref = refAndMessage.slice(0, space);
    const error = refAndMessage.slice(space + 1);
    result.refs[ref] = {
      ok: status3 === "ok",
      error
    };
  }
  return result;
}
async function writeReceivePackRequest({
  capabilities = [],
  triplets = []
}) {
  const packstream = [];
  let capsFirstLine = `\0 ${capabilities.join(" ")}`;
  for (const trip of triplets) {
    packstream.push(
      GitPktLine.encode(
        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}
`
      )
    );
    capsFirstLine = "";
  }
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function _push({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote,
  url: _url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {}
}) {
  const ref = _ref || await _currentBranch({ fs, gitdir });
  if (typeof ref === "undefined") {
    throw new MissingParameterError("ref");
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  remote = remote || await config.get(`branch.${ref}.pushRemote`) || await config.get("remote.pushDefault") || await config.get(`branch.${ref}.remote`) || "origin";
  const url = _url || await config.get(`remote.${remote}.pushurl`) || await config.get(`remote.${remote}.url`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || await config.get(`branch.${ref}.merge`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remoteRef");
  }
  if (corsProxy === void 0) {
    corsProxy = await config.get("http.corsProxy");
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const oid = _delete ? "0000000000000000000000000000000000000000" : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
  const GitRemoteHTTP2 = GitRemoteManager.getRemoteHelperFor({ url });
  const httpRemote = await GitRemoteHTTP2.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-receive-pack",
    url,
    headers,
    protocolVersion: 1
  });
  const auth = httpRemote.auth;
  let fullRemoteRef;
  if (!remoteRef) {
    fullRemoteRef = fullRef;
  } else {
    try {
      fullRemoteRef = await GitRefManager.expandAgainstMap({
        ref: remoteRef,
        map: httpRemote.refs
      });
    } catch (err) {
      if (err instanceof NotFoundError) {
        fullRemoteRef = remoteRef.startsWith("refs/") ? remoteRef : `refs/heads/${remoteRef}`;
      } else {
        throw err;
      }
    }
  }
  const oldoid = httpRemote.refs.get(fullRemoteRef) || "0000000000000000000000000000000000000000";
  const thinPack = !httpRemote.capabilities.has("no-thin");
  let objects = /* @__PURE__ */ new Set();
  if (!_delete) {
    const finish = [...httpRemote.refs.values()];
    let skipObjects = /* @__PURE__ */ new Set();
    if (oldoid !== "0000000000000000000000000000000000000000") {
      const mergebase = await _findMergeBase({
        fs,
        cache,
        gitdir,
        oids: [oid, oldoid]
      });
      for (const oid2 of mergebase)
        finish.push(oid2);
      if (thinPack) {
        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });
      }
    }
    if (!finish.includes(oid)) {
      const commits = await listCommitsAndTags({
        fs,
        cache,
        gitdir,
        start: [oid],
        finish
      });
      objects = await listObjects({ fs, cache, gitdir, oids: commits });
    }
    if (thinPack) {
      try {
        const ref2 = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: `refs/remotes/${remote}/HEAD`,
          depth: 2
        });
        const { oid: oid2 } = await GitRefManager.resolveAgainstMap({
          ref: ref2.replace(`refs/remotes/${remote}/`, ""),
          fullref: ref2,
          map: httpRemote.refs
        });
        const oids = [oid2];
        for (const oid3 of await listObjects({ fs, cache, gitdir, oids })) {
          skipObjects.add(oid3);
        }
      } catch (e6) {
      }
      for (const oid2 of skipObjects) {
        objects.delete(oid2);
      }
    }
    if (oid === oldoid)
      force = true;
    if (!force) {
      if (fullRef.startsWith("refs/tags") && oldoid !== "0000000000000000000000000000000000000000") {
        throw new PushRejectedError("tag-exists");
      }
      if (oid !== "0000000000000000000000000000000000000000" && oldoid !== "0000000000000000000000000000000000000000" && !await _isDescendent({
        fs,
        cache,
        gitdir,
        oid,
        ancestor: oldoid,
        depth: -1
      })) {
        throw new PushRejectedError("not-fast-forward");
      }
    }
  }
  const capabilities = filterCapabilities(
    [...httpRemote.capabilities],
    ["report-status", "side-band-64k", `agent=${pkg.agent}`]
  );
  const packstream1 = await writeReceivePackRequest({
    capabilities,
    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }]
  });
  const packstream2 = _delete ? [] : await _pack({
    fs,
    cache,
    gitdir,
    oids: [...objects]
  });
  const res = await GitRemoteHTTP2.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-receive-pack",
    url,
    auth,
    headers,
    body: [...packstream1, ...packstream2]
  });
  const { packfile, progress } = await GitSideBand.demux(res.body);
  if (onMessage) {
    const lines = splitLines(progress);
    forAwait(lines, async (line) => {
      await onMessage(line);
    });
  }
  const result = await parseReceivePackResponse(packfile);
  if (res.headers) {
    result.headers = res.headers;
  }
  if (remote && result.ok && result.refs[fullRemoteRef].ok) {
    const ref2 = `refs/remotes/${remote}/${fullRemoteRef.replace(
      "refs/heads",
      ""
    )}`;
    if (_delete) {
      await GitRefManager.deleteRef({ fs, gitdir, ref: ref2 });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: ref2, value: oid });
    }
  }
  if (result.ok && Object.values(result.refs).every((result2) => result2.ok)) {
    return result;
  } else {
    const prettyDetails = Object.entries(result.refs).filter(([k2, v2]) => !v2.ok).map(([k2, v2]) => `
  - ${k2}: ${v2.error}`).join("");
    throw new GitPushError(prettyDetails, result);
  }
}
async function push({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  remoteRef,
  remote = "origin",
  url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _push({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remoteRef,
      remote,
      url,
      force,
      delete: _delete,
      corsProxy,
      headers
    });
  } catch (err) {
    err.caller = "git.push";
    throw err;
  }
}
async function resolveBlob({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveBlob({ fs, cache, gitdir, oid });
  }
  if (type !== "blob") {
    throw new ObjectTypeError(oid, type, "blob");
  }
  return { oid, blob: new Uint8Array(object) };
}
async function _readBlob({
  fs,
  cache,
  gitdir,
  oid,
  filepath = void 0
}) {
  if (filepath !== void 0) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const blob = await resolveBlob({
    fs,
    cache,
    gitdir,
    oid
  });
  return blob;
}
async function readBlob({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readBlob({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath
    });
  } catch (err) {
    err.caller = "git.readBlob";
    throw err;
  }
}
async function readCommit({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readCommit({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid
    });
  } catch (err) {
    err.caller = "git.readCommit";
    throw err;
  }
}
async function _readNote({
  fs,
  cache,
  gitdir,
  ref = "refs/notes/commits",
  oid
}) {
  const parent = await GitRefManager.resolve({ gitdir, fs, ref });
  const { blob } = await _readBlob({
    fs,
    cache,
    gitdir,
    oid: parent,
    filepath: oid
  });
  return blob;
}
async function readNote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oid", oid);
    return await _readNote({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
      oid
    });
  } catch (err) {
    err.caller = "git.readNote";
    throw err;
  }
}
async function readObject({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  format = "parsed",
  filepath = void 0,
  encoding = void 0,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    if (filepath !== void 0) {
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath
      });
    }
    const _format = format === "parsed" ? "content" : format;
    const result = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
      format: _format
    });
    result.oid = oid;
    if (format === "parsed") {
      result.format = "parsed";
      switch (result.type) {
        case "commit":
          result.object = GitCommit.from(result.object).parse();
          break;
        case "tree":
          result.object = GitTree.from(result.object).entries();
          break;
        case "blob":
          if (encoding) {
            result.object = result.object.toString(encoding);
          } else {
            result.object = new Uint8Array(result.object);
            result.format = "content";
          }
          break;
        case "tag":
          result.object = GitAnnotatedTag.from(result.object).parse();
          break;
        default:
          throw new ObjectTypeError(
            result.oid,
            result.type,
            "blob|commit|tag|tree"
          );
      }
    } else if (result.format === "deflated" || result.format === "wrapped") {
      result.type = result.format;
    }
    return result;
  } catch (err) {
    err.caller = "git.readObject";
    throw err;
  }
}
async function _readTag({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({
    fs,
    cache,
    gitdir,
    oid,
    format: "content"
  });
  if (type !== "tag") {
    throw new ObjectTypeError(oid, type, "tag");
  }
  const tag2 = GitAnnotatedTag.from(object);
  const result = {
    oid,
    tag: tag2.parse(),
    payload: tag2.payload()
  };
  return result;
}
async function readTag({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTag({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid
    });
  } catch (err) {
    err.caller = "git.readTag";
    throw err;
  }
}
async function readTree({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  filepath = void 0,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTree({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath
    });
  } catch (err) {
    err.caller = "git.readTree";
    throw err;
  }
}
async function remove({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    await GitIndexManager.acquire(
      { fs: new FileSystem(_fs), gitdir, cache },
      async function(index2) {
        index2.delete({ filepath });
      }
    );
  } catch (err) {
    err.caller = "git.remove";
    throw err;
  }
}
async function _removeNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref = "refs/notes/commits",
  oid,
  author,
  committer,
  signingKey
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err;
    }
  }
  const result = await _readTree({
    fs,
    gitdir,
    oid: parent || "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
  });
  let tree = result.tree;
  tree = tree.filter((entry) => entry.path !== oid);
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree
  });
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note removed by 'isomorphic-git removeNote'
`,
    author,
    committer,
    signingKey
  });
  return commitOid;
}
async function removeNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _removeNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      author,
      committer,
      signingKey
    });
  } catch (err) {
    err.caller = "git.removeNote";
    throw err;
  }
}
async function _renameBranch({
  fs,
  gitdir,
  oldref,
  ref,
  checkout: checkout3 = false
}) {
  if (ref !== import_clean_git_ref.default.clean(ref)) {
    throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
  }
  if (oldref !== import_clean_git_ref.default.clean(oldref)) {
    throw new InvalidRefNameError(oldref, import_clean_git_ref.default.clean(oldref));
  }
  const fulloldref = `refs/heads/${oldref}`;
  const fullnewref = `refs/heads/${ref}`;
  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });
  if (newexist) {
    throw new AlreadyExistsError("branch", ref, false);
  }
  const value = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: fulloldref,
    depth: 1
  });
  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });
  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });
  const fullCurrentBranchRef = await _currentBranch({
    fs,
    gitdir,
    fullname: true
  });
  const isCurrentBranch = fullCurrentBranchRef === fulloldref;
  if (checkout3 || isCurrentBranch) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullnewref
    });
  }
}
async function renameBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  oldref,
  checkout: checkout3 = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oldref", oldref);
    return await _renameBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      oldref,
      checkout: checkout3
    });
  } catch (err) {
    err.caller = "git.renameBranch";
    throw err;
  }
}
async function hashObject$1({ gitdir, type, object }) {
  return shasum(GitObject.wrap({ type, object }));
}
async function resetIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  ref,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    let oid;
    let workdirOid;
    try {
      oid = await GitRefManager.resolve({ fs, gitdir, ref: ref || "HEAD" });
    } catch (e6) {
      if (ref) {
        throw e6;
      }
    }
    if (oid) {
      try {
        oid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid,
          filepath
        });
      } catch (e6) {
        oid = null;
      }
    }
    let stats = {
      ctime: /* @__PURE__ */ new Date(0),
      mtime: /* @__PURE__ */ new Date(0),
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0
    };
    const object = dir && await fs.read(join(dir, filepath));
    if (object) {
      workdirOid = await hashObject$1({
        gitdir,
        type: "blob",
        object
      });
      if (oid === workdirOid) {
        stats = await fs.lstat(join(dir, filepath));
      }
    }
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      index2.delete({ filepath });
      if (oid) {
        index2.insert({ filepath, stats, oid });
      }
    });
  } catch (err) {
    err.caller = "git.reset";
    throw err;
  }
}
async function resolveRef({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  depth
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const oid = await GitRefManager.resolve({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      depth
    });
    return oid;
  } catch (err) {
    err.caller = "git.resolveRef";
    throw err;
  }
}
async function setConfig({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  path,
  value,
  append = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    const fs = new FileSystem(_fs);
    const config = await GitConfigManager.get({ fs, gitdir });
    if (append) {
      await config.append(path, value);
    } else {
      await config.set(path, value);
    }
    await GitConfigManager.save({ fs, gitdir, config });
  } catch (err) {
    err.caller = "git.setConfig";
    throw err;
  }
}
async function status({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    const ignored = await GitIgnoreManager.isIgnored({
      fs,
      gitdir,
      dir,
      filepath
    });
    if (ignored) {
      return "ignored";
    }
    const headTree = await getHeadTree({ fs, cache, gitdir });
    const treeOid = await getOidAtPath({
      fs,
      cache,
      gitdir,
      tree: headTree,
      path: filepath
    });
    const indexEntry = await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index2) {
        for (const entry of index2) {
          if (entry.path === filepath)
            return entry;
        }
        return null;
      }
    );
    const stats = await fs.lstat(join(dir, filepath));
    const H = treeOid !== null;
    const I2 = indexEntry !== null;
    const W = stats !== null;
    const getWorkdirOid = async () => {
      if (I2 && !compareStats(indexEntry, stats)) {
        return indexEntry.oid;
      } else {
        const object = await fs.read(join(dir, filepath));
        const workdirOid = await hashObject$1({
          gitdir,
          type: "blob",
          object
        });
        if (I2 && indexEntry.oid === workdirOid) {
          if (stats.size !== -1) {
            GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
              index2.insert({ filepath, stats, oid: workdirOid });
            });
          }
        }
        return workdirOid;
      }
    };
    if (!H && !W && !I2)
      return "absent";
    if (!H && !W && I2)
      return "*absent";
    if (!H && W && !I2)
      return "*added";
    if (!H && W && I2) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === indexEntry.oid ? "added" : "*added";
    }
    if (H && !W && !I2)
      return "deleted";
    if (H && !W && I2) {
      return treeOid === indexEntry.oid ? "*deleted" : "*deleted";
    }
    if (H && W && !I2) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === treeOid ? "*undeleted" : "*undeletemodified";
    }
    if (H && W && I2) {
      const workdirOid = await getWorkdirOid();
      if (workdirOid === treeOid) {
        return workdirOid === indexEntry.oid ? "unmodified" : "*unmodified";
      } else {
        return workdirOid === indexEntry.oid ? "modified" : "*modified";
      }
    }
  } catch (err) {
    err.caller = "git.status";
    throw err;
  }
}
async function getOidAtPath({ fs, cache, gitdir, tree, path }) {
  if (typeof path === "string")
    path = path.split("/");
  const dirname2 = path.shift();
  for (const entry of tree) {
    if (entry.path === dirname2) {
      if (path.length === 0) {
        return entry.oid;
      }
      const { type, object } = await _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid
      });
      if (type === "tree") {
        const tree2 = GitTree.from(object);
        return getOidAtPath({ fs, cache, gitdir, tree: tree2, path });
      }
      if (type === "blob") {
        throw new ObjectTypeError(entry.oid, type, "blob", path.join("/"));
      }
    }
  }
  return null;
}
async function getHeadTree({ fs, cache, gitdir }) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: "HEAD" });
  } catch (e6) {
    if (e6 instanceof NotFoundError) {
      return [];
    }
  }
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  return tree;
}
async function statusMatrix({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "HEAD",
  filepaths = ["."],
  filter,
  cache = {},
  ignored: shouldIgnore = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    return await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees: [TREE({ ref }), WORKDIR(), STAGE()],
      map: async function(filepath, [head, workdir, stage]) {
        if (!head && !stage && workdir) {
          if (!shouldIgnore) {
            const isIgnored3 = await GitIgnoreManager.isIgnored({
              fs,
              dir,
              filepath
            });
            if (isIgnored3) {
              return null;
            }
          }
        }
        if (!filepaths.some((base) => worthWalking(filepath, base))) {
          return null;
        }
        if (filter) {
          if (!filter(filepath))
            return;
        }
        const [headType, workdirType, stageType] = await Promise.all([
          head && head.type(),
          workdir && workdir.type(),
          stage && stage.type()
        ]);
        const isBlob = [headType, workdirType, stageType].includes("blob");
        if ((headType === "tree" || headType === "special") && !isBlob)
          return;
        if (headType === "commit")
          return null;
        if ((workdirType === "tree" || workdirType === "special") && !isBlob)
          return;
        if (stageType === "commit")
          return null;
        if ((stageType === "tree" || stageType === "special") && !isBlob)
          return;
        const headOid = headType === "blob" ? await head.oid() : void 0;
        const stageOid = stageType === "blob" ? await stage.oid() : void 0;
        let workdirOid;
        if (headType !== "blob" && workdirType === "blob" && stageType !== "blob") {
          workdirOid = "42";
        } else if (workdirType === "blob") {
          workdirOid = await workdir.oid();
        }
        const entry = [void 0, headOid, workdirOid, stageOid];
        const result = entry.map((value) => entry.indexOf(value));
        result.shift();
        return [filepath, ...result];
      }
    });
  } catch (err) {
    err.caller = "git.statusMatrix";
    throw err;
  }
}
async function tag({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  object,
  force = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    if (ref === void 0) {
      throw new MissingParameterError("ref");
    }
    ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
    const value = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: object || "HEAD"
    });
    if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
      throw new AlreadyExistsError("tag", ref);
    }
    await GitRefManager.writeRef({ fs, gitdir, ref, value });
  } catch (err) {
    err.caller = "git.tag";
    throw err;
  }
}
async function updateIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  cache = {},
  filepath,
  oid,
  mode,
  add: add3,
  remove: remove3,
  force
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    if (remove3) {
      return await GitIndexManager.acquire(
        { fs, gitdir, cache },
        async function(index2) {
          let fileStats2;
          if (!force) {
            fileStats2 = await fs.lstat(join(dir, filepath));
            if (fileStats2) {
              if (fileStats2.isDirectory()) {
                throw new InvalidFilepathError("directory");
              }
              return;
            }
          }
          if (index2.has({ filepath })) {
            index2.delete({
              filepath
            });
          }
        }
      );
    }
    let fileStats;
    if (!oid) {
      fileStats = await fs.lstat(join(dir, filepath));
      if (!fileStats) {
        throw new NotFoundError(
          `file at "${filepath}" on disk and "remove" not set`
        );
      }
      if (fileStats.isDirectory()) {
        throw new InvalidFilepathError("directory");
      }
    }
    return await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
      if (!add3 && !index2.has({ filepath })) {
        throw new NotFoundError(
          `file at "${filepath}" in index and "add" not set`
        );
      }
      let stats = {
        ctime: /* @__PURE__ */ new Date(0),
        mtime: /* @__PURE__ */ new Date(0),
        dev: 0,
        ino: 0,
        mode,
        uid: 0,
        gid: 0,
        size: 0
      };
      if (!oid) {
        stats = fileStats;
        const object = stats.isSymbolicLink() ? await fs.readlink(join(dir, filepath)) : await fs.read(join(dir, filepath));
        oid = await _writeObject({
          fs,
          gitdir,
          type: "blob",
          format: "content",
          object
        });
      }
      index2.insert({
        filepath,
        oid,
        stats
      });
      return oid;
    });
  } catch (err) {
    err.caller = "git.updateIndex";
    throw err;
  }
}
function version() {
  try {
    return pkg.version;
  } catch (err) {
    err.caller = "git.version";
    throw err;
  }
}
async function walk({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  trees,
  map,
  reduce,
  iterate,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("trees", trees);
    return await _walk({
      fs: new FileSystem(fs),
      cache,
      dir,
      gitdir,
      trees,
      map,
      reduce,
      iterate
    });
  } catch (err) {
    err.caller = "git.walk";
    throw err;
  }
}
async function writeBlob({ fs, dir, gitdir = join(dir, ".git"), blob }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("blob", blob);
    return await _writeObject({
      fs: new FileSystem(fs),
      gitdir,
      type: "blob",
      object: blob,
      format: "content"
    });
  } catch (err) {
    err.caller = "git.writeBlob";
    throw err;
  }
}
async function _writeCommit({ fs, gitdir, commit: commit3 }) {
  const object = GitCommit.from(commit3).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "commit",
    object,
    format: "content"
  });
  return oid;
}
async function writeCommit({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  commit: commit3
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("commit", commit3);
    return await _writeCommit({
      fs: new FileSystem(fs),
      gitdir,
      commit: commit3
    });
  } catch (err) {
    err.caller = "git.writeCommit";
    throw err;
  }
}
async function writeObject({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  type,
  object,
  format = "parsed",
  oid,
  encoding = void 0
}) {
  try {
    const fs = new FileSystem(_fs);
    if (format === "parsed") {
      switch (type) {
        case "commit":
          object = GitCommit.from(object).toObject();
          break;
        case "tree":
          object = GitTree.from(object).toObject();
          break;
        case "blob":
          object = Buffer.from(object, encoding);
          break;
        case "tag":
          object = GitAnnotatedTag.from(object).toObject();
          break;
        default:
          throw new ObjectTypeError(oid || "", type, "blob|commit|tag|tree");
      }
      format = "content";
    }
    oid = await _writeObject({
      fs,
      gitdir,
      type,
      object,
      oid,
      format
    });
    return oid;
  } catch (err) {
    err.caller = "git.writeObject";
    throw err;
  }
}
async function writeRef({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  value,
  force = false,
  symbolic = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("value", value);
    const fs = new FileSystem(_fs);
    if (ref !== import_clean_git_ref.default.clean(ref)) {
      throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
    }
    if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
      throw new AlreadyExistsError("ref", ref);
    }
    if (symbolic) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref,
        value
      });
    } else {
      value = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: value
      });
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value
      });
    }
  } catch (err) {
    err.caller = "git.writeRef";
    throw err;
  }
}
async function _writeTag({ fs, gitdir, tag: tag2 }) {
  const object = GitAnnotatedTag.from(tag2).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object,
    format: "content"
  });
  return oid;
}
async function writeTag({ fs, dir, gitdir = join(dir, ".git"), tag: tag2 }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tag", tag2);
    return await _writeTag({
      fs: new FileSystem(fs),
      gitdir,
      tag: tag2
    });
  } catch (err) {
    err.caller = "git.writeTag";
    throw err;
  }
}
async function writeTree({ fs, dir, gitdir = join(dir, ".git"), tree }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tree", tree);
    return await _writeTree({
      fs: new FileSystem(fs),
      gitdir,
      tree
    });
  } catch (err) {
    err.caller = "git.writeTree";
    throw err;
  }
}
async function writeRefsAdResponse({ capabilities, refs, symrefs }) {
  const stream = [];
  let syms = "";
  for (const [key, value] of Object.entries(symrefs)) {
    syms += `symref=${key}:${value} `;
  }
  let caps = `\0${[...capabilities].join(" ")} ${syms}agent=${pkg.agent}`;
  for (const [key, value] of Object.entries(refs)) {
    stream.push(GitPktLine.encode(`${value} ${key}${caps}
`));
    caps = "";
  }
  stream.push(GitPktLine.flush());
  return stream;
}
async function uploadPack({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  advertiseRefs = false
}) {
  try {
    if (advertiseRefs) {
      const capabilities = [
        "thin-pack",
        "side-band",
        "side-band-64k",
        "shallow",
        "deepen-since",
        "deepen-not",
        "allow-tip-sha1-in-want",
        "allow-reachable-sha1-in-want"
      ];
      let keys = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: "refs"
      });
      keys = keys.map((ref) => `refs/${ref}`);
      const refs = {};
      keys.unshift("HEAD");
      for (const key of keys) {
        refs[key] = await GitRefManager.resolve({ fs, gitdir, ref: key });
      }
      const symrefs = {};
      symrefs.HEAD = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: "HEAD",
        depth: 2
      });
      return writeRefsAdResponse({
        capabilities,
        refs,
        symrefs
      });
    }
  } catch (err) {
    err.caller = "git.uploadPack";
    throw err;
  }
}
function fromEntries(map) {
  const o5 = {};
  for (const [key, value] of map) {
    o5[key] = value;
  }
  return o5;
}
function fromNodeStream(stream) {
  const asyncIterator = Object.getOwnPropertyDescriptor(
    stream,
    Symbol.asyncIterator
  );
  if (asyncIterator && asyncIterator.enumerable) {
    return stream;
  }
  let ended = false;
  const queue = [];
  let defer = {};
  stream.on("data", (chunk) => {
    queue.push(chunk);
    if (defer.resolve) {
      defer.resolve({ value: queue.shift(), done: false });
      defer = {};
    }
  });
  stream.on("error", (err) => {
    if (defer.reject) {
      defer.reject(err);
      defer = {};
    }
  });
  stream.on("end", () => {
    ended = true;
    if (defer.resolve) {
      defer.resolve({ done: true });
      defer = {};
    }
  });
  return {
    next() {
      return new Promise((resolve, reject) => {
        if (queue.length === 0 && ended) {
          return resolve({ done: true });
        } else if (queue.length > 0) {
          return resolve({ value: queue.shift(), done: false });
        } else if (queue.length === 0 && !ended) {
          defer = { resolve, reject };
        }
      });
    },
    return() {
      stream.removeAllListeners();
      if (stream.destroy)
        stream.destroy();
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function fromStream(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    next() {
      return reader.read();
    },
    return() {
      reader.releaseLock();
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function isBinary(buffer) {
  const MAX_XDIFF_SIZE = 1024 * 1024 * 1023;
  if (buffer.length > MAX_XDIFF_SIZE)
    return true;
  return buffer.slice(0, 8e3).some((value) => value === 0);
}
async function sleep(ms) {
  return new Promise((resolve, reject) => setTimeout(resolve, ms));
}
async function parseUploadPackRequest(stream) {
  const read = GitPktLine.streamReader(stream);
  let done = false;
  let capabilities = null;
  const wants = [];
  const haves = [];
  const shallows = [];
  let depth;
  let since;
  const exclude = [];
  let relative = false;
  while (!done) {
    const line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    const [key, value, ...rest] = line.toString("utf8").trim().split(" ");
    if (!capabilities)
      capabilities = rest;
    switch (key) {
      case "want":
        wants.push(value);
        break;
      case "have":
        haves.push(value);
        break;
      case "shallow":
        shallows.push(value);
        break;
      case "deepen":
        depth = parseInt(value);
        break;
      case "deepen-since":
        since = parseInt(value);
        break;
      case "deepen-not":
        exclude.push(value);
        break;
      case "deepen-relative":
        relative = true;
        break;
      case "done":
        done = true;
        break;
    }
  }
  return {
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude,
    relative,
    done
  };
}
var import_async_lock, import_sha1, import_crc_32, import_pako, import_pify, import_ignore, import_clean_git_ref, BaseError, UnmergedPathsError, InternalError, UnsafeFilepathError, BufferCursor, MAX_UINT32, supportsSubtleSHA1, GitIndex, lock, IndexCache, GitIndexManager, GitWalkerIndex, GitWalkSymbol, NotFoundError, ObjectTypeError, InvalidOidError, NoRefspecError, GitPackedRefs, GitRefSpec, GitRefSpecSet, memo, num, bool, schema, SECTION_LINE_REGEX, SECTION_REGEX, VARIABLE_LINE_REGEX, VARIABLE_NAME_REGEX, VARIABLE_VALUE_COMMENT_REGEX, extractSectionLine, extractVariableLine, removeComments, hasOddNumberOfQuotes, removeQuotes, lower, getPath, normalizePath$1, findLastIndex, GitConfig, GitConfigManager, refpaths, GIT_FILES, lock$1, GitRefManager, GitTree, GitObject, StreamReader, supportsDecompressionStream, GitPackIndex, PackfileCache, AlreadyExistsError, AmbiguousError, CheckoutConflictError, CommitNotFetchedError, EmptyServerResponseError, FastForwardError, GitPushError, HttpError, InvalidFilepathError, InvalidRefNameError, MaxDepthError, MergeNotSupportedError, MergeConflictError, MissingNameError, MissingParameterError, MultipleGitError, ParseError, PushRejectedError, RemoteCapabilityError, SmartHttpError, UnknownTransportError, UrlParseError, UserCanceledError, IndexResetError, Errors, GitAnnotatedTag, GitCommit, GitWalkerRepo, GitWalkerFs, flat, RunningMinimum, commands, FileSystem, GitIgnoreManager, supportsCompressionStream, worthWalking, abbreviateRx, GitPktLine, corsProxify, updateHeaders, stringifyBody, GitRemoteHTTP, GitRemoteManager, lock$2, GitShallowManager, pkg, FIFO, GitSideBand, LINEBREAKS, EMPTY_OID, types, deepget, DeepMap, index, isomorphic_git_default;
var init_isomorphic_git = __esm({
  "../../../lix/packages/client/vendored/isomorphic-git/index.js"() {
    "use strict";
    import_async_lock = __toESM(require_async_lock(), 1);
    import_sha1 = __toESM(require_sha1(), 1);
    import_crc_32 = __toESM(require_crc32(), 1);
    import_pako = __toESM(require_pako(), 1);
    import_pify = __toESM(require_pify(), 1);
    import_ignore = __toESM(require_ignore(), 1);
    import_clean_git_ref = __toESM(require_lib2(), 1);
    init_diff3();
    BaseError = class _BaseError extends Error {
      constructor(message) {
        super(message);
        this.caller = "";
      }
      toJSON() {
        return {
          code: this.code,
          data: this.data,
          caller: this.caller,
          message: this.message,
          stack: this.stack
        };
      }
      fromJSON(json) {
        const e6 = new _BaseError(json.message);
        e6.code = json.code;
        e6.data = json.data;
        e6.caller = json.caller;
        e6.stack = json.stack;
        return e6;
      }
      get isIsomorphicGitError() {
        return true;
      }
    };
    UnmergedPathsError = class _UnmergedPathsError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepaths) {
        super(
          `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
        );
        this.code = this.name = _UnmergedPathsError.code;
        this.data = { filepaths };
      }
    };
    UnmergedPathsError.code = "UnmergedPathsError";
    InternalError = class _InternalError extends BaseError {
      /**
       * @param {string} message
       */
      constructor(message) {
        super(
          `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
        );
        this.code = this.name = _InternalError.code;
        this.data = { message };
      }
    };
    InternalError.code = "InternalError";
    UnsafeFilepathError = class _UnsafeFilepathError extends BaseError {
      /**
       * @param {string} filepath
       */
      constructor(filepath) {
        super(`The filepath "${filepath}" contains unsafe character sequences`);
        this.code = this.name = _UnsafeFilepathError.code;
        this.data = { filepath };
      }
    };
    UnsafeFilepathError.code = "UnsafeFilepathError";
    BufferCursor = class {
      constructor(buffer) {
        this.buffer = buffer;
        this._start = 0;
      }
      eof() {
        return this._start >= this.buffer.length;
      }
      tell() {
        return this._start;
      }
      seek(n5) {
        this._start = n5;
      }
      slice(n5) {
        const r6 = this.buffer.slice(this._start, this._start + n5);
        this._start += n5;
        return r6;
      }
      toString(enc, length) {
        const r6 = this.buffer.toString(enc, this._start, this._start + length);
        this._start += length;
        return r6;
      }
      write(value, length, enc) {
        const r6 = this.buffer.write(value, this._start, length, enc);
        this._start += length;
        return r6;
      }
      copy(source, start, end) {
        const r6 = source.copy(this.buffer, this._start, start, end);
        this._start += r6;
        return r6;
      }
      readUInt8() {
        const r6 = this.buffer.readUInt8(this._start);
        this._start += 1;
        return r6;
      }
      writeUInt8(value) {
        const r6 = this.buffer.writeUInt8(value, this._start);
        this._start += 1;
        return r6;
      }
      readUInt16BE() {
        const r6 = this.buffer.readUInt16BE(this._start);
        this._start += 2;
        return r6;
      }
      writeUInt16BE(value) {
        const r6 = this.buffer.writeUInt16BE(value, this._start);
        this._start += 2;
        return r6;
      }
      readUInt32BE() {
        const r6 = this.buffer.readUInt32BE(this._start);
        this._start += 4;
        return r6;
      }
      writeUInt32BE(value) {
        const r6 = this.buffer.writeUInt32BE(value, this._start);
        this._start += 4;
        return r6;
      }
    };
    MAX_UINT32 = 2 ** 32;
    supportsSubtleSHA1 = null;
    GitIndex = class _GitIndex {
      /*::
       _entries: Map<string, CacheEntry>
       _dirty: boolean // Used to determine if index needs to be saved to filesystem
       */
      constructor(entries, unmergedPaths) {
        this._dirty = false;
        this._unmergedPaths = unmergedPaths || /* @__PURE__ */ new Set();
        this._entries = entries || /* @__PURE__ */ new Map();
      }
      _addEntry(entry) {
        if (entry.flags.stage === 0) {
          entry.stages = [entry];
          this._entries.set(entry.path, entry);
          this._unmergedPaths.delete(entry.path);
        } else {
          let existingEntry = this._entries.get(entry.path);
          if (!existingEntry) {
            this._entries.set(entry.path, entry);
            existingEntry = entry;
          }
          existingEntry.stages[entry.flags.stage] = entry;
          this._unmergedPaths.add(entry.path);
        }
      }
      static async from(buffer) {
        if (Buffer.isBuffer(buffer)) {
          return _GitIndex.fromBuffer(buffer);
        } else if (buffer === null) {
          return new _GitIndex(null);
        } else {
          throw new InternalError("invalid type passed to GitIndex.from");
        }
      }
      static async fromBuffer(buffer) {
        if (buffer.length === 0) {
          throw new InternalError("Index file is empty (.git/index)");
        }
        const index2 = new _GitIndex();
        const reader = new BufferCursor(buffer);
        const magic = reader.toString("utf8", 4);
        if (magic !== "DIRC") {
          throw new InternalError(`Invalid dircache magic file number: ${magic}`);
        }
        const shaComputed = await shasum(buffer.slice(0, -20));
        const shaClaimed = buffer.slice(-20).toString("hex");
        if (shaClaimed !== shaComputed) {
          throw new InternalError(
            `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
          );
        }
        const version3 = reader.readUInt32BE();
        if (version3 !== 2) {
          throw new InternalError(`Unsupported dircache version: ${version3}`);
        }
        const numEntries = reader.readUInt32BE();
        let i4 = 0;
        while (!reader.eof() && i4 < numEntries) {
          const entry = {};
          entry.ctimeSeconds = reader.readUInt32BE();
          entry.ctimeNanoseconds = reader.readUInt32BE();
          entry.mtimeSeconds = reader.readUInt32BE();
          entry.mtimeNanoseconds = reader.readUInt32BE();
          entry.dev = reader.readUInt32BE();
          entry.ino = reader.readUInt32BE();
          entry.mode = reader.readUInt32BE();
          entry.uid = reader.readUInt32BE();
          entry.gid = reader.readUInt32BE();
          entry.size = reader.readUInt32BE();
          entry.oid = reader.slice(20).toString("hex");
          const flags = reader.readUInt16BE();
          entry.flags = parseCacheEntryFlags(flags);
          const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();
          if (pathlength < 1) {
            throw new InternalError(`Got a path length of: ${pathlength}`);
          }
          entry.path = reader.toString("utf8", pathlength);
          if (entry.path.includes("..\\") || entry.path.includes("../")) {
            throw new UnsafeFilepathError(entry.path);
          }
          let padding = 8 - (reader.tell() - 12) % 8;
          if (padding === 0)
            padding = 8;
          while (padding--) {
            const tmp = reader.readUInt8();
            if (tmp !== 0) {
              throw new InternalError(
                `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
              );
            } else if (reader.eof()) {
              throw new InternalError("Unexpected end of file");
            }
          }
          entry.stages = [];
          index2._addEntry(entry);
          i4++;
        }
        return index2;
      }
      get unmergedPaths() {
        return [...this._unmergedPaths];
      }
      get entries() {
        return [...this._entries.values()].sort(comparePath);
      }
      get entriesMap() {
        return this._entries;
      }
      get entriesFlat() {
        return [...this.entries].flatMap((entry) => {
          return entry.stages.length > 1 ? entry.stages.filter((x2) => x2) : entry;
        });
      }
      *[Symbol.iterator]() {
        for (const entry of this.entries) {
          yield entry;
        }
      }
      insert({ filepath, stats, oid, stage = 0 }) {
        if (!stats) {
          stats = {
            ctimeSeconds: 0,
            ctimeNanoseconds: 0,
            mtimeSeconds: 0,
            mtimeNanoseconds: 0,
            dev: 0,
            ino: 0,
            mode: 0,
            uid: 0,
            gid: 0,
            size: 0
          };
        }
        stats = normalizeStats(stats);
        const bfilepath = Buffer.from(filepath);
        const entry = {
          ctimeSeconds: stats.ctimeSeconds,
          ctimeNanoseconds: stats.ctimeNanoseconds,
          mtimeSeconds: stats.mtimeSeconds,
          mtimeNanoseconds: stats.mtimeNanoseconds,
          dev: stats.dev,
          ino: stats.ino,
          // We provide a fallback value for `mode` here because not all fs
          // implementations assign it, but we use it in GitTree.
          // '100644' is for a "regular non-executable file"
          mode: stats.mode || 33188,
          uid: stats.uid,
          gid: stats.gid,
          size: stats.size,
          path: filepath,
          oid,
          flags: {
            assumeValid: false,
            extended: false,
            stage,
            nameLength: bfilepath.length < 4095 ? bfilepath.length : 4095
          },
          stages: []
        };
        this._addEntry(entry);
        this._dirty = true;
      }
      delete({ filepath }) {
        if (this._entries.has(filepath)) {
          this._entries.delete(filepath);
        } else {
          for (const key of this._entries.keys()) {
            if (key.startsWith(filepath + "/")) {
              this._entries.delete(key);
            }
          }
        }
        if (this._unmergedPaths.has(filepath)) {
          this._unmergedPaths.delete(filepath);
        }
        this._dirty = true;
      }
      clear() {
        this._entries.clear();
        this._dirty = true;
      }
      has({ filepath }) {
        return this._entries.has(filepath);
      }
      render() {
        return this.entries.map((entry) => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`).join("\n");
      }
      static async _entryToBuffer(entry) {
        const bpath = Buffer.from(entry.path);
        const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
        const written = Buffer.alloc(length);
        const writer = new BufferCursor(written);
        const stat = normalizeStats(entry);
        writer.writeUInt32BE(stat.ctimeSeconds);
        writer.writeUInt32BE(stat.ctimeNanoseconds);
        writer.writeUInt32BE(stat.mtimeSeconds);
        writer.writeUInt32BE(stat.mtimeNanoseconds);
        writer.writeUInt32BE(stat.dev);
        writer.writeUInt32BE(stat.ino);
        writer.writeUInt32BE(stat.mode);
        writer.writeUInt32BE(stat.uid);
        writer.writeUInt32BE(stat.gid);
        writer.writeUInt32BE(stat.size);
        writer.write(entry.oid, 20, "hex");
        writer.writeUInt16BE(renderCacheEntryFlags(entry));
        writer.write(entry.path, bpath.length, "utf8");
        return written;
      }
      async toObject() {
        const header = Buffer.alloc(12);
        const writer = new BufferCursor(header);
        writer.write("DIRC", 4, "utf8");
        writer.writeUInt32BE(2);
        writer.writeUInt32BE(this.entriesFlat.length);
        let entryBuffers = [];
        for (const entry of this.entries) {
          entryBuffers.push(_GitIndex._entryToBuffer(entry));
          if (entry.stages.length > 1) {
            for (const stage of entry.stages) {
              if (stage && stage !== entry) {
                entryBuffers.push(_GitIndex._entryToBuffer(stage));
              }
            }
          }
        }
        entryBuffers = await Promise.all(entryBuffers);
        const body = Buffer.concat(entryBuffers);
        const main = Buffer.concat([header, body]);
        const sum = await shasum(main);
        return Buffer.concat([main, Buffer.from(sum, "hex")]);
      }
    };
    lock = null;
    IndexCache = Symbol("IndexCache");
    GitIndexManager = class {
      /**
       *
       * @param {object} opts
       * @param {import('../models/FileSystem.js').FileSystem} opts.fs
       * @param {string} opts.gitdir
       * @param {object} opts.cache
       * @param {bool} opts.allowUnmerged
       * @param {function(GitIndex): any} closure
       */
      static async acquire({ fs, gitdir, cache, allowUnmerged = true }, closure) {
        if (!cache[IndexCache])
          cache[IndexCache] = createCache();
        const filepath = `${gitdir}/index`;
        if (lock === null)
          lock = new import_async_lock.default({ maxPending: Infinity });
        let result;
        let unmergedPaths = [];
        await lock.acquire(filepath, async () => {
          if (await isIndexStale(fs, filepath, cache[IndexCache])) {
            await updateCachedIndexFile(fs, filepath, cache[IndexCache]);
          }
          const index2 = cache[IndexCache].map.get(filepath);
          unmergedPaths = index2.unmergedPaths;
          if (unmergedPaths.length && !allowUnmerged)
            throw new UnmergedPathsError(unmergedPaths);
          result = await closure(index2);
          if (index2._dirty) {
            const buffer = await index2.toObject();
            await fs.write(filepath, buffer);
            cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));
            index2._dirty = false;
          }
        });
        return result;
      }
    };
    GitWalkerIndex = class {
      constructor({ fs, gitdir, cache }) {
        this.treePromise = GitIndexManager.acquire(
          { fs, gitdir, cache },
          async function(index2) {
            return flatFileListToDirectoryStructure(index2.entries);
          }
        );
        const walker = this;
        this.ConstructEntry = class StageEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const tree = await this.treePromise;
        const inode = tree.get(filepath);
        if (!inode)
          return null;
        if (inode.type === "blob")
          return null;
        if (inode.type !== "tree") {
          throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);
        }
        const names = inode.children.map((inode2) => inode2.fullpath);
        names.sort(compareStrings);
        return names;
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          if (!inode) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          const stats = inode.type === "tree" ? {} : normalizeStats(inode.metadata);
          entry._type = inode.type === "tree" ? "tree" : mode2type(stats.mode);
          entry._mode = stats.mode;
          if (inode.type === "tree") {
            entry._stat = void 0;
          } else {
            entry._stat = stats;
          }
        }
        return entry._stat;
      }
      async content(_entry) {
      }
      async oid(entry) {
        if (entry._oid === false) {
          const tree = await this.treePromise;
          const inode = tree.get(entry._fullpath);
          entry._oid = inode.metadata.oid;
        }
        return entry._oid;
      }
    };
    GitWalkSymbol = Symbol("GitWalkSymbol");
    NotFoundError = class _NotFoundError extends BaseError {
      /**
       * @param {string} what
       */
      constructor(what) {
        super(`Could not find ${what}.`);
        this.code = this.name = _NotFoundError.code;
        this.data = { what };
      }
    };
    NotFoundError.code = "NotFoundError";
    ObjectTypeError = class _ObjectTypeError extends BaseError {
      /**
       * @param {string} oid
       * @param {'blob'|'commit'|'tag'|'tree'} actual
       * @param {'blob'|'commit'|'tag'|'tree'} expected
       * @param {string} [filepath]
       */
      constructor(oid, actual, expected, filepath) {
        super(
          `Object ${oid} ${filepath ? `at ${filepath}` : ""}was anticipated to be a ${expected} but it is a ${actual}.`
        );
        this.code = this.name = _ObjectTypeError.code;
        this.data = { oid, actual, expected, filepath };
      }
    };
    ObjectTypeError.code = "ObjectTypeError";
    InvalidOidError = class _InvalidOidError extends BaseError {
      /**
       * @param {string} value
       */
      constructor(value) {
        super(`Expected a 40-char hex object id but saw "${value}".`);
        this.code = this.name = _InvalidOidError.code;
        this.data = { value };
      }
    };
    InvalidOidError.code = "InvalidOidError";
    NoRefspecError = class _NoRefspecError extends BaseError {
      /**
       * @param {string} remote
       */
      constructor(remote) {
        super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
	fetch = +refs/heads/*:refs/remotes/origin/*
`);
        this.code = this.name = _NoRefspecError.code;
        this.data = { remote };
      }
    };
    NoRefspecError.code = "NoRefspecError";
    GitPackedRefs = class _GitPackedRefs {
      constructor(text) {
        this.refs = /* @__PURE__ */ new Map();
        this.parsedConfig = [];
        if (text) {
          let key = null;
          this.parsedConfig = text.trim().split("\n").map((line) => {
            if (/^\s*#/.test(line)) {
              return { line, comment: true };
            }
            const i4 = line.indexOf(" ");
            if (line.startsWith("^")) {
              const value = line.slice(1);
              this.refs.set(key + "^{}", value);
              return { line, ref: key, peeled: value };
            } else {
              const value = line.slice(0, i4);
              key = line.slice(i4 + 1);
              this.refs.set(key, value);
              return { line, ref: key, oid: value };
            }
          });
        }
        return this;
      }
      static from(text) {
        return new _GitPackedRefs(text);
      }
      delete(ref) {
        this.parsedConfig = this.parsedConfig.filter((entry) => entry.ref !== ref);
        this.refs.delete(ref);
      }
      toString() {
        return this.parsedConfig.map(({ line }) => line).join("\n") + "\n";
      }
    };
    GitRefSpec = class _GitRefSpec {
      constructor({ remotePath, localPath, force, matchPrefix }) {
        Object.assign(this, {
          remotePath,
          localPath,
          force,
          matchPrefix
        });
      }
      static from(refspec) {
        const [
          forceMatch,
          remotePath,
          remoteGlobMatch,
          localPath,
          localGlobMatch
        ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
        const force = forceMatch === "+";
        const remoteIsGlob = remoteGlobMatch === "*";
        const localIsGlob = localGlobMatch === "*";
        if (remoteIsGlob !== localIsGlob) {
          throw new InternalError("Invalid refspec");
        }
        return new _GitRefSpec({
          remotePath,
          localPath,
          force,
          matchPrefix: remoteIsGlob
        });
      }
      translate(remoteBranch) {
        if (this.matchPrefix) {
          if (remoteBranch.startsWith(this.remotePath)) {
            return this.localPath + remoteBranch.replace(this.remotePath, "");
          }
        } else {
          if (remoteBranch === this.remotePath)
            return this.localPath;
        }
        return null;
      }
      reverseTranslate(localBranch) {
        if (this.matchPrefix) {
          if (localBranch.startsWith(this.localPath)) {
            return this.remotePath + localBranch.replace(this.localPath, "");
          }
        } else {
          if (localBranch === this.localPath)
            return this.remotePath;
        }
        return null;
      }
    };
    GitRefSpecSet = class _GitRefSpecSet {
      constructor(rules = []) {
        this.rules = rules;
      }
      static from(refspecs) {
        const rules = [];
        for (const refspec of refspecs) {
          rules.push(GitRefSpec.from(refspec));
        }
        return new _GitRefSpecSet(rules);
      }
      add(refspec) {
        const rule = GitRefSpec.from(refspec);
        this.rules.push(rule);
      }
      translate(remoteRefs) {
        const result = [];
        for (const rule of this.rules) {
          for (const remoteRef of remoteRefs) {
            const localRef = rule.translate(remoteRef);
            if (localRef) {
              result.push([remoteRef, localRef]);
            }
          }
        }
        return result;
      }
      translateOne(remoteRef) {
        let result = null;
        for (const rule of this.rules) {
          const localRef = rule.translate(remoteRef);
          if (localRef) {
            result = localRef;
          }
        }
        return result;
      }
      localNamespaces() {
        return this.rules.filter((rule) => rule.matchPrefix).map((rule) => rule.localPath.replace(/\/$/, ""));
      }
    };
    memo = /* @__PURE__ */ new Map();
    num = (val) => {
      val = val.toLowerCase();
      let n5 = parseInt(val);
      if (val.endsWith("k"))
        n5 *= 1024;
      if (val.endsWith("m"))
        n5 *= 1024 * 1024;
      if (val.endsWith("g"))
        n5 *= 1024 * 1024 * 1024;
      return n5;
    };
    bool = (val) => {
      val = val.trim().toLowerCase();
      if (val === "true" || val === "yes" || val === "on")
        return true;
      if (val === "false" || val === "no" || val === "off")
        return false;
      throw Error(
        `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
      );
    };
    schema = {
      core: {
        filemode: bool,
        bare: bool,
        logallrefupdates: bool,
        symlinks: bool,
        ignorecase: bool,
        bigFileThreshold: num
      }
    };
    SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
    SECTION_REGEX = /^[A-Za-z0-9-.]+$/;
    VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
    VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;
    VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;
    extractSectionLine = (line) => {
      const matches = SECTION_LINE_REGEX.exec(line);
      if (matches != null) {
        const [section, subsection] = matches.slice(1);
        return [section, subsection];
      }
      return null;
    };
    extractVariableLine = (line) => {
      const matches = VARIABLE_LINE_REGEX.exec(line);
      if (matches != null) {
        const [name, rawValue = "true"] = matches.slice(1);
        const valueWithoutComments = removeComments(rawValue);
        const valueWithoutQuotes = removeQuotes(valueWithoutComments);
        return [name, valueWithoutQuotes];
      }
      return null;
    };
    removeComments = (rawValue) => {
      const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
      if (commentMatches == null) {
        return rawValue;
      }
      const [valueWithoutComment, comment] = commentMatches.slice(1);
      if (hasOddNumberOfQuotes(valueWithoutComment) && hasOddNumberOfQuotes(comment)) {
        return `${valueWithoutComment}${comment}`;
      }
      return valueWithoutComment;
    };
    hasOddNumberOfQuotes = (text) => {
      const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
      return numberOfQuotes % 2 !== 0;
    };
    removeQuotes = (text) => {
      return text.split("").reduce((newText, c4, idx, text2) => {
        const isQuote = c4 === '"' && text2[idx - 1] !== "\\";
        const isEscapeForQuote = c4 === "\\" && text2[idx + 1] === '"';
        if (isQuote || isEscapeForQuote) {
          return newText;
        }
        return newText + c4;
      }, "");
    };
    lower = (text) => {
      return text != null ? text.toLowerCase() : null;
    };
    getPath = (section, subsection, name) => {
      return [lower(section), subsection, lower(name)].filter((a2) => a2 != null).join(".");
    };
    normalizePath$1 = (path) => {
      const pathSegments = path.split(".");
      const section = pathSegments.shift();
      const name = pathSegments.pop();
      const subsection = pathSegments.length ? pathSegments.join(".") : void 0;
      return {
        section,
        subsection,
        name,
        path: getPath(section, subsection, name),
        sectionPath: getPath(section, subsection, null)
      };
    };
    findLastIndex = (array, callback) => {
      return array.reduce((lastIndex, item, index2) => {
        return callback(item) ? index2 : lastIndex;
      }, -1);
    };
    GitConfig = class _GitConfig {
      constructor(text) {
        let section = null;
        let subsection = null;
        this.parsedConfig = text.split("\n").map((line) => {
          let name = null;
          let value = null;
          const trimmedLine = line.trim();
          const extractedSection = extractSectionLine(trimmedLine);
          const isSection = extractedSection != null;
          if (isSection) {
            ;
            [section, subsection] = extractedSection;
          } else {
            const extractedVariable = extractVariableLine(trimmedLine);
            const isVariable = extractedVariable != null;
            if (isVariable) {
              ;
              [name, value] = extractedVariable;
            }
          }
          const path = getPath(section, subsection, name);
          return { line, isSection, section, subsection, name, value, path };
        });
      }
      static from(text) {
        return new _GitConfig(text);
      }
      async get(path, getall = false) {
        const normalizedPath = normalizePath$1(path).path;
        const allValues = this.parsedConfig.filter((config) => config.path === normalizedPath).map(({ section, name, value }) => {
          const fn = schema[section] && schema[section][name];
          return fn ? fn(value) : value;
        });
        return getall ? allValues : allValues.pop();
      }
      async getall(path) {
        return this.get(path, true);
      }
      async getSubsections(section) {
        return this.parsedConfig.filter((config) => config.section === section && config.isSection).map((config) => config.subsection);
      }
      async deleteSection(section, subsection) {
        this.parsedConfig = this.parsedConfig.filter(
          (config) => !(config.section === section && config.subsection === subsection)
        );
      }
      async append(path, value) {
        return this.set(path, value, true);
      }
      async set(path, value, append = false) {
        const {
          section,
          subsection,
          name,
          path: normalizedPath,
          sectionPath
        } = normalizePath$1(path);
        const configIndex = findLastIndex(
          this.parsedConfig,
          (config) => config.path === normalizedPath
        );
        if (value == null) {
          if (configIndex !== -1) {
            this.parsedConfig.splice(configIndex, 1);
          }
        } else {
          if (configIndex !== -1) {
            const config = this.parsedConfig[configIndex];
            const modifiedConfig = Object.assign({}, config, {
              name,
              value,
              modified: true
            });
            if (append) {
              this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
            } else {
              this.parsedConfig[configIndex] = modifiedConfig;
            }
          } else {
            const sectionIndex = this.parsedConfig.findIndex(
              (config) => config.path === sectionPath
            );
            const newConfig = {
              section,
              subsection,
              name,
              value,
              modified: true,
              path: normalizedPath
            };
            if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
              if (sectionIndex >= 0) {
                this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
              } else {
                const newSection = {
                  section,
                  subsection,
                  modified: true,
                  path: sectionPath
                };
                this.parsedConfig.push(newSection, newConfig);
              }
            }
          }
        }
      }
      toString() {
        return this.parsedConfig.map(({ line, section, subsection, name, value, modified: modified2 = false }) => {
          if (!modified2) {
            return line;
          }
          if (name != null && value != null) {
            if (typeof value === "string" && /[#;]/.test(value)) {
              return `	${name} = "${value}"`;
            }
            return `	${name} = ${value}`;
          }
          if (subsection != null) {
            return `[${section} "${subsection}"]`;
          }
          return `[${section}]`;
        }).join("\n");
      }
    };
    GitConfigManager = class {
      static async get({ fs, gitdir }) {
        const text = await fs.read(`${gitdir}/config`, { encoding: "utf8" });
        return GitConfig.from(text);
      }
      static async save({ fs, gitdir, config }) {
        await fs.write(`${gitdir}/config`, config.toString(), {
          encoding: "utf8"
        });
      }
    };
    refpaths = (ref) => [
      `${ref}`,
      `refs/${ref}`,
      `refs/tags/${ref}`,
      `refs/heads/${ref}`,
      `refs/remotes/${ref}`,
      `refs/remotes/${ref}/HEAD`
    ];
    GIT_FILES = ["config", "description", "index", "shallow", "commondir"];
    GitRefManager = class _GitRefManager {
      static async updateRemoteRefs({
        fs,
        gitdir,
        remote,
        refs,
        symrefs,
        tags,
        refspecs = void 0,
        prune = false,
        pruneTags = false
      }) {
        for (const value of refs.values()) {
          if (!value.match(/[0-9a-f]{40}/)) {
            throw new InvalidOidError(value);
          }
        }
        const config = await GitConfigManager.get({ fs, gitdir });
        if (!refspecs) {
          refspecs = await config.getall(`remote.${remote}.fetch`);
          if (refspecs.length === 0) {
            throw new NoRefspecError(remote);
          }
          refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
        }
        const refspec = GitRefSpecSet.from(refspecs);
        const actualRefsToWrite = /* @__PURE__ */ new Map();
        if (pruneTags) {
          const tags2 = await _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: "refs/tags"
          });
          await _GitRefManager.deleteRefs({
            fs,
            gitdir,
            refs: tags2.map((tag2) => `refs/tags/${tag2}`)
          });
        }
        if (tags) {
          for (const serverRef of refs.keys()) {
            if (serverRef.startsWith("refs/tags") && !serverRef.endsWith("^{}")) {
              if (!await _GitRefManager.exists({ fs, gitdir, ref: serverRef })) {
                const oid = refs.get(serverRef);
                actualRefsToWrite.set(serverRef, oid);
              }
            }
          }
        }
        const refTranslations = refspec.translate([...refs.keys()]);
        for (const [serverRef, translatedRef] of refTranslations) {
          const value = refs.get(serverRef);
          actualRefsToWrite.set(translatedRef, value);
        }
        const symrefTranslations = refspec.translate([...symrefs.keys()]);
        for (const [serverRef, translatedRef] of symrefTranslations) {
          const value = symrefs.get(serverRef);
          const symtarget = refspec.translateOne(value);
          if (symtarget) {
            actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
          }
        }
        const pruned = [];
        if (prune) {
          for (const filepath of refspec.localNamespaces()) {
            const refs2 = (await _GitRefManager.listRefs({
              fs,
              gitdir,
              filepath
            })).map((file) => `${filepath}/${file}`);
            for (const ref of refs2) {
              if (!actualRefsToWrite.has(ref)) {
                pruned.push(ref);
              }
            }
          }
          if (pruned.length > 0) {
            await _GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
          }
        }
        for (const [key, value] of actualRefsToWrite) {
          await acquireLock(
            key,
            async () => fs.write(join(gitdir, key), `${value.trim()}
`, "utf8")
          );
        }
        return { pruned };
      }
      // TODO: make this less crude?
      static async writeRef({ fs, gitdir, ref, value }) {
        if (!value.match(/[0-9a-f]{40}/)) {
          throw new InvalidOidError(value);
        }
        await acquireLock(
          ref,
          async () => fs.write(join(gitdir, ref), `${value.trim()}
`, "utf8")
        );
      }
      static async writeSymbolicRef({ fs, gitdir, ref, value }) {
        await acquireLock(
          ref,
          async () => fs.write(join(gitdir, ref), `ref: ${value.trim()}
`, "utf8")
        );
      }
      static async deleteRef({ fs, gitdir, ref }) {
        return _GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] });
      }
      static async deleteRefs({ fs, gitdir, refs }) {
        await Promise.all(refs.map((ref) => fs.rm(join(gitdir, ref))));
        let text = await acquireLock(
          "packed-refs",
          async () => fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
        );
        const packed = GitPackedRefs.from(text);
        const beforeSize = packed.refs.size;
        for (const ref of refs) {
          if (packed.refs.has(ref)) {
            packed.delete(ref);
          }
        }
        if (packed.refs.size < beforeSize) {
          text = packed.toString();
          await acquireLock(
            "packed-refs",
            async () => fs.write(`${gitdir}/packed-refs`, text, { encoding: "utf8" })
          );
        }
      }
      /**
       * @param {object} args
       * @param {import('../models/FileSystem.js').FileSystem} args.fs
       * @param {string} args.gitdir
       * @param {string} args.ref
       * @param {number} [args.depth]
       * @returns {Promise<string>}
       */
      static async resolve({ fs, gitdir, ref, depth = void 0 }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return ref;
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return _GitRefManager.resolve({ fs, gitdir, ref, depth });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await _GitRefManager.packedRefs({ fs, gitdir });
        const allpaths = refpaths(ref).filter((p2) => !GIT_FILES.includes(p2));
        for (const ref2 of allpaths) {
          const sha = await acquireLock(
            ref2,
            async () => await fs.read(`${gitdir}/${ref2}`, { encoding: "utf8" }) || packedMap.get(ref2)
          );
          if (sha) {
            return _GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth });
          }
        }
        throw new NotFoundError(ref);
      }
      static async exists({ fs, gitdir, ref }) {
        try {
          await _GitRefManager.expand({ fs, gitdir, ref });
          return true;
        } catch (err) {
          return false;
        }
      }
      static async expand({ fs, gitdir, ref }) {
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return ref;
        }
        const packedMap = await _GitRefManager.packedRefs({ fs, gitdir });
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const refExists = await acquireLock(
            ref2,
            async () => fs.exists(`${gitdir}/${ref2}`)
          );
          if (refExists)
            return ref2;
          if (packedMap.has(ref2))
            return ref2;
        }
        throw new NotFoundError(ref);
      }
      static async expandAgainstMap({ ref, map }) {
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          if (await map.has(ref2))
            return ref2;
        }
        throw new NotFoundError(ref);
      }
      static resolveAgainstMap({ ref, fullref = ref, depth = void 0, map }) {
        if (depth !== void 0) {
          depth--;
          if (depth === -1) {
            return { fullref, oid: ref };
          }
        }
        if (ref.startsWith("ref: ")) {
          ref = ref.slice("ref: ".length);
          return _GitRefManager.resolveAgainstMap({ ref, fullref, depth, map });
        }
        if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
          return { fullref, oid: ref };
        }
        const allpaths = refpaths(ref);
        for (const ref2 of allpaths) {
          const sha = map.get(ref2);
          if (sha) {
            return _GitRefManager.resolveAgainstMap({
              ref: sha.trim(),
              fullref: ref2,
              depth,
              map
            });
          }
        }
        throw new NotFoundError(ref);
      }
      static async packedRefs({ fs, gitdir }) {
        const text = await acquireLock(
          "packed-refs",
          async () => fs.read(`${gitdir}/packed-refs`, { encoding: "utf8" })
        );
        const packed = GitPackedRefs.from(text);
        return packed.refs;
      }
      // List all the refs that match the `filepath` prefix
      static async listRefs({ fs, gitdir, filepath }) {
        const packedMap = _GitRefManager.packedRefs({ fs, gitdir });
        let files = null;
        try {
          files = await fs.readdirDeep(`${gitdir}/${filepath}`);
          files = files.map((x2) => x2.replace(`${gitdir}/${filepath}/`, ""));
        } catch (err) {
          files = [];
        }
        for (let key of (await packedMap).keys()) {
          if (key.startsWith(filepath)) {
            key = key.replace(filepath + "/", "");
            if (!files.includes(key)) {
              files.push(key);
            }
          }
        }
        files.sort(compareRefNames);
        return files;
      }
      static async listBranches({ fs, gitdir, remote }) {
        if (remote) {
          return _GitRefManager.listRefs({
            fs,
            gitdir,
            filepath: `refs/remotes/${remote}`
          });
        } else {
          return _GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` });
        }
      }
      static async listTags({ fs, gitdir }) {
        const tags = await _GitRefManager.listRefs({
          fs,
          gitdir,
          filepath: `refs/tags`
        });
        return tags.filter((x2) => !x2.endsWith("^{}"));
      }
    };
    GitTree = class _GitTree {
      constructor(entries) {
        if (Buffer.isBuffer(entries)) {
          this._entries = parseBuffer(entries);
        } else if (Array.isArray(entries)) {
          this._entries = entries.map(nudgeIntoShape);
        } else {
          throw new InternalError("invalid type passed to GitTree constructor");
        }
        this._entries.sort(comparePath);
      }
      static from(tree) {
        return new _GitTree(tree);
      }
      render() {
        return this._entries.map((entry) => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join("\n");
      }
      toObject() {
        const entries = [...this._entries];
        entries.sort(compareTreeEntryPath);
        return Buffer.concat(
          entries.map((entry) => {
            const mode = Buffer.from(entry.mode.replace(/^0/, ""));
            const space = Buffer.from(" ");
            const path = Buffer.from(entry.path, "utf8");
            const nullchar = Buffer.from([0]);
            const oid = Buffer.from(entry.oid, "hex");
            return Buffer.concat([mode, space, path, nullchar, oid]);
          })
        );
      }
      /**
       * @returns {TreeEntry[]}
       */
      entries() {
        return this._entries;
      }
      *[Symbol.iterator]() {
        for (const entry of this._entries) {
          yield entry;
        }
      }
    };
    GitObject = class {
      static wrap({ type, object }) {
        return Buffer.concat([
          Buffer.from(`${type} ${object.byteLength.toString()}\0`),
          Buffer.from(object)
        ]);
      }
      static unwrap(buffer) {
        const s2 = buffer.indexOf(32);
        const i4 = buffer.indexOf(0);
        const type = buffer.slice(0, s2).toString("utf8");
        const length = buffer.slice(s2 + 1, i4).toString("utf8");
        const actualLength = buffer.length - (i4 + 1);
        if (parseInt(length) !== actualLength) {
          throw new InternalError(
            `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
          );
        }
        return {
          type,
          object: Buffer.from(buffer.slice(i4 + 1))
        };
      }
    };
    StreamReader = class {
      constructor(stream) {
        this.stream = getIterator(stream);
        this.buffer = null;
        this.cursor = 0;
        this.undoCursor = 0;
        this.started = false;
        this._ended = false;
        this._discardedBytes = 0;
      }
      eof() {
        return this._ended && this.cursor === this.buffer.length;
      }
      tell() {
        return this._discardedBytes + this.cursor;
      }
      async byte() {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended)
            return;
        }
        this._moveCursor(1);
        return this.buffer[this.undoCursor];
      }
      async chunk() {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor === this.buffer.length) {
          await this._loadnext();
          if (this._ended)
            return;
        }
        this._moveCursor(this.buffer.length);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async read(n5) {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor + n5 > this.buffer.length) {
          this._trim();
          await this._accumulate(n5);
        }
        this._moveCursor(n5);
        return this.buffer.slice(this.undoCursor, this.cursor);
      }
      async skip(n5) {
        if (this.eof())
          return;
        if (!this.started)
          await this._init();
        if (this.cursor + n5 > this.buffer.length) {
          this._trim();
          await this._accumulate(n5);
        }
        this._moveCursor(n5);
      }
      async undo() {
        this.cursor = this.undoCursor;
      }
      async _next() {
        this.started = true;
        let { done, value } = await this.stream.next();
        if (done) {
          this._ended = true;
          if (!value)
            return Buffer.alloc(0);
        }
        if (value) {
          value = Buffer.from(value);
        }
        return value;
      }
      _trim() {
        this.buffer = this.buffer.slice(this.undoCursor);
        this.cursor -= this.undoCursor;
        this._discardedBytes += this.undoCursor;
        this.undoCursor = 0;
      }
      _moveCursor(n5) {
        this.undoCursor = this.cursor;
        this.cursor += n5;
        if (this.cursor > this.buffer.length) {
          this.cursor = this.buffer.length;
        }
      }
      async _accumulate(n5) {
        if (this._ended)
          return;
        const buffers = [this.buffer];
        while (this.cursor + n5 > lengthBuffers(buffers)) {
          const nextbuffer = await this._next();
          if (this._ended)
            break;
          buffers.push(nextbuffer);
        }
        this.buffer = Buffer.concat(buffers);
      }
      async _loadnext() {
        this._discardedBytes += this.buffer.length;
        this.undoCursor = 0;
        this.cursor = 0;
        this.buffer = await this._next();
      }
      async _init() {
        this.buffer = await this._next();
      }
    };
    supportsDecompressionStream = false;
    GitPackIndex = class _GitPackIndex {
      constructor(stuff) {
        Object.assign(this, stuff);
        this.offsetCache = {};
      }
      static async fromIdx({ idx, getExternalRefDelta }) {
        const reader = new BufferCursor(idx);
        const magic = reader.slice(4).toString("hex");
        if (magic !== "ff744f63") {
          return;
        }
        const version3 = reader.readUInt32BE();
        if (version3 !== 2) {
          throw new InternalError(
            `Unable to read version ${version3} packfile IDX. (Only version 2 supported)`
          );
        }
        if (idx.byteLength > 2048 * 1024 * 1024) {
          throw new InternalError(
            `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
          );
        }
        reader.seek(reader.tell() + 4 * 255);
        const size3 = reader.readUInt32BE();
        const hashes = [];
        for (let i4 = 0; i4 < size3; i4++) {
          const hash2 = reader.slice(20).toString("hex");
          hashes[i4] = hash2;
        }
        reader.seek(reader.tell() + 4 * size3);
        const offsets = /* @__PURE__ */ new Map();
        for (let i4 = 0; i4 < size3; i4++) {
          offsets.set(hashes[i4], reader.readUInt32BE());
        }
        const packfileSha = reader.slice(20).toString("hex");
        return new _GitPackIndex({
          hashes,
          crcs: {},
          offsets,
          packfileSha,
          getExternalRefDelta
        });
      }
      static async fromPack({ pack, getExternalRefDelta, onProgress }) {
        const listpackTypes = {
          1: "commit",
          2: "tree",
          3: "blob",
          4: "tag",
          6: "ofs-delta",
          7: "ref-delta"
        };
        const offsetToObject = {};
        const packfileSha = pack.slice(-20).toString("hex");
        const hashes = [];
        const crcs = {};
        const offsets = /* @__PURE__ */ new Map();
        let totalObjectCount = null;
        let lastPercent = null;
        await listpack([pack], async ({ data, type, reference, offset: offset3, num: num3 }) => {
          if (totalObjectCount === null)
            totalObjectCount = num3;
          const percent = Math.floor(
            (totalObjectCount - num3) * 100 / totalObjectCount
          );
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Receiving objects",
                loaded: totalObjectCount - num3,
                total: totalObjectCount
              });
            }
          }
          lastPercent = percent;
          type = listpackTypes[type];
          if (["commit", "tree", "blob", "tag"].includes(type)) {
            offsetToObject[offset3] = {
              type,
              offset: offset3
            };
          } else if (type === "ofs-delta") {
            offsetToObject[offset3] = {
              type,
              offset: offset3
            };
          } else if (type === "ref-delta") {
            offsetToObject[offset3] = {
              type,
              offset: offset3
            };
          }
        });
        const offsetArray = Object.keys(offsetToObject).map(Number);
        for (const [i4, start] of offsetArray.entries()) {
          const end = i4 + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i4 + 1];
          const o5 = offsetToObject[start];
          const crc = import_crc_32.default.buf(pack.slice(start, end)) >>> 0;
          o5.end = end;
          o5.crc = crc;
        }
        const p2 = new _GitPackIndex({
          pack: Promise.resolve(pack),
          packfileSha,
          crcs,
          hashes,
          offsets,
          getExternalRefDelta
        });
        lastPercent = null;
        let count = 0;
        const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (let offset3 in offsetToObject) {
          offset3 = Number(offset3);
          const percent = Math.floor(count * 100 / totalObjectCount);
          if (percent !== lastPercent) {
            if (onProgress) {
              await onProgress({
                phase: "Resolving deltas",
                loaded: count,
                total: totalObjectCount
              });
            }
          }
          count++;
          lastPercent = percent;
          const o5 = offsetToObject[offset3];
          if (o5.oid)
            continue;
          try {
            p2.readDepth = 0;
            p2.externalReadDepth = 0;
            const { type, object } = await p2.readSlice({ start: offset3 });
            objectsByDepth[p2.readDepth] += 1;
            const oid = await shasum(GitObject.wrap({ type, object }));
            o5.oid = oid;
            hashes.push(oid);
            offsets.set(oid, offset3);
            crcs[oid] = o5.crc;
          } catch (err) {
            continue;
          }
        }
        hashes.sort();
        return p2;
      }
      async toBuffer() {
        const buffers = [];
        const write = (str, encoding) => {
          buffers.push(Buffer.from(str, encoding));
        };
        write("ff744f63", "hex");
        write("00000002", "hex");
        const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
        for (let i4 = 0; i4 < 256; i4++) {
          let count = 0;
          for (const hash2 of this.hashes) {
            if (parseInt(hash2.slice(0, 2), 16) <= i4)
              count++;
          }
          fanoutBuffer.writeUInt32BE(count);
        }
        buffers.push(fanoutBuffer.buffer);
        for (const hash2 of this.hashes) {
          write(hash2, "hex");
        }
        const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
        for (const hash2 of this.hashes) {
          crcsBuffer.writeUInt32BE(this.crcs[hash2]);
        }
        buffers.push(crcsBuffer.buffer);
        const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
        for (const hash2 of this.hashes) {
          offsetsBuffer.writeUInt32BE(this.offsets.get(hash2));
        }
        buffers.push(offsetsBuffer.buffer);
        write(this.packfileSha, "hex");
        const totalBuffer = Buffer.concat(buffers);
        const sha = await shasum(totalBuffer);
        const shaBuffer = Buffer.alloc(20);
        shaBuffer.write(sha, "hex");
        return Buffer.concat([totalBuffer, shaBuffer]);
      }
      async load({ pack }) {
        this.pack = pack;
      }
      async unload() {
        this.pack = null;
      }
      async read({ oid }) {
        if (!this.offsets.get(oid)) {
          if (this.getExternalRefDelta) {
            this.externalReadDepth++;
            return this.getExternalRefDelta(oid);
          } else {
            throw new InternalError(`Could not read object ${oid} from packfile`);
          }
        }
        const start = this.offsets.get(oid);
        return this.readSlice({ start });
      }
      async readSlice({ start }) {
        if (this.offsetCache[start]) {
          return Object.assign({}, this.offsetCache[start]);
        }
        this.readDepth++;
        const types2 = {
          16: "commit",
          32: "tree",
          48: "blob",
          64: "tag",
          96: "ofs_delta",
          112: "ref_delta"
        };
        if (!this.pack) {
          throw new InternalError(
            "Tried to read from a GitPackIndex with no packfile loaded into memory"
          );
        }
        const raw = (await this.pack).slice(start);
        const reader = new BufferCursor(raw);
        const byte = reader.readUInt8();
        const btype = byte & 112;
        let type = types2[btype];
        if (type === void 0) {
          throw new InternalError("Unrecognized type: 0b" + btype.toString(2));
        }
        const lastFour = byte & 15;
        let length = lastFour;
        const multibyte = byte & 128;
        if (multibyte) {
          length = otherVarIntDecode(reader, lastFour);
        }
        let base = null;
        let object = null;
        if (type === "ofs_delta") {
          const offset3 = decodeVarInt(reader);
          const baseOffset = start - offset3;
          ({ object: base, type } = await this.readSlice({ start: baseOffset }));
        }
        if (type === "ref_delta") {
          const oid = reader.slice(20).toString("hex");
          ({ object: base, type } = await this.read({ oid }));
        }
        const buffer = raw.slice(reader.tell());
        object = Buffer.from(await inflate(buffer));
        if (object.byteLength !== length) {
          throw new InternalError(
            `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
          );
        }
        if (base) {
          object = Buffer.from(applyDelta(object, base));
        }
        if (this.readDepth > 3) {
          this.offsetCache[start] = { type, object };
        }
        return { type, format: "content", object };
      }
    };
    PackfileCache = Symbol("PackfileCache");
    AlreadyExistsError = class _AlreadyExistsError extends BaseError {
      /**
       * @param {'note'|'remote'|'tag'|'branch'} noun
       * @param {string} where
       * @param {boolean} canForce
       */
      constructor(noun, where, canForce = true) {
        super(
          `Failed to create ${noun} at ${where} because it already exists.${canForce ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)` : ""}`
        );
        this.code = this.name = _AlreadyExistsError.code;
        this.data = { noun, where, canForce };
      }
    };
    AlreadyExistsError.code = "AlreadyExistsError";
    AmbiguousError = class _AmbiguousError extends BaseError {
      /**
       * @param {'oids'|'refs'} nouns
       * @param {string} short
       * @param {string[]} matches
       */
      constructor(nouns, short, matches) {
        super(
          `Found multiple ${nouns} matching "${short}" (${matches.join(
            ", "
          )}). Use a longer abbreviation length to disambiguate them.`
        );
        this.code = this.name = _AmbiguousError.code;
        this.data = { nouns, short, matches };
      }
    };
    AmbiguousError.code = "AmbiguousError";
    CheckoutConflictError = class _CheckoutConflictError extends BaseError {
      /**
       * @param {string[]} filepaths
       */
      constructor(filepaths) {
        super(
          `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
            ", "
          )}`
        );
        this.code = this.name = _CheckoutConflictError.code;
        this.data = { filepaths };
      }
    };
    CheckoutConflictError.code = "CheckoutConflictError";
    CommitNotFetchedError = class _CommitNotFetchedError extends BaseError {
      /**
       * @param {string} ref
       * @param {string} oid
       */
      constructor(ref, oid) {
        super(
          `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
        );
        this.code = this.name = _CommitNotFetchedError.code;
        this.data = { ref, oid };
      }
    };
    CommitNotFetchedError.code = "CommitNotFetchedError";
    EmptyServerResponseError = class _EmptyServerResponseError extends BaseError {
      constructor() {
        super(`Empty response from git server.`);
        this.code = this.name = _EmptyServerResponseError.code;
        this.data = {};
      }
    };
    EmptyServerResponseError.code = "EmptyServerResponseError";
    FastForwardError = class _FastForwardError extends BaseError {
      constructor() {
        super(`A simple fast-forward merge was not possible.`);
        this.code = this.name = _FastForwardError.code;
        this.data = {};
      }
    };
    FastForwardError.code = "FastForwardError";
    GitPushError = class _GitPushError extends BaseError {
      /**
       * @param {string} prettyDetails
       * @param {PushResult} result
       */
      constructor(prettyDetails, result) {
        super(`One or more branches were not updated: ${prettyDetails}`);
        this.code = this.name = _GitPushError.code;
        this.data = { prettyDetails, result };
      }
    };
    GitPushError.code = "GitPushError";
    HttpError = class _HttpError extends BaseError {
      /**
       * @param {number} statusCode
       * @param {string} statusMessage
       * @param {string} response
       */
      constructor(statusCode, statusMessage, response) {
        super(`HTTP Error: ${statusCode} ${statusMessage}`);
        this.code = this.name = _HttpError.code;
        this.data = { statusCode, statusMessage, response };
      }
    };
    HttpError.code = "HttpError";
    InvalidFilepathError = class _InvalidFilepathError extends BaseError {
      /**
       * @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
       */
      constructor(reason) {
        let message = "invalid filepath";
        if (reason === "leading-slash" || reason === "trailing-slash") {
          message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
        } else if (reason === "directory") {
          message = `"filepath" should not be a directory.`;
        }
        super(message);
        this.code = this.name = _InvalidFilepathError.code;
        this.data = { reason };
      }
    };
    InvalidFilepathError.code = "InvalidFilepathError";
    InvalidRefNameError = class _InvalidRefNameError extends BaseError {
      /**
       * @param {string} ref
       * @param {string} suggestion
       * @param {boolean} canForce
       */
      constructor(ref, suggestion) {
        super(
          `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
        );
        this.code = this.name = _InvalidRefNameError.code;
        this.data = { ref, suggestion };
      }
    };
    InvalidRefNameError.code = "InvalidRefNameError";
    MaxDepthError = class _MaxDepthError extends BaseError {
      /**
       * @param {number} depth
       */
      constructor(depth) {
        super(`Maximum search depth of ${depth} exceeded.`);
        this.code = this.name = _MaxDepthError.code;
        this.data = { depth };
      }
    };
    MaxDepthError.code = "MaxDepthError";
    MergeNotSupportedError = class _MergeNotSupportedError extends BaseError {
      constructor() {
        super(`Merges with conflicts are not supported yet.`);
        this.code = this.name = _MergeNotSupportedError.code;
        this.data = {};
      }
    };
    MergeNotSupportedError.code = "MergeNotSupportedError";
    MergeConflictError = class _MergeConflictError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       * @param {Array<string>} bothModified
       * @param {Array<string>} deleteByUs
       * @param {Array<string>} deleteByTheirs
       */
      constructor(filepaths, bothModified, deleteByUs, deleteByTheirs) {
        super(
          `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`
        );
        this.code = this.name = _MergeConflictError.code;
        this.data = { filepaths, bothModified, deleteByUs, deleteByTheirs };
      }
    };
    MergeConflictError.code = "MergeConflictError";
    MissingNameError = class _MissingNameError extends BaseError {
      /**
       * @param {'author'|'committer'|'tagger'} role
       */
      constructor(role) {
        super(
          `No name was provided for ${role} in the argument or in the .git/config file.`
        );
        this.code = this.name = _MissingNameError.code;
        this.data = { role };
      }
    };
    MissingNameError.code = "MissingNameError";
    MissingParameterError = class _MissingParameterError extends BaseError {
      /**
       * @param {string} parameter
       */
      constructor(parameter) {
        super(
          `The function requires a "${parameter}" parameter but none was provided.`
        );
        this.code = this.name = _MissingParameterError.code;
        this.data = { parameter };
      }
    };
    MissingParameterError.code = "MissingParameterError";
    MultipleGitError = class _MultipleGitError extends BaseError {
      /**
       * @param {Error[]} errors
       * @param {string} message
       */
      constructor(errors) {
        super(
          `There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more`
        );
        this.code = this.name = _MultipleGitError.code;
        this.data = { errors };
        this.errors = errors;
      }
    };
    MultipleGitError.code = "MultipleGitError";
    ParseError = class _ParseError extends BaseError {
      /**
       * @param {string} expected
       * @param {string} actual
       */
      constructor(expected, actual) {
        super(`Expected "${expected}" but received "${actual}".`);
        this.code = this.name = _ParseError.code;
        this.data = { expected, actual };
      }
    };
    ParseError.code = "ParseError";
    PushRejectedError = class _PushRejectedError extends BaseError {
      /**
       * @param {'not-fast-forward'|'tag-exists'} reason
       */
      constructor(reason) {
        let message = "";
        if (reason === "not-fast-forward") {
          message = " because it was not a simple fast-forward";
        } else if (reason === "tag-exists") {
          message = " because tag already exists";
        }
        super(`Push rejected${message}. Use "force: true" to override.`);
        this.code = this.name = _PushRejectedError.code;
        this.data = { reason };
      }
    };
    PushRejectedError.code = "PushRejectedError";
    RemoteCapabilityError = class _RemoteCapabilityError extends BaseError {
      /**
       * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
       * @param {'depth'|'since'|'exclude'|'relative'} parameter
       */
      constructor(capability, parameter) {
        super(
          `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
        );
        this.code = this.name = _RemoteCapabilityError.code;
        this.data = { capability, parameter };
      }
    };
    RemoteCapabilityError.code = "RemoteCapabilityError";
    SmartHttpError = class _SmartHttpError extends BaseError {
      /**
       * @param {string} preview
       * @param {string} response
       */
      constructor(preview, response) {
        super(
          `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
        );
        this.code = this.name = _SmartHttpError.code;
        this.data = { preview, response };
      }
    };
    SmartHttpError.code = "SmartHttpError";
    UnknownTransportError = class _UnknownTransportError extends BaseError {
      /**
       * @param {string} url
       * @param {string} transport
       * @param {string} [suggestion]
       */
      constructor(url, transport, suggestion) {
        super(
          `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
        );
        this.code = this.name = _UnknownTransportError.code;
        this.data = { url, transport, suggestion };
      }
    };
    UnknownTransportError.code = "UnknownTransportError";
    UrlParseError = class _UrlParseError extends BaseError {
      /**
       * @param {string} url
       */
      constructor(url) {
        super(`Cannot parse remote URL: "${url}"`);
        this.code = this.name = _UrlParseError.code;
        this.data = { url };
      }
    };
    UrlParseError.code = "UrlParseError";
    UserCanceledError = class _UserCanceledError extends BaseError {
      constructor() {
        super(`The operation was canceled.`);
        this.code = this.name = _UserCanceledError.code;
        this.data = {};
      }
    };
    UserCanceledError.code = "UserCanceledError";
    IndexResetError = class _IndexResetError extends BaseError {
      /**
       * @param {Array<string>} filepaths
       */
      constructor(filepath) {
        super(
          `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged changes.`
        );
        this.code = this.name = _IndexResetError.code;
        this.data = { filepath };
      }
    };
    IndexResetError.code = "IndexResetError";
    Errors = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      AlreadyExistsError,
      AmbiguousError,
      CheckoutConflictError,
      CommitNotFetchedError,
      EmptyServerResponseError,
      FastForwardError,
      GitPushError,
      HttpError,
      InternalError,
      InvalidFilepathError,
      InvalidOidError,
      InvalidRefNameError,
      MaxDepthError,
      MergeNotSupportedError,
      MergeConflictError,
      MissingNameError,
      MissingParameterError,
      MultipleGitError,
      NoRefspecError,
      NotFoundError,
      ObjectTypeError,
      ParseError,
      PushRejectedError,
      RemoteCapabilityError,
      SmartHttpError,
      UnknownTransportError,
      UnsafeFilepathError,
      UrlParseError,
      UserCanceledError,
      UnmergedPathsError,
      IndexResetError
    });
    GitAnnotatedTag = class _GitAnnotatedTag {
      constructor(tag2) {
        if (typeof tag2 === "string") {
          this._tag = tag2;
        } else if (Buffer.isBuffer(tag2)) {
          this._tag = tag2.toString("utf8");
        } else if (typeof tag2 === "object") {
          this._tag = _GitAnnotatedTag.render(tag2);
        } else {
          throw new InternalError(
            "invalid type passed to GitAnnotatedTag constructor"
          );
        }
      }
      static from(tag2) {
        return new _GitAnnotatedTag(tag2);
      }
      static render(obj) {
        return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ""}`;
      }
      justHeaders() {
        return this._tag.slice(0, this._tag.indexOf("\n\n"));
      }
      message() {
        const tag2 = this.withoutSignature();
        return tag2.slice(tag2.indexOf("\n\n") + 2);
      }
      parse() {
        return Object.assign(this.headers(), {
          message: this.message(),
          gpgsig: this.gpgsig()
        });
      }
      render() {
        return this._tag;
      }
      headers() {
        const headers = this.justHeaders().split("\n");
        const hs = [];
        for (const h4 of headers) {
          if (h4[0] === " ") {
            hs[hs.length - 1] += "\n" + h4.slice(1);
          } else {
            hs.push(h4);
          }
        }
        const obj = {};
        for (const h4 of hs) {
          const key = h4.slice(0, h4.indexOf(" "));
          const value = h4.slice(h4.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.tagger) {
          obj.tagger = parseAuthor(obj.tagger);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      withoutSignature() {
        const tag2 = normalizeNewlines(this._tag);
        if (tag2.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1)
          return tag2;
        return tag2.slice(0, tag2.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
      }
      gpgsig() {
        if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -1)
          return;
        const signature = this._tag.slice(
          this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._tag.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
        );
        return normalizeNewlines(signature);
      }
      payload() {
        return this.withoutSignature() + "\n";
      }
      toObject() {
        return Buffer.from(this._tag, "utf8");
      }
      static async sign(tag2, sign3, secretKey) {
        const payload = tag2.payload();
        let { signature } = await sign3({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const signedTag = payload + signature;
        return _GitAnnotatedTag.from(signedTag);
      }
    };
    GitCommit = class _GitCommit {
      constructor(commit3) {
        if (typeof commit3 === "string") {
          this._commit = commit3;
        } else if (Buffer.isBuffer(commit3)) {
          this._commit = commit3.toString("utf8");
        } else if (typeof commit3 === "object") {
          this._commit = _GitCommit.render(commit3);
        } else {
          throw new InternalError("invalid type passed to GitCommit constructor");
        }
      }
      static fromPayloadSignature({ payload, signature }) {
        const headers = _GitCommit.justHeaders(payload);
        const message = _GitCommit.justMessage(payload);
        const commit3 = normalizeNewlines(
          headers + "\ngpgsig" + indent(signature) + "\n" + message
        );
        return new _GitCommit(commit3);
      }
      static from(commit3) {
        return new _GitCommit(commit3);
      }
      toObject() {
        return Buffer.from(this._commit, "utf8");
      }
      // Todo: allow setting the headers and message
      headers() {
        return this.parseHeaders();
      }
      // Todo: allow setting the headers and message
      message() {
        return _GitCommit.justMessage(this._commit);
      }
      parse() {
        return Object.assign({ message: this.message() }, this.headers());
      }
      static justMessage(commit3) {
        return normalizeNewlines(commit3.slice(commit3.indexOf("\n\n") + 2));
      }
      static justHeaders(commit3) {
        return commit3.slice(0, commit3.indexOf("\n\n"));
      }
      parseHeaders() {
        const headers = _GitCommit.justHeaders(this._commit).split("\n");
        const hs = [];
        for (const h4 of headers) {
          if (h4[0] === " ") {
            hs[hs.length - 1] += "\n" + h4.slice(1);
          } else {
            hs.push(h4);
          }
        }
        const obj = {
          parent: []
        };
        for (const h4 of hs) {
          const key = h4.slice(0, h4.indexOf(" "));
          const value = h4.slice(h4.indexOf(" ") + 1);
          if (Array.isArray(obj[key])) {
            obj[key].push(value);
          } else {
            obj[key] = value;
          }
        }
        if (obj.author) {
          obj.author = parseAuthor(obj.author);
        }
        if (obj.committer) {
          obj.committer = parseAuthor(obj.committer);
        }
        return obj;
      }
      static renderHeaders(obj) {
        let headers = "";
        if (obj.tree) {
          headers += `tree ${obj.tree}
`;
        } else {
          headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`;
        }
        if (obj.parent) {
          if (obj.parent.length === void 0) {
            throw new InternalError(`commit 'parent' property should be an array`);
          }
          for (const p2 of obj.parent) {
            headers += `parent ${p2}
`;
          }
        }
        const author = obj.author;
        headers += `author ${formatAuthor(author)}
`;
        const committer = obj.committer || obj.author;
        headers += `committer ${formatAuthor(committer)}
`;
        if (obj.gpgsig) {
          headers += "gpgsig" + indent(obj.gpgsig);
        }
        return headers;
      }
      static render(obj) {
        return _GitCommit.renderHeaders(obj) + "\n" + normalizeNewlines(obj.message);
      }
      render() {
        return this._commit;
      }
      withoutSignature() {
        const commit3 = normalizeNewlines(this._commit);
        if (commit3.indexOf("\ngpgsig") === -1)
          return commit3;
        const headers = commit3.slice(0, commit3.indexOf("\ngpgsig"));
        const message = commit3.slice(
          commit3.indexOf("-----END PGP SIGNATURE-----\n") + "-----END PGP SIGNATURE-----\n".length
        );
        return normalizeNewlines(headers + "\n" + message);
      }
      isolateSignature() {
        const signature = this._commit.slice(
          this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
          this._commit.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
        );
        return outdent(signature);
      }
      static async sign(commit3, sign3, secretKey) {
        const payload = commit3.withoutSignature();
        const message = _GitCommit.justMessage(commit3._commit);
        let { signature } = await sign3({ payload, secretKey });
        signature = normalizeNewlines(signature);
        const headers = _GitCommit.justHeaders(commit3._commit);
        const signedCommit = headers + "\ngpgsig" + indent(signature) + "\n" + message;
        return _GitCommit.from(signedCommit);
      }
    };
    GitWalkerRepo = class {
      constructor({ fs, gitdir, ref, cache }) {
        this.fs = fs;
        this.cache = cache;
        this.gitdir = gitdir;
        this.mapPromise = (async () => {
          const map = /* @__PURE__ */ new Map();
          let oid;
          try {
            oid = await GitRefManager.resolve({ fs, gitdir, ref });
          } catch (e6) {
            if (e6 instanceof NotFoundError) {
              oid = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";
            }
          }
          const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });
          tree.type = "tree";
          tree.mode = "40000";
          map.set(".", tree);
          return map;
        })();
        const walker = this;
        this.ConstructEntry = class TreeEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs, cache, gitdir } = this;
        const map = await this.mapPromise;
        const obj = map.get(filepath);
        if (!obj)
          throw new Error(`No obj for ${filepath}`);
        const oid = obj.oid;
        if (!oid)
          throw new Error(`No oid for obj ${JSON.stringify(obj)}`);
        if (obj.type !== "tree") {
          return null;
        }
        const { type, object } = await _readObject({ fs, cache, gitdir, oid });
        if (type !== obj.type) {
          throw new ObjectTypeError(oid, type, obj.type);
        }
        const tree = GitTree.from(object);
        for (const entry2 of tree) {
          map.set(join(filepath, entry2.path), entry2);
        }
        return tree.entries().map((entry2) => join(filepath, entry2.path));
      }
      async type(entry) {
        if (entry._type === false) {
          const map = await this.mapPromise;
          const { type } = map.get(entry._fullpath);
          entry._type = type;
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          const map = await this.mapPromise;
          const { mode } = map.get(entry._fullpath);
          entry._mode = normalizeMode(parseInt(mode, 8));
        }
        return entry._mode;
      }
      async stat(_entry) {
      }
      async content(entry) {
        if (entry._content === false) {
          const map = await this.mapPromise;
          const { fs, cache, gitdir } = this;
          const obj = map.get(entry._fullpath);
          const oid = obj.oid;
          const { type, object } = await _readObject({ fs, cache, gitdir, oid });
          if (type !== "blob") {
            entry._content = void 0;
          } else {
            entry._content = new Uint8Array(object);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const map = await this.mapPromise;
          const obj = map.get(entry._fullpath);
          entry._oid = obj.oid;
        }
        return entry._oid;
      }
    };
    GitWalkerFs = class {
      constructor({ fs, dir, gitdir, cache }) {
        this.fs = fs;
        this.cache = cache;
        this.dir = dir;
        this.gitdir = gitdir;
        const walker = this;
        this.ConstructEntry = class WorkdirEntry {
          constructor(fullpath) {
            this._fullpath = fullpath;
            this._type = false;
            this._mode = false;
            this._stat = false;
            this._content = false;
            this._oid = false;
          }
          async type() {
            return walker.type(this);
          }
          async mode() {
            return walker.mode(this);
          }
          async stat() {
            return walker.stat(this);
          }
          async content() {
            return walker.content(this);
          }
          async oid() {
            return walker.oid(this);
          }
        };
      }
      async readdir(entry) {
        const filepath = entry._fullpath;
        const { fs, dir } = this;
        const names = await fs.readdir(join(dir, filepath));
        if (names === null)
          return null;
        return names.map((name) => join(filepath, name));
      }
      async type(entry) {
        if (entry._type === false) {
          await entry.stat();
        }
        return entry._type;
      }
      async mode(entry) {
        if (entry._mode === false) {
          await entry.stat();
        }
        return entry._mode;
      }
      async stat(entry) {
        if (entry._stat === false) {
          const { fs, dir } = this;
          let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
          if (!stat) {
            throw new Error(
              `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
            );
          }
          let type = stat.isDirectory() ? "tree" : "blob";
          if (type === "blob" && !stat.isFile() && !stat.isSymbolicLink()) {
            type = "special";
          }
          entry._type = type;
          stat = normalizeStats(stat);
          entry._mode = stat.mode;
          if (stat.size === -1 && entry._actualSize) {
            stat.size = entry._actualSize;
          }
          entry._stat = stat;
        }
        return entry._stat;
      }
      async content(entry) {
        if (entry._content === false) {
          const { fs, dir } = this;
          if (await entry.type() === "tree") {
            entry._content = void 0;
          } else {
            const content = await fs.read(`${dir}/${entry._fullpath}`);
            entry._actualSize = content.length;
            if (entry._stat && entry._stat.size === -1) {
              entry._stat.size = entry._actualSize;
            }
            entry._content = new Uint8Array(content);
          }
        }
        return entry._content;
      }
      async oid(entry) {
        if (entry._oid === false) {
          const { fs, gitdir, cache } = this;
          let oid;
          await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index2) {
            const stage = index2.entriesMap.get(entry._fullpath);
            const stats = await entry.stat();
            if (!stage || compareStats(stats, stage)) {
              const content = await entry.content();
              if (content === void 0) {
                oid = void 0;
              } else {
                oid = await shasum(
                  GitObject.wrap({ type: "blob", object: await entry.content() })
                );
                if (stage && oid === stage.oid && stats.mode === stage.mode && compareStats(stats, stage)) {
                  index2.insert({
                    filepath: entry._fullpath,
                    stats,
                    oid
                  });
                }
              }
            } else {
              oid = stage.oid;
            }
          });
          entry._oid = oid;
        }
        return entry._oid;
      }
    };
    flat = typeof Array.prototype.flat === "undefined" ? (entries) => entries.reduce((acc, x2) => acc.concat(x2), []) : (entries) => entries.flat();
    RunningMinimum = class {
      constructor() {
        this.value = null;
      }
      consider(value) {
        if (value === null || value === void 0)
          return;
        if (this.value === null) {
          this.value = value;
        } else if (value < this.value) {
          this.value = value;
        }
      }
      reset() {
        this.value = null;
      }
    };
    commands = [
      "readFile",
      "writeFile",
      "mkdir",
      "rmdir",
      "unlink",
      "stat",
      "lstat",
      "readdir",
      "readlink",
      "symlink"
    ];
    FileSystem = class {
      constructor(fs) {
        if (typeof fs._original_unwrapped_fs !== "undefined")
          return fs;
        const promises = Object.getOwnPropertyDescriptor(fs, "promises");
        if (promises && promises.enumerable) {
          bindFs(this, fs.promises);
        } else {
          bindFs(this, fs);
        }
        this._original_unwrapped_fs = fs;
      }
      /**
       * Return true if a file exists, false if it doesn't exist.
       * Rethrows errors that aren't related to file existence.
       */
      async exists(filepath, options = {}) {
        try {
          await this._stat(filepath);
          return true;
        } catch (err) {
          if (err.code === "ENOENT" || err.code === "ENOTDIR") {
            return false;
          } else {
            console.log('Unhandled error in "FileSystem.exists()" function', err);
            throw err;
          }
        }
      }
      /**
       * Return the contents of a file if it exists, otherwise returns null.
       *
       * @param {string} filepath
       * @param {object} [options]
       *
       * @returns {Promise<Buffer|string|null>}
       */
      async read(filepath, options = {}) {
        try {
          let buffer = await this._readFile(filepath, options);
          if (typeof buffer !== "string") {
            buffer = Buffer.from(buffer);
          }
          return buffer;
        } catch (err) {
          return null;
        }
      }
      /**
       * Write a file (creating missing directories if need be) without throwing errors.
       *
       * @param {string} filepath
       * @param {Buffer|Uint8Array|string} contents
       * @param {object|string} [options]
       */
      async write(filepath, contents, options = {}) {
        try {
          await this._writeFile(filepath, contents, options);
          return;
        } catch (err) {
          await this.mkdir(dirname(filepath));
          await this._writeFile(filepath, contents, options);
        }
      }
      /**
       * Make a directory (or series of nested directories) without throwing an error if it already exists.
       */
      async mkdir(filepath, _selfCall = false) {
        try {
          await this._mkdir(filepath);
          return;
        } catch (err) {
          if (err === null)
            return;
          if (err.code === "EEXIST")
            return;
          if (_selfCall)
            throw err;
          if (err.code === "ENOENT") {
            const parent = dirname(filepath);
            if (parent === "." || parent === "/" || parent === filepath)
              throw err;
            await this.mkdir(parent);
            await this.mkdir(filepath, true);
          }
        }
      }
      /**
       * Delete a file without throwing an error if it is already deleted.
       */
      async rm(filepath) {
        try {
          await this._unlink(filepath);
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
      }
      /**
       * Delete a directory without throwing an error if it is already deleted.
       */
      async rmdir(filepath, opts) {
        try {
          if (opts && opts.recursive) {
            await this._rm(filepath, opts);
          } else {
            await this._rmdir(filepath);
          }
        } catch (err) {
          if (err.code !== "ENOENT")
            throw err;
        }
      }
      /**
       * Read a directory without throwing an error is the directory doesn't exist
       */
      async readdir(filepath) {
        try {
          const names = await this._readdir(filepath);
          names.sort(compareStrings);
          return names;
        } catch (err) {
          if (err.code === "ENOTDIR")
            return null;
          return [];
        }
      }
      /**
       * Return a flast list of all the files nested inside a directory
       *
       * Based on an elegant concurrent recursive solution from SO
       * https://stackoverflow.com/a/45130990/2168416
       */
      async readdirDeep(dir) {
        const subdirs = await this._readdir(dir);
        const files = await Promise.all(
          subdirs.map(async (subdir) => {
            const res = dir + "/" + subdir;
            return (await this._stat(res)).isDirectory() ? this.readdirDeep(res) : res;
          })
        );
        return files.reduce((a2, f4) => a2.concat(f4), []);
      }
      /**
       * Return the Stats of a file/symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existence.
       */
      async lstat(filename) {
        try {
          const stats = await this._lstat(filename);
          return stats;
        } catch (err) {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        }
      }
      /**
       * Reads the contents of a symlink if it exists, otherwise returns null.
       * Rethrows errors that aren't related to file existence.
       */
      async readlink(filename, opts = { encoding: "buffer" }) {
        try {
          const link = await this._readlink(filename, opts);
          return Buffer.isBuffer(link) ? link : Buffer.from(link);
        } catch (err) {
          if (err.code === "ENOENT") {
            return null;
          }
          throw err;
        }
      }
      /**
       * Write the contents of buffer to a symlink.
       */
      async writelink(filename, buffer) {
        return this._symlink(buffer.toString("utf8"), filename);
      }
    };
    GitIgnoreManager = class {
      static async isIgnored({ fs, dir, gitdir = join(dir, ".git"), filepath }) {
        if (basename(filepath) === ".git")
          return true;
        if (filepath === ".")
          return false;
        let excludes = "";
        const excludesFile = join(gitdir, "info", "exclude");
        if (await fs.exists(excludesFile)) {
          excludes = await fs.read(excludesFile, "utf8");
        }
        const pairs = [
          {
            gitignore: join(dir, ".gitignore"),
            filepath
          }
        ];
        const pieces = filepath.split("/").filter(Boolean);
        for (let i4 = 1; i4 < pieces.length; i4++) {
          const folder = pieces.slice(0, i4).join("/");
          const file = pieces.slice(i4).join("/");
          pairs.push({
            gitignore: join(dir, folder, ".gitignore"),
            filepath: file
          });
        }
        let ignoredStatus = false;
        for (const p2 of pairs) {
          let file;
          try {
            file = await fs.read(p2.gitignore, "utf8");
          } catch (err) {
            if (err.code === "NOENT")
              continue;
          }
          const ign = (0, import_ignore.default)().add(excludes);
          ign.add(file);
          const parentdir = dirname(p2.filepath);
          if (parentdir !== "." && ign.ignores(parentdir))
            return true;
          if (ignoredStatus) {
            ignoredStatus = !ign.test(p2.filepath).unignored;
          } else {
            ignoredStatus = ign.test(p2.filepath).ignored;
          }
        }
        return ignoredStatus;
      }
    };
    supportsCompressionStream = null;
    worthWalking = (filepath, root) => {
      if (filepath === "." || root == null || root.length === 0 || root === "." || root === filepath) {
        return true;
      }
      if (root.length > filepath.length) {
        return root.startsWith(filepath + "/");
      } else {
        return filepath.startsWith(root + "/");
      }
    };
    abbreviateRx = new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");
    GitPktLine = class {
      static flush() {
        return Buffer.from("0000", "utf8");
      }
      static delim() {
        return Buffer.from("0001", "utf8");
      }
      static encode(line) {
        if (typeof line === "string") {
          line = Buffer.from(line);
        }
        const length = line.length + 4;
        const hexlength = padHex(4, length);
        return Buffer.concat([Buffer.from(hexlength, "utf8"), line]);
      }
      static streamReader(stream) {
        const reader = new StreamReader(stream);
        return async function read() {
          try {
            let length = await reader.read(4);
            if (length == null)
              return true;
            length = parseInt(length.toString("utf8"), 16);
            if (length === 0)
              return null;
            if (length === 1)
              return null;
            const buffer = await reader.read(length - 4);
            if (buffer == null)
              return true;
            return buffer;
          } catch (err) {
            stream.error = err;
            return true;
          }
        };
      }
    };
    corsProxify = (corsProxy, url) => corsProxy.endsWith("?") ? `${corsProxy}${url}` : `${corsProxy}/${url.replace(/^https?:\/\//, "")}`;
    updateHeaders = (headers, auth) => {
      if (auth.username || auth.password) {
        headers.Authorization = calculateBasicAuthHeader(auth);
      }
      if (auth.headers) {
        Object.assign(headers, auth.headers);
      }
    };
    stringifyBody = async (res) => {
      try {
        const data = Buffer.from(await collect(res.body));
        const response = data.toString("utf8");
        const preview = response.length < 256 ? response : response.slice(0, 256) + "...";
        return { preview, response, data };
      } catch (e6) {
        return {};
      }
    };
    GitRemoteHTTP = class {
      static async capabilities() {
        return ["discover", "connect"];
      }
      /**
       * @param {Object} args
       * @param {HttpClient} args.http
       * @param {ProgressCallback} [args.onProgress]
       * @param {AuthCallback} [args.onAuth]
       * @param {AuthFailureCallback} [args.onAuthFailure]
       * @param {AuthSuccessCallback} [args.onAuthSuccess]
       * @param {string} [args.corsProxy]
       * @param {string} args.service
       * @param {string} args.url
       * @param {Object<string, string>} args.headers
       * @param {1 | 2} args.protocolVersion - Git Protocol Version
       */
      static async discover({
        http,
        onProgress,
        onAuth,
        onAuthSuccess,
        onAuthFailure,
        corsProxy,
        service,
        url: _origUrl,
        headers,
        protocolVersion
      }) {
        let { url, auth } = extractAuthFromUrl(_origUrl);
        const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
        if (auth.username || auth.password) {
          headers.Authorization = calculateBasicAuthHeader(auth);
        }
        if (protocolVersion === 2) {
          headers["Git-Protocol"] = "version=2";
        }
        let res;
        let tryAgain;
        let providedAuthBefore = false;
        do {
          res = await http.request({
            onProgress,
            method: "GET",
            url: `${proxifiedURL}/info/refs?service=${service}`,
            headers
          });
          tryAgain = false;
          if (res.statusCode === 401 || res.statusCode === 203) {
            const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
            if (getAuth) {
              auth = await getAuth(url, {
                ...auth,
                headers: { ...headers }
              });
              if (auth && auth.cancel) {
                throw new UserCanceledError();
              } else if (auth) {
                updateHeaders(headers, auth);
                providedAuthBefore = true;
                tryAgain = true;
              }
            }
          } else if (res.statusCode === 200 && providedAuthBefore && onAuthSuccess) {
            await onAuthSuccess(url, auth);
          }
        } while (tryAgain);
        if (res.statusCode !== 200) {
          const { response } = await stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        if (res.headers["content-type"] === `application/x-${service}-advertisement`) {
          const remoteHTTP = await parseRefsAdResponse(res.body, { service });
          remoteHTTP.auth = auth;
          return remoteHTTP;
        } else {
          const { preview, response, data } = await stringifyBody(res);
          try {
            const remoteHTTP = await parseRefsAdResponse([data], { service });
            remoteHTTP.auth = auth;
            return remoteHTTP;
          } catch (e6) {
            throw new SmartHttpError(preview, response);
          }
        }
      }
      /**
       * @param {Object} args
       * @param {HttpClient} args.http
       * @param {ProgressCallback} [args.onProgress]
       * @param {string} [args.corsProxy]
       * @param {string} args.service
       * @param {string} args.url
       * @param {Object<string, string>} [args.headers]
       * @param {any} args.body
       * @param {any} args.auth
       */
      static async connect({
        http,
        onProgress,
        corsProxy,
        service,
        url,
        auth,
        body,
        headers
      }) {
        const urlAuth = extractAuthFromUrl(url);
        if (urlAuth)
          url = urlAuth.url;
        if (corsProxy)
          url = corsProxify(corsProxy, url);
        headers["content-type"] = `application/x-${service}-request`;
        headers.accept = `application/x-${service}-result`;
        updateHeaders(headers, auth);
        const res = await http.request({
          onProgress,
          method: "POST",
          url: `${url}/${service}`,
          body,
          headers
        });
        if (res.statusCode !== 200) {
          const { response } = stringifyBody(res);
          throw new HttpError(res.statusCode, res.statusMessage, response);
        }
        return res;
      }
    };
    GitRemoteManager = class {
      static getRemoteHelperFor({ url }) {
        const remoteHelpers = /* @__PURE__ */ new Map();
        remoteHelpers.set("http", GitRemoteHTTP);
        remoteHelpers.set("https", GitRemoteHTTP);
        const parts = parseRemoteUrl({ url });
        if (!parts) {
          throw new UrlParseError(url);
        }
        if (remoteHelpers.has(parts.transport)) {
          return remoteHelpers.get(parts.transport);
        }
        throw new UnknownTransportError(
          url,
          parts.transport,
          parts.transport === "ssh" ? translateSSHtoHTTP(url) : void 0
        );
      }
    };
    lock$2 = null;
    GitShallowManager = class {
      static async read({ fs, gitdir }) {
        if (lock$2 === null)
          lock$2 = new import_async_lock.default();
        const filepath = join(gitdir, "shallow");
        const oids = /* @__PURE__ */ new Set();
        await lock$2.acquire(filepath, async function() {
          const text = await fs.read(filepath, { encoding: "utf8" });
          if (text === null)
            return oids;
          if (text.trim() === "")
            return oids;
          text.trim().split("\n").map((oid) => oids.add(oid));
        });
        return oids;
      }
      static async write({ fs, gitdir, oids }) {
        if (lock$2 === null)
          lock$2 = new import_async_lock.default();
        const filepath = join(gitdir, "shallow");
        if (oids.size > 0) {
          const text = [...oids].join("\n") + "\n";
          await lock$2.acquire(filepath, async function() {
            await fs.write(filepath, text, {
              encoding: "utf8"
            });
          });
        } else {
          await lock$2.acquire(filepath, async function() {
            await fs.rm(filepath);
          });
        }
      }
    };
    pkg = {
      name: "isomorphic-git",
      version: "0.0.0-development",
      agent: "git/isomorphic-git@0.0.0-development"
    };
    FIFO = class {
      constructor() {
        this._queue = [];
      }
      write(chunk) {
        if (this._ended) {
          throw Error("You cannot write to a FIFO that has already been ended!");
        }
        if (this._waiting) {
          const resolve = this._waiting;
          this._waiting = null;
          resolve({ value: chunk });
        } else {
          this._queue.push(chunk);
        }
      }
      end() {
        this._ended = true;
        if (this._waiting) {
          const resolve = this._waiting;
          this._waiting = null;
          resolve({ done: true });
        }
      }
      destroy(err) {
        this.error = err;
        this.end();
      }
      async next() {
        if (this._queue.length > 0) {
          return { value: this._queue.shift() };
        }
        if (this._ended) {
          return { done: true };
        }
        if (this._waiting) {
          throw Error(
            "You cannot call read until the previous call to read has returned!"
          );
        }
        return new Promise((resolve) => {
          this._waiting = resolve;
        });
      }
    };
    GitSideBand = class {
      static demux(input) {
        const read = GitPktLine.streamReader(input);
        const packetlines = new FIFO();
        const packfile = new FIFO();
        const progress = new FIFO();
        const nextBit = async function() {
          const line = await read();
          if (line === null)
            return nextBit();
          if (line === true) {
            packetlines.end();
            progress.end();
            input.error ? packfile.destroy(input.error) : packfile.end();
            return;
          }
          switch (line[0]) {
            case 1: {
              packfile.write(line.slice(1));
              break;
            }
            case 2: {
              progress.write(line.slice(1));
              break;
            }
            case 3: {
              const error = line.slice(1);
              progress.write(error);
              packetlines.end();
              progress.end();
              packfile.destroy(new Error(error.toString("utf8")));
              return;
            }
            default: {
              packetlines.write(line);
            }
          }
          nextBit();
        };
        nextBit();
        return {
          packetlines,
          packfile,
          progress
        };
      }
      // static mux ({
      //   protocol, // 'side-band' or 'side-band-64k'
      //   packetlines,
      //   packfile,
      //   progress,
      //   error
      // }) {
      //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
      //   let output = new PassThrough()
      //   packetlines.on('data', data => {
      //     if (data === null) {
      //       output.write(GitPktLine.flush())
      //     } else {
      //       output.write(GitPktLine.encode(data))
      //     }
      //   })
      //   let packfileWasEmpty = true
      //   let packfileEnded = false
      //   let progressEnded = false
      //   let errorEnded = false
      //   let goodbye = Buffer.concat([
      //     GitPktLine.encode(Buffer.from('010A', 'hex')),
      //     GitPktLine.flush()
      //   ])
      //   packfile
      //     .on('data', data => {
      //       packfileWasEmpty = false
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       packfileEnded = true
      //       if (!packfileWasEmpty) output.write(goodbye)
      //       if (progressEnded && errorEnded) output.end()
      //     })
      //   progress
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       progressEnded = true
      //       if (packfileEnded && errorEnded) output.end()
      //     })
      //   error
      //     .on('data', data => {
      //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
      //       for (const buffer of buffers) {
      //         output.write(
      //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
      //         )
      //       }
      //     })
      //     .on('end', () => {
      //       errorEnded = true
      //       if (progressEnded && packfileEnded) output.end()
      //     })
      //   return output
      // }
    };
    LINEBREAKS = /^.*(\r?\n|$)/gm;
    EMPTY_OID = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
    types = {
      commit: 16,
      tree: 32,
      blob: 48,
      tag: 64,
      ofs_delta: 96,
      ref_delta: 112
    };
    deepget = (keys, map) => {
      for (const key of keys) {
        if (!map.has(key))
          map.set(key, /* @__PURE__ */ new Map());
        map = map.get(key);
      }
      return map;
    };
    DeepMap = class {
      constructor() {
        this._root = /* @__PURE__ */ new Map();
      }
      set(keys, value) {
        const lastKey = keys.pop();
        const lastMap = deepget(keys, this._root);
        lastMap.set(lastKey, value);
      }
      get(keys) {
        const lastKey = keys.pop();
        const lastMap = deepget(keys, this._root);
        return lastMap.get(lastKey);
      }
      has(keys) {
        const lastKey = keys.pop();
        const lastMap = deepget(keys, this._root);
        return lastMap.has(lastKey);
      }
    };
    index = {
      Errors,
      STAGE,
      TREE,
      WORKDIR,
      add,
      abortMerge,
      addNote,
      addRemote,
      annotatedTag,
      branch,
      checkout,
      clone,
      commit,
      getConfig,
      getConfigAll,
      setConfig,
      currentBranch,
      deleteBranch,
      deleteRef,
      deleteRemote,
      deleteTag,
      expandOid,
      expandRef,
      fastForward,
      fetch: fetch2,
      findMergeBase,
      findRoot,
      getRemoteInfo,
      getRemoteInfo2,
      hashBlob,
      indexPack,
      init,
      isDescendent,
      isIgnored,
      listBranches,
      listFiles,
      listNotes,
      listRemotes,
      listServerRefs,
      listTags,
      log,
      merge,
      packObjects,
      pull,
      push,
      readBlob,
      readCommit,
      readNote,
      readObject,
      readTag,
      readTree,
      remove,
      removeNote,
      renameBranch,
      resetIndex,
      updateIndex,
      resolveRef,
      status,
      statusMatrix,
      tag,
      version,
      walk,
      _walk,
      writeBlob,
      writeCommit,
      writeObject,
      writeRef,
      writeTag,
      writeTree,
      _listObjects: listObjects,
      _pack,
      _uploadPack: uploadPack,
      _GitConfigManager: GitConfigManager,
      _GitIgnoreManager: GitIgnoreManager,
      _GitIndexManager: GitIndexManager,
      _GitRefManager: GitRefManager,
      _GitRemoteHTTP: GitRemoteHTTP,
      _GitRemoteManager: GitRemoteManager,
      _GitShallowManager: GitShallowManager,
      _FileSystem: FileSystem,
      _GitAnnotatedTag: GitAnnotatedTag,
      _GitCommit: GitCommit,
      _GitConfig: GitConfig,
      _GitIndex: GitIndex,
      _GitObject: GitObject,
      _GitPackIndex: GitPackIndex,
      _GitPktLine: GitPktLine,
      _GitRefSpec: GitRefSpec,
      _GitRefSpecSet: GitRefSpecSet,
      _GitSideBand: GitSideBand,
      _GitTree: GitTree,
      _GitWalkerFs: GitWalkerFs,
      _GitWalkerIndex: GitWalkerIndex,
      _GitWalkerRepo: GitWalkerRepo,
      _RunningMinimum: RunningMinimum,
      _expandOid,
      _expandOidLoose: expandOidLoose,
      _expandOidPacked: expandOidPacked,
      _hasObject: hasObject,
      _hasObjectLoose: hasObjectLoose,
      _hasObjectPacked: hasObjectPacked,
      _hashObject: hashObject,
      _readObject,
      _readObjectLoose: readObjectLoose,
      _readObjectPacked: readObjectPacked,
      _readPackIndex: readPackIndex,
      _writeObject,
      _writeObjectLoose: writeObjectLoose,
      _BufferCursor: BufferCursor,
      _DeepMap: DeepMap,
      _FIFO: FIFO,
      _StreamReader: StreamReader,
      _abbreviateRef: abbreviateRef,
      _applyDelta: applyDelta,
      _arrayRange: arrayRange,
      _assertParameter: assertParameter,
      // _asyncIteratorToStream,
      _basename: basename,
      _calculateBasicAuthHeader: calculateBasicAuthHeader,
      _collect: collect,
      _compareAge: compareAge,
      _comparePath: comparePath,
      _compareRefNames: compareRefNames,
      _compareStats: compareStats,
      _compareStrings: compareStrings,
      _compareTreeEntryPath: compareTreeEntryPath,
      _deflate: deflate,
      _dirname: dirname,
      _emptyPackfile: emptyPackfile,
      _extractAuthFromUrl: extractAuthFromUrl,
      _filterCapabilities: filterCapabilities,
      _flat: flat,
      _flatFileListToDirectoryStructure: flatFileListToDirectoryStructure,
      _forAwait: forAwait,
      _formatAuthor: formatAuthor,
      _formatInfoRefs: formatInfoRefs,
      _fromEntries: fromEntries,
      _fromNodeStream: fromNodeStream,
      _fromStream: fromStream,
      _fromValue: fromValue,
      _getIterator: getIterator,
      _listpack: listpack,
      _utils_hashObject: hashObject$1,
      _indent: indent,
      _inflate: inflate,
      _isBinary: isBinary,
      _join: join,
      _mergeFile: mergeFile,
      _mergeTree: mergeTree,
      _mode2type: mode2type,
      _modified: modified,
      _normalizeAuthorObject: normalizeAuthorObject,
      _normalizeCommitterObject: normalizeCommitterObject,
      _normalizeMode: normalizeMode,
      _normalizeNewlines: normalizeNewlines,
      _normalizePath: normalizePath2,
      _normalizeStats: normalizeStats,
      _outdent: outdent,
      _padHex: padHex,
      _parseAuthor: parseAuthor,
      _pkg: pkg,
      _posixifyPathBuffer: posixifyPathBuffer,
      _resolveBlob: resolveBlob,
      _resolveCommit: resolveCommit,
      _resolveFileIdInTree: resolveFileIdInTree,
      _resolveFilepath: resolveFilepath,
      _resolveTree: resolveTree,
      _rmRecursive: rmRecursive,
      _shasum: shasum,
      _sleep: sleep,
      _splitLines: splitLines,
      // _symbols,
      _toHex: toHex,
      _translateSSHtoHTTP: translateSSHtoHTTP,
      _unionOfIterators: unionOfIterators,
      _worthWalking: worthWalking,
      _parseCapabilitiesV2: parseCapabilitiesV2,
      _parseListRefsResponse: parseListRefsResponse,
      _parseReceivePackResponse: parseReceivePackResponse,
      _parseRefsAdResponse: parseRefsAdResponse,
      _parseUploadPackRequest: parseUploadPackRequest,
      _parseUploadPackResponse: parseUploadPackResponse,
      _writeListRefsRequest: writeListRefsRequest,
      _writeReceivePackRequest: writeReceivePackRequest,
      _writeRefsAdResponse: writeRefsAdResponse,
      _writeUploadPackRequest: writeUploadPackRequest
    };
    isomorphic_git_default = index;
  }
});

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t5, e6, o5) {
    if (this._$cssResult$ = true, o5 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t5, this.t = e6;
  }
  get styleSheet() {
    let t5 = this.o;
    const s2 = this.t;
    if (e && void 0 === t5) {
      const e6 = void 0 !== s2 && 1 === s2.length;
      e6 && (t5 = o.get(s2)), void 0 === t5 && ((this.o = t5 = new CSSStyleSheet()).replaceSync(this.cssText), e6 && o.set(s2, t5));
    }
    return t5;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t5) => new n("string" == typeof t5 ? t5 : t5 + "", void 0, s);
var i = (t5, ...e6) => {
  const o5 = 1 === t5.length ? t5[0] : e6.reduce((e7, s2, o6) => e7 + ((t6) => {
    if (true === t6._$cssResult$)
      return t6.cssText;
    if ("number" == typeof t6)
      return t6;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t6 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t5[o6 + 1], t5[0]);
  return new n(o5, t5, s);
};
var S = (s2, o5) => {
  if (e)
    s2.adoptedStyleSheets = o5.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet);
  else
    for (const e6 of o5) {
      const o6 = document.createElement("style"), n5 = t.litNonce;
      void 0 !== n5 && o6.setAttribute("nonce", n5), o6.textContent = e6.cssText, s2.appendChild(o6);
    }
};
var c = e ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
  let e6 = "";
  for (const s2 of t6.cssRules)
    e6 += s2.cssText;
  return r(e6);
})(t5) : t5;

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/reactive-element.js
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t5, s2) => t5;
var u = { toAttribute(t5, s2) {
  switch (s2) {
    case Boolean:
      t5 = t5 ? l : null;
      break;
    case Object:
    case Array:
      t5 = null == t5 ? t5 : JSON.stringify(t5);
  }
  return t5;
}, fromAttribute(t5, s2) {
  let i4 = t5;
  switch (s2) {
    case Boolean:
      i4 = null !== t5;
      break;
    case Number:
      i4 = null === t5 ? null : Number(t5);
      break;
    case Object:
    case Array:
      try {
        i4 = JSON.parse(t5);
      } catch (t6) {
        i4 = null;
      }
  }
  return i4;
} };
var f = (t5, s2) => !i2(t5, s2);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
Symbol.metadata ??= Symbol("metadata"), a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b = class extends HTMLElement {
  static addInitializer(t5) {
    this._$Ei(), (this.l ??= []).push(t5);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t5, s2 = y) {
    if (s2.state && (s2.attribute = false), this._$Ei(), this.elementProperties.set(t5, s2), !s2.noAccessor) {
      const i4 = Symbol(), r6 = this.getPropertyDescriptor(t5, i4, s2);
      void 0 !== r6 && e2(this.prototype, t5, r6);
    }
  }
  static getPropertyDescriptor(t5, s2, i4) {
    const { get: e6, set: h4 } = r2(this.prototype, t5) ?? { get() {
      return this[s2];
    }, set(t6) {
      this[s2] = t6;
    } };
    return { get() {
      return e6?.call(this);
    }, set(s3) {
      const r6 = e6?.call(this);
      h4.call(this, s3), this.requestUpdate(t5, r6, i4);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t5) {
    return this.elementProperties.get(t5) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties")))
      return;
    const t5 = n2(this);
    t5.finalize(), void 0 !== t5.l && (this.l = [...t5.l]), this.elementProperties = new Map(t5.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t6 = this.properties, s2 = [...h(t6), ...o2(t6)];
      for (const i4 of s2)
        this.createProperty(i4, t6[i4]);
    }
    const t5 = this[Symbol.metadata];
    if (null !== t5) {
      const s2 = litPropertyMetadata.get(t5);
      if (void 0 !== s2)
        for (const [t6, i4] of s2)
          this.elementProperties.set(t6, i4);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t6, s2] of this.elementProperties) {
      const i4 = this._$Eu(t6, s2);
      void 0 !== i4 && this._$Eh.set(i4, t6);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s2) {
    const i4 = [];
    if (Array.isArray(s2)) {
      const e6 = new Set(s2.flat(1 / 0).reverse());
      for (const s3 of e6)
        i4.unshift(c(s3));
    } else
      void 0 !== s2 && i4.push(c(s2));
    return i4;
  }
  static _$Eu(t5, s2) {
    const i4 = s2.attribute;
    return false === i4 ? void 0 : "string" == typeof i4 ? i4 : "string" == typeof t5 ? t5.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t5) => this.enableUpdating = t5), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t5) => t5(this));
  }
  addController(t5) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t5), void 0 !== this.renderRoot && this.isConnected && t5.hostConnected?.();
  }
  removeController(t5) {
    this._$EO?.delete(t5);
  }
  _$E_() {
    const t5 = /* @__PURE__ */ new Map(), s2 = this.constructor.elementProperties;
    for (const i4 of s2.keys())
      this.hasOwnProperty(i4) && (t5.set(i4, this[i4]), delete this[i4]);
    t5.size > 0 && (this._$Ep = t5);
  }
  createRenderRoot() {
    const t5 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t5, this.constructor.elementStyles), t5;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t5) => t5.hostConnected?.());
  }
  enableUpdating(t5) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t5) => t5.hostDisconnected?.());
  }
  attributeChangedCallback(t5, s2, i4) {
    this._$AK(t5, i4);
  }
  _$EC(t5, s2) {
    const i4 = this.constructor.elementProperties.get(t5), e6 = this.constructor._$Eu(t5, i4);
    if (void 0 !== e6 && true === i4.reflect) {
      const r6 = (void 0 !== i4.converter?.toAttribute ? i4.converter : u).toAttribute(s2, i4.type);
      this._$Em = t5, null == r6 ? this.removeAttribute(e6) : this.setAttribute(e6, r6), this._$Em = null;
    }
  }
  _$AK(t5, s2) {
    const i4 = this.constructor, e6 = i4._$Eh.get(t5);
    if (void 0 !== e6 && this._$Em !== e6) {
      const t6 = i4.getPropertyOptions(e6), r6 = "function" == typeof t6.converter ? { fromAttribute: t6.converter } : void 0 !== t6.converter?.fromAttribute ? t6.converter : u;
      this._$Em = e6, this[e6] = r6.fromAttribute(s2, t6.type), this._$Em = null;
    }
  }
  requestUpdate(t5, s2, i4) {
    if (void 0 !== t5) {
      if (i4 ??= this.constructor.getPropertyOptions(t5), !(i4.hasChanged ?? f)(this[t5], s2))
        return;
      this.P(t5, s2, i4);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t5, s2, i4) {
    this._$AL.has(t5) || this._$AL.set(t5, s2), true === i4.reflect && this._$Em !== t5 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t5);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t6) {
      Promise.reject(t6);
    }
    const t5 = this.scheduleUpdate();
    return null != t5 && await t5, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t7, s3] of this._$Ep)
          this[t7] = s3;
        this._$Ep = void 0;
      }
      const t6 = this.constructor.elementProperties;
      if (t6.size > 0)
        for (const [s3, i4] of t6)
          true !== i4.wrapped || this._$AL.has(s3) || void 0 === this[s3] || this.P(s3, this[s3], i4);
    }
    let t5 = false;
    const s2 = this._$AL;
    try {
      t5 = this.shouldUpdate(s2), t5 ? (this.willUpdate(s2), this._$EO?.forEach((t6) => t6.hostUpdate?.()), this.update(s2)) : this._$EU();
    } catch (s3) {
      throw t5 = false, this._$EU(), s3;
    }
    t5 && this._$AE(s2);
  }
  willUpdate(t5) {
  }
  _$AE(t5) {
    this._$EO?.forEach((t6) => t6.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t5) {
    return true;
  }
  update(t5) {
    this._$Ej &&= this._$Ej.forEach((t6) => this._$EC(t6, this[t6])), this._$EU();
  }
  updated(t5) {
  }
  firstUpdated(t5) {
  }
};
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: b }), (a.reactiveElementVersions ??= []).push("2.0.4");

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/lit-html.js
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
var f2 = "$lit$";
var v = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m = "?" + v;
var _ = `<${m}>`;
var w = document;
var lt = () => w.createComment("");
var st = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
var g = Array.isArray;
var $ = (t5) => g(t5) || "function" == typeof t5?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t5) => (i4, ...s2) => ({ _$litType$: t5, strings: i4, values: s2 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t5, i4) {
  if (!g(t5) || !t5.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i4) : i4;
}
var U = (t5, i4) => {
  const s2 = t5.length - 1, e6 = [];
  let h4, o5 = 2 === i4 ? "<svg>" : 3 === i4 ? "<math>" : "", n5 = T;
  for (let i5 = 0; i5 < s2; i5++) {
    const s3 = t5[i5];
    let r6, l2, c4 = -1, a2 = 0;
    for (; a2 < s3.length && (n5.lastIndex = a2, l2 = n5.exec(s3), null !== l2); )
      a2 = n5.lastIndex, n5 === T ? "!--" === l2[1] ? n5 = E : void 0 !== l2[1] ? n5 = k : void 0 !== l2[2] ? (M.test(l2[2]) && (h4 = RegExp("</" + l2[2], "g")), n5 = O) : void 0 !== l2[3] && (n5 = O) : n5 === O ? ">" === l2[0] ? (n5 = h4 ?? T, c4 = -1) : void 0 === l2[1] ? c4 = -2 : (c4 = n5.lastIndex - l2[2].length, r6 = l2[1], n5 = void 0 === l2[3] ? O : '"' === l2[3] ? j : S2) : n5 === j || n5 === S2 ? n5 = O : n5 === E || n5 === k ? n5 = T : (n5 = O, h4 = void 0);
    const u2 = n5 === O && t5[i5 + 1].startsWith("/>") ? " " : "";
    o5 += n5 === T ? s3 + _ : c4 >= 0 ? (e6.push(r6), s3.slice(0, c4) + f2 + s3.slice(c4) + v + u2) : s3 + v + (-2 === c4 ? i5 : u2);
  }
  return [N(t5, o5 + (t5[s2] || "<?>") + (2 === i4 ? "</svg>" : 3 === i4 ? "</math>" : "")), e6];
};
var B = class _B {
  constructor({ strings: t5, _$litType$: i4 }, s2) {
    let e6;
    this.parts = [];
    let h4 = 0, o5 = 0;
    const n5 = t5.length - 1, r6 = this.parts, [l2, a2] = U(t5, i4);
    if (this.el = _B.createElement(l2, s2), I.currentNode = this.el.content, 2 === i4 || 3 === i4) {
      const t6 = this.el.content.firstChild;
      t6.replaceWith(...t6.childNodes);
    }
    for (; null !== (e6 = I.nextNode()) && r6.length < n5; ) {
      if (1 === e6.nodeType) {
        if (e6.hasAttributes())
          for (const t6 of e6.getAttributeNames())
            if (t6.endsWith(f2)) {
              const i5 = a2[o5++], s3 = e6.getAttribute(t6).split(v), n6 = /([.?@])?(.*)/.exec(i5);
              r6.push({ type: 1, index: h4, name: n6[2], strings: s3, ctor: "." === n6[1] ? Y : "?" === n6[1] ? Z : "@" === n6[1] ? q : G }), e6.removeAttribute(t6);
            } else
              t6.startsWith(v) && (r6.push({ type: 6, index: h4 }), e6.removeAttribute(t6));
        if (M.test(e6.tagName)) {
          const t6 = e6.textContent.split(v), i5 = t6.length - 1;
          if (i5 > 0) {
            e6.textContent = c3 ? c3.emptyScript : "";
            for (let s3 = 0; s3 < i5; s3++)
              e6.append(t6[s3], lt()), I.nextNode(), r6.push({ type: 2, index: ++h4 });
            e6.append(t6[i5], lt());
          }
        }
      } else if (8 === e6.nodeType)
        if (e6.data === m)
          r6.push({ type: 2, index: h4 });
        else {
          let t6 = -1;
          for (; -1 !== (t6 = e6.data.indexOf(v, t6 + 1)); )
            r6.push({ type: 7, index: h4 }), t6 += v.length - 1;
        }
      h4++;
    }
  }
  static createElement(t5, i4) {
    const s2 = w.createElement("template");
    return s2.innerHTML = t5, s2;
  }
};
function z(t5, i4, s2 = t5, e6) {
  if (i4 === R)
    return i4;
  let h4 = void 0 !== e6 ? s2.o?.[e6] : s2.l;
  const o5 = st(i4) ? void 0 : i4._$litDirective$;
  return h4?.constructor !== o5 && (h4?._$AO?.(false), void 0 === o5 ? h4 = void 0 : (h4 = new o5(t5), h4._$AT(t5, s2, e6)), void 0 !== e6 ? (s2.o ??= [])[e6] = h4 : s2.l = h4), void 0 !== h4 && (i4 = z(t5, h4._$AS(t5, i4.values), h4, e6)), i4;
}
var F = class {
  constructor(t5, i4) {
    this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t5) {
    const { el: { content: i4 }, parts: s2 } = this._$AD, e6 = (t5?.creationScope ?? w).importNode(i4, true);
    I.currentNode = e6;
    let h4 = I.nextNode(), o5 = 0, n5 = 0, r6 = s2[0];
    for (; void 0 !== r6; ) {
      if (o5 === r6.index) {
        let i5;
        2 === r6.type ? i5 = new et(h4, h4.nextSibling, this, t5) : 1 === r6.type ? i5 = new r6.ctor(h4, r6.name, r6.strings, this, t5) : 6 === r6.type && (i5 = new K(h4, this, t5)), this._$AV.push(i5), r6 = s2[++n5];
      }
      o5 !== r6?.index && (h4 = I.nextNode(), o5++);
    }
    return I.currentNode = w, e6;
  }
  p(t5) {
    let i4 = 0;
    for (const s2 of this._$AV)
      void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t5, s2, i4), i4 += s2.strings.length - 2) : s2._$AI(t5[i4])), i4++;
  }
};
var et = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t5, i4, s2, e6) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t5, this._$AB = i4, this._$AM = s2, this.options = e6, this.v = e6?.isConnected ?? true;
  }
  get parentNode() {
    let t5 = this._$AA.parentNode;
    const i4 = this._$AM;
    return void 0 !== i4 && 11 === t5?.nodeType && (t5 = i4.parentNode), t5;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t5, i4 = this) {
    t5 = z(this, t5, i4), st(t5) ? t5 === D || null == t5 || "" === t5 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t5 !== this._$AH && t5 !== R && this._(t5) : void 0 !== t5._$litType$ ? this.$(t5) : void 0 !== t5.nodeType ? this.T(t5) : $(t5) ? this.k(t5) : this._(t5);
  }
  O(t5) {
    return this._$AA.parentNode.insertBefore(t5, this._$AB);
  }
  T(t5) {
    this._$AH !== t5 && (this._$AR(), this._$AH = this.O(t5));
  }
  _(t5) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t5 : this.T(w.createTextNode(t5)), this._$AH = t5;
  }
  $(t5) {
    const { values: i4, _$litType$: s2 } = t5, e6 = "number" == typeof s2 ? this._$AC(t5) : (void 0 === s2.el && (s2.el = B.createElement(N(s2.h, s2.h[0]), this.options)), s2);
    if (this._$AH?._$AD === e6)
      this._$AH.p(i4);
    else {
      const t6 = new F(e6, this), s3 = t6.u(this.options);
      t6.p(i4), this.T(s3), this._$AH = t6;
    }
  }
  _$AC(t5) {
    let i4 = V.get(t5.strings);
    return void 0 === i4 && V.set(t5.strings, i4 = new B(t5)), i4;
  }
  k(t5) {
    g(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s2, e6 = 0;
    for (const h4 of t5)
      e6 === i4.length ? i4.push(s2 = new _et(this.O(lt()), this.O(lt()), this, this.options)) : s2 = i4[e6], s2._$AI(h4), e6++;
    e6 < i4.length && (this._$AR(s2 && s2._$AB.nextSibling, e6), i4.length = e6);
  }
  _$AR(t5 = this._$AA.nextSibling, i4) {
    for (this._$AP?.(false, true, i4); t5 && t5 !== this._$AB; ) {
      const i5 = t5.nextSibling;
      t5.remove(), t5 = i5;
    }
  }
  setConnected(t5) {
    void 0 === this._$AM && (this.v = t5, this._$AP?.(t5));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t5, i4, s2, e6, h4) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t5, this.name = i4, this._$AM = e6, this.options = h4, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = D;
  }
  _$AI(t5, i4 = this, s2, e6) {
    const h4 = this.strings;
    let o5 = false;
    if (void 0 === h4)
      t5 = z(this, t5, i4, 0), o5 = !st(t5) || t5 !== this._$AH && t5 !== R, o5 && (this._$AH = t5);
    else {
      const e7 = t5;
      let n5, r6;
      for (t5 = h4[0], n5 = 0; n5 < h4.length - 1; n5++)
        r6 = z(this, e7[s2 + n5], i4, n5), r6 === R && (r6 = this._$AH[n5]), o5 ||= !st(r6) || r6 !== this._$AH[n5], r6 === D ? t5 = D : t5 !== D && (t5 += (r6 ?? "") + h4[n5 + 1]), this._$AH[n5] = r6;
    }
    o5 && !e6 && this.j(t5);
  }
  j(t5) {
    t5 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t5) {
    this.element[this.name] = t5 === D ? void 0 : t5;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t5) {
    this.element.toggleAttribute(this.name, !!t5 && t5 !== D);
  }
};
var q = class extends G {
  constructor(t5, i4, s2, e6, h4) {
    super(t5, i4, s2, e6, h4), this.type = 5;
  }
  _$AI(t5, i4 = this) {
    if ((t5 = z(this, t5, i4, 0) ?? D) === R)
      return;
    const s2 = this._$AH, e6 = t5 === D && s2 !== D || t5.capture !== s2.capture || t5.once !== s2.once || t5.passive !== s2.passive, h4 = t5 !== D && (s2 === D || e6);
    e6 && this.element.removeEventListener(this.name, this, s2), h4 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
  }
  handleEvent(t5) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t5) : this._$AH.handleEvent(t5);
  }
};
var K = class {
  constructor(t5, i4, s2) {
    this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t5) {
    z(this, t5);
  }
};
var si = { M: f2, P: v, A: m, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t5, i4, s2) => {
  const e6 = s2?.renderBefore ?? i4;
  let h4 = e6._$litPart$;
  if (void 0 === h4) {
    const t6 = s2?.renderBefore ?? null;
    e6._$litPart$ = h4 = new et(i4.insertBefore(lt(), t6), t6, void 0, s2 ?? {});
  }
  return h4._$AI(t5), h4;
};

// ../../../node_modules/.pnpm/lit-element@4.1.0/node_modules/lit-element/lit-element.js
var h3 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t5 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t5.firstChild, t5;
  }
  update(t5) {
    const e6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this.o = Q(e6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/custom-element.js
var t2 = (t5) => (e6, o5) => {
  void 0 !== o5 ? o5.addInitializer(() => {
    customElements.define(t5, e6);
  }) : customElements.define(t5, e6);
};

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/property.js
var o3 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r3 = (t5 = o3, e6, r6) => {
  const { kind: n5, metadata: i4 } = r6;
  let s2 = globalThis.litPropertyMetadata.get(i4);
  if (void 0 === s2 && globalThis.litPropertyMetadata.set(i4, s2 = /* @__PURE__ */ new Map()), s2.set(r6.name, t5), "accessor" === n5) {
    const { name: o5 } = r6;
    return { set(r7) {
      const n6 = e6.get.call(this);
      e6.set.call(this, r7), this.requestUpdate(o5, n6, t5);
    }, init(e7) {
      return void 0 !== e7 && this.P(o5, void 0, t5), e7;
    } };
  }
  if ("setter" === n5) {
    const { name: o5 } = r6;
    return function(r7) {
      const n6 = this[o5];
      e6.call(this, r7), this.requestUpdate(o5, n6, t5);
    };
  }
  throw Error("Unsupported decorator location: " + n5);
};
function n4(t5) {
  return (e6, o5) => "object" == typeof o5 ? r3(t5, e6, o5) : ((t6, e7, o6) => {
    const r6 = e7.hasOwnProperty(o6);
    return e7.constructor.createProperty(o6, r6 ? { ...t6, wrapped: true } : t6), r6 ? Object.getOwnPropertyDescriptor(e7, o6) : void 0;
  })(t5, e6, o5);
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/state.js
function r4(r6) {
  return n4({ ...r6, state: true, attribute: false });
}

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/base.js
var e3 = (e6, t5, c4) => (c4.configurable = true, c4.enumerable = true, Reflect.decorate && "object" != typeof t5 && Object.defineProperty(e6, t5, c4), c4);

// ../../../node_modules/.pnpm/@lit+reactive-element@2.0.4/node_modules/@lit/reactive-element/decorators/query.js
function e4(e6, r6) {
  return (n5, s2, i4) => {
    const o5 = (t5) => t5.renderRoot?.querySelector(e6) ?? null;
    if (r6) {
      const { get: e7, set: r7 } = "object" == typeof s2 ? n5 : i4 ?? (() => {
        const t5 = Symbol();
        return { get() {
          return this[t5];
        }, set(e8) {
          this[t5] = e8;
        } };
      })();
      return e3(n5, s2, { get() {
        let t5 = e7.call(this);
        return void 0 === t5 && (t5 = o5(this), (null !== t5 || this.hasUpdated) && r7.call(this, t5)), t5;
      } });
    }
    return e3(n5, s2, { get() {
      return o5(this);
    } });
  };
}

// src/styling/base.ts
var baseStyling = i`
	:host {
		font-family: "Inter", sans-serif;

		/*
		* Color Primitives
		*/

		/* Gray */
		--sl-color-gray-50: hsl(0 0% 97.5%);
		--sl-color-gray-100: hsl(240 4.8% 95.9%);
		--sl-color-gray-200: hsl(240 5.9% 90%);
		--sl-color-gray-300: hsl(240 4.9% 83.9%);
		--sl-color-gray-400: hsl(240 5% 64.9%);
		--sl-color-gray-500: hsl(240 3.8% 46.1%);
		--sl-color-gray-600: hsl(240 5.2% 33.9%);
		--sl-color-gray-700: hsl(240 5.3% 26.1%);
		--sl-color-gray-800: hsl(240 3.7% 15.9%);
		--sl-color-gray-900: hsl(240 5.9% 10%);
		--sl-color-gray-950: hsl(240 7.3% 8%);

		/* Red */
		--sl-color-red-50: hsl(0 85.7% 97.3%);
		--sl-color-red-100: hsl(0 93.3% 94.1%);
		--sl-color-red-200: hsl(0 96.3% 89.4%);
		--sl-color-red-300: hsl(0 93.5% 81.8%);
		--sl-color-red-400: hsl(0 90.6% 70.8%);
		--sl-color-red-500: hsl(0 84.2% 60.2%);
		--sl-color-red-600: hsl(0 72.2% 50.6%);
		--sl-color-red-700: hsl(0 73.7% 41.8%);
		--sl-color-red-800: hsl(0 70% 35.3%);
		--sl-color-red-900: hsl(0 62.8% 30.6%);
		--sl-color-red-950: hsl(0 60% 19.6%);

		/* Orange */
		--sl-color-orange-50: hsl(33.3 100% 96.5%);
		--sl-color-orange-100: hsl(34.3 100% 91.8%);
		--sl-color-orange-200: hsl(32.1 97.7% 83.1%);
		--sl-color-orange-300: hsl(30.7 97.2% 72.4%);
		--sl-color-orange-400: hsl(27 96% 61%);
		--sl-color-orange-500: hsl(24.6 95% 53.1%);
		--sl-color-orange-600: hsl(20.5 90.2% 48.2%);
		--sl-color-orange-700: hsl(17.5 88.3% 40.4%);
		--sl-color-orange-800: hsl(15 79.1% 33.7%);
		--sl-color-orange-900: hsl(15.3 74.6% 27.8%);
		--sl-color-orange-950: hsl(15.2 69.1% 19%);

		/* Amber */
		--sl-color-amber-50: hsl(48 100% 96.1%);
		--sl-color-amber-100: hsl(48 96.5% 88.8%);
		--sl-color-amber-200: hsl(48 96.6% 76.7%);
		--sl-color-amber-300: hsl(45.9 96.7% 64.5%);
		--sl-color-amber-400: hsl(43.3 96.4% 56.3%);
		--sl-color-amber-500: hsl(37.7 92.1% 50.2%);
		--sl-color-amber-600: hsl(32.1 94.6% 43.7%);
		--sl-color-amber-700: hsl(26 90.5% 37.1%);
		--sl-color-amber-800: hsl(22.7 82.5% 31.4%);
		--sl-color-amber-900: hsl(21.7 77.8% 26.5%);
		--sl-color-amber-950: hsl(22.9 74.1% 16.7%);

		/* Yellow */
		--sl-color-yellow-50: hsl(54.5 91.7% 95.3%);
		--sl-color-yellow-100: hsl(54.9 96.7% 88%);
		--sl-color-yellow-200: hsl(52.8 98.3% 76.9%);
		--sl-color-yellow-300: hsl(50.4 97.8% 63.5%);
		--sl-color-yellow-400: hsl(47.9 95.8% 53.1%);
		--sl-color-yellow-500: hsl(45.4 93.4% 47.5%);
		--sl-color-yellow-600: hsl(40.6 96.1% 40.4%);
		--sl-color-yellow-700: hsl(35.5 91.7% 32.9%);
		--sl-color-yellow-800: hsl(31.8 81% 28.8%);
		--sl-color-yellow-900: hsl(28.4 72.5% 25.7%);
		--sl-color-yellow-950: hsl(33.1 69% 13.9%);

		/* Lime */
		--sl-color-lime-50: hsl(78.3 92% 95.1%);
		--sl-color-lime-100: hsl(79.6 89.1% 89.2%);
		--sl-color-lime-200: hsl(80.9 88.5% 79.6%);
		--sl-color-lime-300: hsl(82 84.5% 67.1%);
		--sl-color-lime-400: hsl(82.7 78% 55.5%);
		--sl-color-lime-500: hsl(83.7 80.5% 44.3%);
		--sl-color-lime-600: hsl(84.8 85.2% 34.5%);
		--sl-color-lime-700: hsl(85.9 78.4% 27.3%);
		--sl-color-lime-800: hsl(86.3 69% 22.7%);
		--sl-color-lime-900: hsl(87.6 61.2% 20.2%);
		--sl-color-lime-950: hsl(86.5 60.6% 13.9%);

		/* Green */
		--sl-color-green-50: hsl(138.5 76.5% 96.7%);
		--sl-color-green-100: hsl(140.6 84.2% 92.5%);
		--sl-color-green-200: hsl(141 78.9% 85.1%);
		--sl-color-green-300: hsl(141.7 76.6% 73.1%);
		--sl-color-green-400: hsl(141.9 69.2% 58%);
		--sl-color-green-500: hsl(142.1 70.6% 45.3%);
		--sl-color-green-600: hsl(142.1 76.2% 36.3%);
		--sl-color-green-700: hsl(142.4 71.8% 29.2%);
		--sl-color-green-800: hsl(142.8 64.2% 24.1%);
		--sl-color-green-900: hsl(143.8 61.2% 20.2%);
		--sl-color-green-950: hsl(144.3 60.7% 12%);

		/* Emerald */
		--sl-color-emerald-50: hsl(151.8 81% 95.9%);
		--sl-color-emerald-100: hsl(149.3 80.4% 90%);
		--sl-color-emerald-200: hsl(152.4 76% 80.4%);
		--sl-color-emerald-300: hsl(156.2 71.6% 66.9%);
		--sl-color-emerald-400: hsl(158.1 64.4% 51.6%);
		--sl-color-emerald-500: hsl(160.1 84.1% 39.4%);
		--sl-color-emerald-600: hsl(161.4 93.5% 30.4%);
		--sl-color-emerald-700: hsl(162.9 93.5% 24.3%);
		--sl-color-emerald-800: hsl(163.1 88.1% 19.8%);
		--sl-color-emerald-900: hsl(164.2 85.7% 16.5%);
		--sl-color-emerald-950: hsl(164.3 87.5% 9.4%);

		/* Teal */
		--sl-color-teal-50: hsl(166.2 76.5% 96.7%);
		--sl-color-teal-100: hsl(167.2 85.5% 89.2%);
		--sl-color-teal-200: hsl(168.4 83.8% 78.2%);
		--sl-color-teal-300: hsl(170.6 76.9% 64.3%);
		--sl-color-teal-400: hsl(172.5 66% 50.4%);
		--sl-color-teal-500: hsl(173.4 80.4% 40%);
		--sl-color-teal-600: hsl(174.7 83.9% 31.6%);
		--sl-color-teal-700: hsl(175.3 77.4% 26.1%);
		--sl-color-teal-800: hsl(176.1 69.4% 21.8%);
		--sl-color-teal-900: hsl(175.9 60.8% 19%);
		--sl-color-teal-950: hsl(176.5 58.6% 11.4%);

		/* Cyan */
		--sl-color-cyan-50: hsl(183.2 100% 96.3%);
		--sl-color-cyan-100: hsl(185.1 95.9% 90.4%);
		--sl-color-cyan-200: hsl(186.2 93.5% 81.8%);
		--sl-color-cyan-300: hsl(187 92.4% 69%);
		--sl-color-cyan-400: hsl(187.9 85.7% 53.3%);
		--sl-color-cyan-500: hsl(188.7 94.5% 42.7%);
		--sl-color-cyan-600: hsl(191.6 91.4% 36.5%);
		--sl-color-cyan-700: hsl(192.9 82.3% 31%);
		--sl-color-cyan-800: hsl(194.4 69.6% 27.1%);
		--sl-color-cyan-900: hsl(196.4 63.6% 23.7%);
		--sl-color-cyan-950: hsl(196.8 61% 16.1%);

		/* Sky */
		--sl-color-sky-50: hsl(204 100% 97.1%);
		--sl-color-sky-100: hsl(204 93.8% 93.7%);
		--sl-color-sky-200: hsl(200.6 94.4% 86.1%);
		--sl-color-sky-300: hsl(199.4 95.5% 73.9%);
		--sl-color-sky-400: hsl(198.4 93.2% 59.6%);
		--sl-color-sky-500: hsl(198.6 88.7% 48.4%);
		--sl-color-sky-600: hsl(200.4 98% 39.4%);
		--sl-color-sky-700: hsl(201.3 96.3% 32.2%);
		--sl-color-sky-800: hsl(201 90% 27.5%);
		--sl-color-sky-900: hsl(202 80.3% 23.9%);
		--sl-color-sky-950: hsl(202.3 73.8% 16.5%);

		/* Blue */
		--sl-color-blue-50: hsl(213.8 100% 96.9%);
		--sl-color-blue-100: hsl(214.3 94.6% 92.7%);
		--sl-color-blue-200: hsl(213.3 96.9% 87.3%);
		--sl-color-blue-300: hsl(211.7 96.4% 78.4%);
		--sl-color-blue-400: hsl(213.1 93.9% 67.8%);
		--sl-color-blue-500: hsl(217.2 91.2% 59.8%);
		--sl-color-blue-600: hsl(221.2 83.2% 53.3%);
		--sl-color-blue-700: hsl(224.3 76.3% 48%);
		--sl-color-blue-800: hsl(225.9 70.7% 40.2%);
		--sl-color-blue-900: hsl(224.4 64.3% 32.9%);
		--sl-color-blue-950: hsl(226.2 55.3% 18.4%);

		/* Indigo */
		--sl-color-indigo-50: hsl(225.9 100% 96.7%);
		--sl-color-indigo-100: hsl(226.5 100% 93.9%);
		--sl-color-indigo-200: hsl(228 96.5% 88.8%);
		--sl-color-indigo-300: hsl(229.7 93.5% 81.8%);
		--sl-color-indigo-400: hsl(234.5 89.5% 73.9%);
		--sl-color-indigo-500: hsl(238.7 83.5% 66.7%);
		--sl-color-indigo-600: hsl(243.4 75.4% 58.6%);
		--sl-color-indigo-700: hsl(244.5 57.9% 50.6%);
		--sl-color-indigo-800: hsl(243.7 54.5% 41.4%);
		--sl-color-indigo-900: hsl(242.2 47.4% 34.3%);
		--sl-color-indigo-950: hsl(243.5 43.6% 22.9%);

		/* Violet */
		--sl-color-violet-50: hsl(250 100% 97.6%);
		--sl-color-violet-100: hsl(251.4 91.3% 95.5%);
		--sl-color-violet-200: hsl(250.5 95.2% 91.8%);
		--sl-color-violet-300: hsl(252.5 94.7% 85.1%);
		--sl-color-violet-400: hsl(255.1 91.7% 76.3%);
		--sl-color-violet-500: hsl(258.3 89.5% 66.3%);
		--sl-color-violet-600: hsl(262.1 83.3% 57.8%);
		--sl-color-violet-700: hsl(263.4 70% 50.4%);
		--sl-color-violet-800: hsl(263.4 69.3% 42.2%);
		--sl-color-violet-900: hsl(263.5 67.4% 34.9%);
		--sl-color-violet-950: hsl(265.1 61.5% 21.4%);

		/* Purple */
		--sl-color-purple-50: hsl(270 100% 98%);
		--sl-color-purple-100: hsl(268.7 100% 95.5%);
		--sl-color-purple-200: hsl(268.6 100% 91.8%);
		--sl-color-purple-300: hsl(269.2 97.4% 85.1%);
		--sl-color-purple-400: hsl(270 95.2% 75.3%);
		--sl-color-purple-500: hsl(270.7 91% 65.1%);
		--sl-color-purple-600: hsl(271.5 81.3% 55.9%);
		--sl-color-purple-700: hsl(272.1 71.7% 47.1%);
		--sl-color-purple-800: hsl(272.9 67.2% 39.4%);
		--sl-color-purple-900: hsl(273.6 65.6% 32%);
		--sl-color-purple-950: hsl(276 59.5% 16.5%);

		/* Fuchsia */
		--sl-color-fuchsia-50: hsl(289.1 100% 97.8%);
		--sl-color-fuchsia-100: hsl(287 100% 95.5%);
		--sl-color-fuchsia-200: hsl(288.3 95.8% 90.6%);
		--sl-color-fuchsia-300: hsl(291.1 93.1% 82.9%);
		--sl-color-fuchsia-400: hsl(292 91.4% 72.5%);
		--sl-color-fuchsia-500: hsl(292.2 84.1% 60.6%);
		--sl-color-fuchsia-600: hsl(293.4 69.5% 48.8%);
		--sl-color-fuchsia-700: hsl(294.7 72.4% 39.8%);
		--sl-color-fuchsia-800: hsl(295.4 70.2% 32.9%);
		--sl-color-fuchsia-900: hsl(296.7 63.6% 28%);
		--sl-color-fuchsia-950: hsl(297.1 56.8% 14.5%);

		/* Pink */
		--sl-color-pink-50: hsl(327.3 73.3% 97.1%);
		--sl-color-pink-100: hsl(325.7 77.8% 94.7%);
		--sl-color-pink-200: hsl(325.9 84.6% 89.8%);
		--sl-color-pink-300: hsl(327.4 87.1% 81.8%);
		--sl-color-pink-400: hsl(328.6 85.5% 70.2%);
		--sl-color-pink-500: hsl(330.4 81.2% 60.4%);
		--sl-color-pink-600: hsl(333.3 71.4% 50.6%);
		--sl-color-pink-700: hsl(335.1 77.6% 42%);
		--sl-color-pink-800: hsl(335.8 74.4% 35.3%);
		--sl-color-pink-900: hsl(335.9 69% 30.4%);
		--sl-color-pink-950: hsl(336.2 65.4% 15.9%);

		/* Rose */
		--sl-color-rose-50: hsl(355.7 100% 97.3%);
		--sl-color-rose-100: hsl(355.6 100% 94.7%);
		--sl-color-rose-200: hsl(352.7 96.1% 90%);
		--sl-color-rose-300: hsl(352.6 95.7% 81.8%);
		--sl-color-rose-400: hsl(351.3 94.5% 71.4%);
		--sl-color-rose-500: hsl(349.7 89.2% 60.2%);
		--sl-color-rose-600: hsl(346.8 77.2% 49.8%);
		--sl-color-rose-700: hsl(345.3 82.7% 40.8%);
		--sl-color-rose-800: hsl(343.4 79.7% 34.7%);
		--sl-color-rose-900: hsl(341.5 75.5% 30.4%);
		--sl-color-rose-950: hsl(341.3 70.1% 17.1%);

		/*
   * Theme Tokens
   */

		/* Primary */
		--sl-color-primary-50: var(--sl-color-sky-50);
		--sl-color-primary-100: var(--sl-color-sky-100);
		--sl-color-primary-200: var(--sl-color-sky-200);
		--sl-color-primary-300: var(--sl-color-sky-300);
		--sl-color-primary-400: var(--sl-color-sky-400);
		--sl-color-primary-500: var(--sl-color-sky-500);
		--sl-color-primary-600: var(--sl-color-sky-600);
		--sl-color-primary-700: var(--sl-color-sky-700);
		--sl-color-primary-800: var(--sl-color-sky-800);
		--sl-color-primary-900: var(--sl-color-sky-900);
		--sl-color-primary-950: var(--sl-color-sky-950);

		/* Success */
		--sl-color-success-50: var(--sl-color-green-50);
		--sl-color-success-100: var(--sl-color-green-100);
		--sl-color-success-200: var(--sl-color-green-200);
		--sl-color-success-300: var(--sl-color-green-300);
		--sl-color-success-400: var(--sl-color-green-400);
		--sl-color-success-500: var(--sl-color-green-500);
		--sl-color-success-600: var(--sl-color-green-600);
		--sl-color-success-700: var(--sl-color-green-700);
		--sl-color-success-800: var(--sl-color-green-800);
		--sl-color-success-900: var(--sl-color-green-900);
		--sl-color-success-950: var(--sl-color-green-950);

		/* Warning */
		--sl-color-warning-50: var(--sl-color-amber-50);
		--sl-color-warning-100: var(--sl-color-amber-100);
		--sl-color-warning-200: var(--sl-color-amber-200);
		--sl-color-warning-300: var(--sl-color-amber-300);
		--sl-color-warning-400: var(--sl-color-amber-400);
		--sl-color-warning-500: var(--sl-color-amber-500);
		--sl-color-warning-600: var(--sl-color-amber-600);
		--sl-color-warning-700: var(--sl-color-amber-700);
		--sl-color-warning-800: var(--sl-color-amber-800);
		--sl-color-warning-900: var(--sl-color-amber-900);
		--sl-color-warning-950: var(--sl-color-amber-950);

		/* Danger */
		--sl-color-danger-50: var(--sl-color-red-50);
		--sl-color-danger-100: var(--sl-color-red-100);
		--sl-color-danger-200: var(--sl-color-red-200);
		--sl-color-danger-300: var(--sl-color-red-300);
		--sl-color-danger-400: var(--sl-color-red-400);
		--sl-color-danger-500: var(--sl-color-red-500);
		--sl-color-danger-600: var(--sl-color-red-600);
		--sl-color-danger-700: var(--sl-color-red-700);
		--sl-color-danger-800: var(--sl-color-red-800);
		--sl-color-danger-900: var(--sl-color-red-900);
		--sl-color-danger-950: var(--sl-color-red-950);

		/* Neutral */
		--sl-color-neutral-50: var(--sl-color-gray-50);
		--sl-color-neutral-100: var(--sl-color-gray-100);
		--sl-color-neutral-200: var(--sl-color-gray-200);
		--sl-color-neutral-300: var(--sl-color-gray-300);
		--sl-color-neutral-400: var(--sl-color-gray-400);
		--sl-color-neutral-500: var(--sl-color-gray-500);
		--sl-color-neutral-600: var(--sl-color-gray-600);
		--sl-color-neutral-700: var(--sl-color-gray-700);
		--sl-color-neutral-800: var(--sl-color-gray-800);
		--sl-color-neutral-900: var(--sl-color-gray-900);
		--sl-color-neutral-950: var(--sl-color-gray-950);

		/* Neutral one-offs */
		--sl-color-neutral-0: hsl(0, 0%, 100%);
		--sl-color-neutral-1000: hsl(0, 0%, 0%);

		/*
   * Border radii
   */

		--sl-border-radius-small: 0.1875rem; /* 3px */
		--sl-border-radius-medium: 0.25rem; /* 4px */
		--sl-border-radius-large: 0.5rem; /* 8px */
		--sl-border-radius-x-large: 1rem; /* 16px */

		--sl-border-radius-circle: 50%;
		--sl-border-radius-pill: 9999px;

		/*
   * Elevations
   */

		--sl-shadow-x-small: 0 1px 2px hsl(240 3.8% 46.1% / 6%);
		--sl-shadow-small: 0 1px 2px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-medium: 0 2px 4px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-large: 0 2px 8px hsl(240 3.8% 46.1% / 12%);
		--sl-shadow-x-large: 0 4px 16px hsl(240 3.8% 46.1% / 12%);

		/*
   * Spacings
   */

		--sl-spacing-3x-small: 0.125rem; /* 2px */
		--sl-spacing-2x-small: 0.25rem; /* 4px */
		--sl-spacing-x-small: 0.5rem; /* 8px */
		--sl-spacing-small: 0.75rem; /* 12px */
		--sl-spacing-medium: 1rem; /* 16px */
		--sl-spacing-large: 1.25rem; /* 20px */
		--sl-spacing-x-large: 1.75rem; /* 28px */
		--sl-spacing-2x-large: 2.25rem; /* 36px */
		--sl-spacing-3x-large: 3rem; /* 48px */
		--sl-spacing-4x-large: 4.5rem; /* 72px */

		/*
   * Transitions
   */

		--sl-transition-x-slow: 1000ms;
		--sl-transition-slow: 500ms;
		--sl-transition-medium: 250ms;
		--sl-transition-fast: 150ms;
		--sl-transition-x-fast: 50ms;

		/*
   * Typography
   */

		/* Fonts */
		--sl-font-mono: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
		--sl-font-sans: Inter, sans-serif;
		--sl-font-serif: Inter, "Times New Roman", serif;

		/* Font sizes */
		--sl-font-size-2x-small: 0.625rem; /* 10px */
		--sl-font-size-x-small: 0.75rem; /* 12px */
		--sl-font-size-small: 0.875rem; /* 14px */
		--sl-font-size-medium: 1rem; /* 16px */
		--sl-font-size-large: 1.25rem; /* 20px */
		--sl-font-size-x-large: 1.5rem; /* 24px */
		--sl-font-size-2x-large: 2.25rem; /* 36px */
		--sl-font-size-3x-large: 3rem; /* 48px */
		--sl-font-size-4x-large: 4.5rem; /* 72px */

		/* Font weights */
		--sl-font-weight-light: 300;
		--sl-font-weight-normal: 400;
		--sl-font-weight-semibold: 500;
		--sl-font-weight-bold: 700;

		/* Letter spacings */
		--sl-letter-spacing-denser: -0.03em;
		--sl-letter-spacing-dense: -0.015em;
		--sl-letter-spacing-normal: normal;
		--sl-letter-spacing-loose: 0.075em;
		--sl-letter-spacing-looser: 0.15em;

		/* Line heights */
		--sl-line-height-denser: 1;
		--sl-line-height-dense: 1.4;
		--sl-line-height-normal: 1.8;
		--sl-line-height-loose: 2.2;
		--sl-line-height-looser: 2.6;

		/* Focus rings */
		--sl-focus-ring-color: var(--sl-color-primary-600);
		--sl-focus-ring-style: solid;
		--sl-focus-ring-width: 3px;
		--sl-focus-ring: var(--sl-focus-ring-style) var(--sl-focus-ring-width)
			var(--sl-focus-ring-color);
		--sl-focus-ring-offset: 1px;

		/*
   * Forms
   */

		/* Buttons */
		--sl-button-font-size-small: var(--sl-font-size-x-small);
		--sl-button-font-size-medium: var(--sl-font-size-small);
		--sl-button-font-size-large: var(--sl-font-size-medium);

		/* Inputs */
		--sl-input-height-small: 1.875rem; /* 30px */
		--sl-input-height-medium: 2.5rem; /* 40px */
		--sl-input-height-large: 3.125rem; /* 50px */

		--sl-input-background-color: var(--sl-color-neutral-0);
		--sl-input-background-color-hover: var(--sl-input-background-color);
		--sl-input-background-color-focus: var(--sl-input-background-color);
		--sl-input-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-border-color: var(--sl-color-neutral-300);
		--sl-input-border-color-hover: var(--sl-color-neutral-400);
		--sl-input-border-color-focus: var(--sl-color-primary-500);
		--sl-input-border-color-disabled: var(--sl-color-neutral-300);
		--sl-input-border-width: 1px;
		--sl-input-required-content: "*";
		--sl-input-required-content-offset: -2px;
		--sl-input-required-content-color: var(--sl-input-label-color);

		--sl-input-border-radius-small: var(--sl-border-radius-medium);
		--sl-input-border-radius-medium: var(--sl-border-radius-medium);
		--sl-input-border-radius-large: var(--sl-border-radius-medium);

		--sl-input-font-family: var(--sl-font-sans);
		--sl-input-font-weight: var(--sl-font-weight-normal);
		--sl-input-font-size-small: var(--sl-font-size-small);
		--sl-input-font-size-medium: var(--sl-font-size-medium);
		--sl-input-font-size-large: var(--sl-font-size-large);
		--sl-input-letter-spacing: var(--sl-letter-spacing-normal);

		--sl-input-color: var(--sl-color-neutral-700);
		--sl-input-color-hover: var(--sl-color-neutral-700);
		--sl-input-color-focus: var(--sl-color-neutral-700);
		--sl-input-color-disabled: var(--sl-color-neutral-900);
		--sl-input-icon-color: var(--sl-color-neutral-500);
		--sl-input-icon-color-hover: var(--sl-color-neutral-600);
		--sl-input-icon-color-focus: var(--sl-color-neutral-600);
		--sl-input-placeholder-color: var(--sl-color-neutral-500);
		--sl-input-placeholder-color-disabled: var(--sl-color-neutral-600);
		--sl-input-spacing-small: var(--sl-spacing-small);
		--sl-input-spacing-medium: var(--sl-spacing-medium);
		--sl-input-spacing-large: var(--sl-spacing-large);

		--sl-input-focus-ring-color: hsl(198.6 88.7% 48.4% / 40%);
		--sl-input-focus-ring-offset: 0;

		--sl-input-filled-background-color: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-hover: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-focus: var(--sl-color-neutral-100);
		--sl-input-filled-background-color-disabled: var(--sl-color-neutral-100);
		--sl-input-filled-color: var(--sl-color-neutral-800);
		--sl-input-filled-color-hover: var(--sl-color-neutral-800);
		--sl-input-filled-color-focus: var(--sl-color-neutral-700);
		--sl-input-filled-color-disabled: var(--sl-color-neutral-800);

		/* Labels */
		--sl-input-label-font-size-small: var(--sl-font-size-small);
		--sl-input-label-font-size-medium: var(--sl-font-size-medium);
		--sl-input-label-font-size-large: var(--sl-font-size-large);
		--sl-input-label-color: inherit;

		/* Help text */
		--sl-input-help-text-font-size-small: var(--sl-font-size-x-small);
		--sl-input-help-text-font-size-medium: var(--sl-font-size-small);
		--sl-input-help-text-font-size-large: var(--sl-font-size-medium);
		--sl-input-help-text-color: var(--sl-color-neutral-500);

		/* Toggles (checkboxes, radios, switches) */
		--sl-toggle-size-small: 0.875rem; /* 14px */
		--sl-toggle-size-medium: 1.125rem; /* 18px */
		--sl-toggle-size-large: 1.375rem; /* 22px */

		/*
   * Overlays
   */

		--sl-overlay-background-color: hsl(240 3.8% 46.1% / 33%);

		/*
   * Panels
   */

		--sl-panel-background-color: var(--sl-color-neutral-0);
		--sl-panel-border-color: var(--sl-color-neutral-200);
		--sl-panel-border-width: 1px;

		/*
   * Tooltips
   */

		--sl-tooltip-border-radius: var(--sl-border-radius-medium);
		--sl-tooltip-background-color: var(--sl-color-neutral-800);
		--sl-tooltip-color: var(--sl-color-neutral-0);
		--sl-tooltip-font-family: var(--sl-font-sans);
		--sl-tooltip-font-weight: var(--sl-font-weight-normal);
		--sl-tooltip-font-size: var(--sl-font-size-small);
		--sl-tooltip-line-height: var(--sl-line-height-dense);
		--sl-tooltip-padding: var(--sl-spacing-2x-small) var(--sl-spacing-x-small);
		--sl-tooltip-arrow-size: 6px;

		/*
   * Z-indexes
   */

		--sl-z-index-drawer: 700;
		--sl-z-index-dialog: 800;
		--sl-z-index-dropdown: 900;
		--sl-z-index-toast: 950;
		--sl-z-index-tooltip: 1000;
	}
`;

// ../versioned-interfaces/translatable/dist/interface.js
var import_typebox = __toESM(require_typebox(), 1);
var Translatable = (type) => import_typebox.Type.Union([type, import_typebox.Type.Intersect([import_typebox.Type.Object({ en: type }), import_typebox.Type.Record(import_typebox.Type.String(), type)])]);

// ../versioned-interfaces/message-lint-rule/dist/interface.js
var import_typebox5 = __toESM(require_typebox(), 1);

// ../versioned-interfaces/project-settings/dist/interface.js
var import_typebox4 = __toESM(require_typebox(), 1);

// ../versioned-interfaces/language-tag/dist/interface.js
var import_typebox2 = __toESM(require_typebox(), 1);
var pattern = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
var LanguageTag = import_typebox2.Type.String({
  pattern,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"]
});

// ../json-types/dist/interface.js
var import_typebox3 = __toESM(require_typebox(), 1);
var JSONValue1 = import_typebox3.Type.Union([import_typebox3.Type.String(), import_typebox3.Type.Number(), import_typebox3.Type.Boolean(), import_typebox3.Type.Null()]);
var JSONArray1 = import_typebox3.Type.Array(JSONValue1);
var JSONObject1 = import_typebox3.Type.Record(import_typebox3.Type.String(), import_typebox3.Type.Union([JSONArray1, JSONValue1]));
var JSONValue2 = import_typebox3.Type.Union([JSONValue1, JSONObject1]);
var JSONArray2 = import_typebox3.Type.Array(JSONValue2);
var JSONObject2 = import_typebox3.Type.Record(import_typebox3.Type.String(), import_typebox3.Type.Union([JSONValue2, JSONArray2]));
var JSONValue3 = import_typebox3.Type.Union([JSONValue2, JSONObject2]);
var JSONArray3 = import_typebox3.Type.Array(JSONValue3);
var JSONObject3 = import_typebox3.Type.Record(import_typebox3.Type.String(), import_typebox3.Type.Union([JSONValue3, JSONArray3]));
var JSONValue4 = import_typebox3.Type.Union([JSONValue3, JSONObject3]);
var JSONArray4 = import_typebox3.Type.Array(JSONValue4);
var JSONObject4 = import_typebox3.Type.Record(import_typebox3.Type.String(), import_typebox3.Type.Union([JSONValue4, JSONArray4]));
var JSON2 = import_typebox3.Type.Union([JSONObject4, JSONValue4, JSONArray4]);

// ../versioned-interfaces/project-settings/dist/interface.js
var _MessageLintRuleId = import_typebox4.Type.String({
  pattern: "^messageLintRule\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
  description: "The key must be conform to `messageLintRule.{namespace}.{id}` pattern.",
  examples: [
    "messageLintRule.namespace.patternInvalid",
    "messageLintRule.namespace.missingTranslation"
  ]
});
var _MessageLintRuleLevel = import_typebox4.Type.Union([import_typebox4.Type.Literal("error"), import_typebox4.Type.Literal("warning")]);
var SourceLanguageTag = LanguageTag;
SourceLanguageTag.title = "Source language tag";
SourceLanguageTag.description = "Set the reference language for your project. It needs to be a valid BCP-47 language tag.";
var InternalProjectSettings = import_typebox4.Type.Object({
  $schema: import_typebox4.Type.Optional(import_typebox4.Type.Literal("https://inlang.com/schema/project-settings")),
  sourceLanguageTag: SourceLanguageTag,
  languageTags: import_typebox4.Type.Array(LanguageTag, {
    uniqueItems: true,
    title: "Language tags",
    description: "Set the languages that are available in your project. All language tags needs to be a valid BCP-47 language tag. Needs to include the source language tag."
  }),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: import_typebox4.Type.Array(import_typebox4.Type.Intersect([
    import_typebox4.Type.String({
      pattern: "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?",
      description: "The module must be a valid URI according to RFC 3986."
    }),
    import_typebox4.Type.String({
      pattern: ".*\\.js$",
      description: "The module must end with `.js`."
    }),
    import_typebox4.Type.String({
      pattern: "^(?!.*@\\d\\.)[^]*$",
      description: "The module can only contain a major version number."
    })
  ]), {
    uniqueItems: true,
    description: "The modules to load. Must be a valid URI but can be relative.",
    examples: [
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
      "./local-testing-plugin.js"
    ]
  }),
  messageLintRuleLevels: import_typebox4.Type.Optional(import_typebox4.Type.Record(_MessageLintRuleId, _MessageLintRuleLevel, {
    title: "Levels for lint rules",
    description: "Adjust the lint rule levels in your project to choose between 'warning' and 'error'. If set to 'error', you can configure a CI process to prevent merging with existing reports. (When you want to configure your lint rules visit inlang.com/c/lint-rules)",
    examples: [
      {
        "messageLintRule.inlang.missingTranslation": "error",
        "messageLintRule.inlang.patternInvalid": "warning"
      }
    ]
  })),
  experimental: import_typebox4.Type.Optional(import_typebox4.Type.Record(import_typebox4.Type.String(), import_typebox4.Type.Literal(true), {
    title: "Experimental settings",
    description: "Experimental settings that are used for product development."
  }))
});
var ExternalProjectSettings = import_typebox4.Type.Record(
  import_typebox4.Type.String({
    // pattern includes ProjectSettings keys
    pattern: `^((messageLintRule|plugin|app|library)\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${Object.keys(InternalProjectSettings.properties).map((key) => key.replaceAll(".", "\\.")).join("|")})$`,
    description: "The key must be conform to `{type:app|plugin|messageLintRule}.{namespace:string}.{id:string}`.",
    examples: ["plugin.publisher.sqlite", "messageLintRule.inlang.missingTranslation"]
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  JSON2,
  { description: "Settings defined by apps, plugins, etc." }
);
var ProjectSettings = import_typebox4.Type.Intersect([InternalProjectSettings, ExternalProjectSettings]);

// ../versioned-interfaces/message-lint-rule/dist/interface.js
var MessageLintRule = import_typebox5.Type.Object({
  id: _MessageLintRuleId,
  displayName: Translatable(import_typebox5.Type.String()),
  description: Translatable(import_typebox5.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: import_typebox5.Type.Optional(import_typebox5.Type.Object({}, { additionalProperties: true }))
});

// ../versioned-interfaces/plugin/dist/customApis/app.inlang.ideExtension.js
var import_typebox6 = __toESM(require_typebox(), 1);
var MessageReferenceMatch = import_typebox6.Type.Object({
  /**
   * The messages id.
   */
  messageId: import_typebox6.Type.String(),
  /**
   * The position from where to where the reference can be found.
   */
  position: import_typebox6.Type.Object({
    start: import_typebox6.Type.Object({
      line: import_typebox6.Type.Number(),
      character: import_typebox6.Type.Number()
    }),
    end: import_typebox6.Type.Object({
      line: import_typebox6.Type.Number(),
      character: import_typebox6.Type.Number()
    })
  })
});
var IdeExtensionConfigSchema = import_typebox6.Type.Object({
  /**
   * Defines matchers for message references inside the code.
   *
   * @param args represents the data to conduct the search on
   * @returns a promise with matched message references
   */
  messageReferenceMatchers: import_typebox6.Type.Array(import_typebox6.Type.Function([
    import_typebox6.Type.Object({
      documentText: import_typebox6.Type.String()
    })
  ], import_typebox6.Type.Promise(import_typebox6.Type.Array(MessageReferenceMatch)))),
  /**
   * Defines the options to extract messages.
   */
  extractMessageOptions: import_typebox6.Type.Array(import_typebox6.Type.Object({
    /**
     * Function which is called, when the user finished the message extraction command.
     *
     * @param messageId is the message identifier entered by the user
     * @param selection is the text which was extracted
     * @returns the code which is inserted into the document
     */
    callback: import_typebox6.Type.Function([
      import_typebox6.Type.Object({
        messageId: import_typebox6.Type.String(),
        selection: import_typebox6.Type.String()
      })
    ], import_typebox6.Type.Object({
      messageId: import_typebox6.Type.String(),
      messageReplacement: import_typebox6.Type.String()
    }))
  })),
  /**
   * An array of Visual Studio Code DocumentSelectors.
   *
   * The document selectors specify for which files/programming languages
   * (typescript, svelte, etc.) the extension should be activated.
   *
   * See https://code.visualstudio.com/api/references/document-selector
   */
  documentSelectors: import_typebox6.Type.Optional(import_typebox6.Type.Array(import_typebox6.Type.Object({
    language: import_typebox6.Type.Optional(import_typebox6.Type.String())
  })))
});

// ../versioned-interfaces/plugin/dist/interface.js
var import_typebox7 = __toESM(require_typebox(), 1);
var Plugin = import_typebox7.Type.Object({
  id: import_typebox7.Type.String({
    pattern: "^plugin\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
    examples: ["plugin.namespace.id"]
  }),
  displayName: Translatable(import_typebox7.Type.String()),
  description: Translatable(import_typebox7.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: import_typebox7.Type.Optional(import_typebox7.Type.Object({}, { additionalProperties: true })),
  loadMessages: import_typebox7.Type.Optional(import_typebox7.Type.Any()),
  saveMessages: import_typebox7.Type.Optional(import_typebox7.Type.Any()),
  /**
   * @deprecated removed
   */
  detectedLanguageTags: import_typebox7.Type.Optional(import_typebox7.Type.Any()),
  addCustomApi: import_typebox7.Type.Optional(import_typebox7.Type.Any())
});

// ../versioned-interfaces/message/dist/interface.js
var import_typebox8 = __toESM(require_typebox(), 1);
var Text = import_typebox8.Type.Object({
  type: import_typebox8.Type.Literal("Text"),
  value: import_typebox8.Type.String()
});
var VariableReference = import_typebox8.Type.Object({
  type: import_typebox8.Type.Literal("VariableReference"),
  name: import_typebox8.Type.String()
});
var Expression = import_typebox8.Type.Union([VariableReference]);
var Pattern = import_typebox8.Type.Array(import_typebox8.Type.Union([Text, Expression]));
var Variant = import_typebox8.Type.Object({
  languageTag: LanguageTag,
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: import_typebox8.Type.Array(import_typebox8.Type.String()),
  pattern: Pattern
});
var Message = import_typebox8.Type.Object({
  id: import_typebox8.Type.String(),
  alias: import_typebox8.Type.Record(import_typebox8.Type.String(), import_typebox8.Type.String()),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: import_typebox8.Type.Array(Expression),
  variants: import_typebox8.Type.Array(Variant)
});

// ../versioned-interfaces/module/dist/interface.js
var import_typebox9 = __toESM(require_typebox(), 1);
var InlangModule = import_typebox9.Type.Object({
  default: import_typebox9.Type.Union([Plugin, MessageLintRule])
});

// ../sdk/dist/resolve-modules/message-lint-rules/resolveMessageLintRules.js
var import_value = __toESM(require_value2(), 1);

// ../../../node_modules/.pnpm/dedent@1.5.1/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i4 = 1; i4 < arguments.length; i4++) {
    var source = null != arguments[i4] ? arguments[i4] : {};
    i4 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var dedent_default = createDedent({});
function createDedent(options) {
  dedent.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === "string" ? [strings] : strings.raw;
    const {
      escapeSpecialCharacters = Array.isArray(strings)
    } = options;
    let result = "";
    for (let i4 = 0; i4 < raw.length; i4++) {
      let next = raw[i4];
      if (escapeSpecialCharacters) {
        next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\{/g, "{");
      }
      result += next;
      if (i4 < values.length) {
        result += values[i4];
      }
    }
    const lines = result.split("\n");
    let mindent = null;
    for (const l2 of lines) {
      const m2 = l2.match(/^(\s+)\S+/);
      if (m2) {
        const indent2 = m2[1].length;
        if (!mindent) {
          mindent = indent2;
        } else {
          mindent = Math.min(mindent, indent2);
        }
      }
    }
    if (mindent !== null) {
      const m2 = mindent;
      result = lines.map((l2) => l2[0] === " " || l2[0] === "	" ? l2.slice(m2) : l2).join("\n");
    }
    return result.trim().replace(/\\n/g, "\n");
  }
}

// ../sdk/dist/resolve-modules/plugins/resolvePlugins.js
var import_compiler = __toESM(require_compiler2(), 1);
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("sdk:resolvePlugins");
var PluginCompiler = import_compiler.TypeCompiler.Compile(Plugin);

// ../sdk/dist/resolve-modules/resolveModules.js
var import_compiler2 = __toESM(require_compiler2(), 1);

// ../sdk/dist/resolve-modules/validatedModuleSettings.js
var import_value2 = __toESM(require_value2(), 1);

// ../sdk/dist/resolve-modules/resolveModules.js
var ModuleCompiler = import_compiler2.TypeCompiler.Compile(InlangModule);

// ../sdk/dist/loadProject.js
var import_compiler3 = __toESM(require_compiler2(), 1);

// ../sdk/dist/reactivity/map.js
var $KEYS = Symbol("track-keys");

// ../sdk/dist/persistence/filelock/acquireFileLock.js
init_dist();
var import_debug2 = __toESM(require_browser(), 1);
var debug2 = (0, import_debug2.default)("sdk:fileLock");

// ../sdk/dist/createMessagesQuery.js
var import_debug4 = __toESM(require_browser(), 1);

// ../sdk/dist/persistence/filelock/releaseLock.js
init_dist();
var import_debug3 = __toESM(require_browser(), 1);
var debug3 = (0, import_debug3.default)("sdk:fileLock");

// ../sdk/dist/storage/human-id/human-readable-id.js
var import_murmurhash3js = __toESM(require_murmurhash3js(), 1);

// ../sdk/dist/createMessagesQuery.js
var debug4 = (0, import_debug4.default)("sdk:messages");

// ../sdk/dist/createMessageLintReportsQuery.js
var import_debug5 = __toESM(require_browser(), 1);
var debug5 = (0, import_debug5.default)("sdk:lintReports");

// ../sdk/dist/createNodeishFsWithAbsolutePaths.js
init_dist();

// ../sdk/dist/loadProject.js
init_dist();

// ../../../lix/packages/client/dist/git/commit.js
init_dist();

// ../../../lix/packages/client/dist/git/status-list.js
init_isomorphic_git();
var {
  walk: walk2,
  // _walk expects cache to always exist.
  TREE: TREE2,
  WORKDIR: WORKDIR2,
  STAGE: STAGE2,
  isIgnored: isIgnored2
} = isomorphic_git_default;

// ../../../lix/packages/client/dist/index.js
init_dist();

// ../../../lix/packages/client/dist/mockRepo.js
init_dist();

// ../sdk/dist/v2/stubQueryApi.js
var stubMessagesQuery = {
  create: () => false,
  // @ts-expect-error
  get: subscribable(() => void 0),
  // @ts-expect-error
  getByDefaultAlias: subscribable(() => void 0),
  // @ts-expect-error
  includedMessageIds: subscribable(() => []),
  // @ts-expect-error
  getAll: subscribable(() => []),
  update: () => false,
  upsert: () => {
  },
  delete: () => false,
  setDelegate: () => {
  }
};
var stubMessageLintReportsQuery = {
  // @ts-expect-error
  get: subscribable(() => []),
  // @ts-expect-error
  getAll: settleable(subscribable(() => []))
};
function subscribable(fn) {
  return Object.assign(fn, {
    subscribe: () => {
    }
  });
}
function settleable(fn) {
  return Object.assign(fn, {
    settled: async () => []
  });
}

// ../sdk/dist/v2/types.js
var import_typebox10 = __toESM(require_typebox(), 1);
var pattern2 = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
var LanguageTag2 = import_typebox10.Type.String({
  pattern: pattern2,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"]
});
var Literal = import_typebox10.Type.Object({
  type: import_typebox10.Type.Literal("literal"),
  value: import_typebox10.Type.String()
});
var Text2 = import_typebox10.Type.Object({
  type: import_typebox10.Type.Literal("text"),
  value: import_typebox10.Type.String()
});
var VariableReference2 = import_typebox10.Type.Object({
  type: import_typebox10.Type.Literal("variable"),
  name: import_typebox10.Type.String()
});
var Option = import_typebox10.Type.Object({
  name: import_typebox10.Type.String(),
  value: import_typebox10.Type.Union([Literal, VariableReference2])
});
var FunctionAnnotation = import_typebox10.Type.Object({
  type: import_typebox10.Type.Literal("function"),
  name: import_typebox10.Type.String(),
  options: import_typebox10.Type.Array(Option)
});
var Expression2 = import_typebox10.Type.Object({
  type: import_typebox10.Type.Literal("expression"),
  arg: import_typebox10.Type.Union([Literal, VariableReference2]),
  annotation: import_typebox10.Type.Optional(FunctionAnnotation)
});
var Pattern2 = import_typebox10.Type.Array(import_typebox10.Type.Union([Text2, Expression2]));
var Variant2 = import_typebox10.Type.Object({
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: import_typebox10.Type.Array(import_typebox10.Type.String()),
  pattern: Pattern2
});
var InputDeclaration = import_typebox10.Type.Object({
  type: import_typebox10.Type.Literal("input"),
  name: import_typebox10.Type.String(),
  //TODO make this generic so that only Variable-Ref Expressions are allowed
  value: Expression2
});
var Declaration = import_typebox10.Type.Union([InputDeclaration]);
var Message2 = import_typebox10.Type.Object({
  locale: LanguageTag2,
  declarations: import_typebox10.Type.Array(Declaration),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: import_typebox10.Type.Array(Expression2),
  variants: import_typebox10.Type.Array(Variant2)
});
var MessageBundle = import_typebox10.Type.Object({
  id: import_typebox10.Type.String(),
  alias: import_typebox10.Type.Record(import_typebox10.Type.String(), import_typebox10.Type.String()),
  messages: import_typebox10.Type.Array(Message2)
});
var MessageSlot = import_typebox10.Type.Object({
  locale: LanguageTag2,
  slot: import_typebox10.Type.Literal(true)
});
var MessageBundleWithSlots = import_typebox10.Type.Object({
  id: import_typebox10.Type.String(),
  alias: import_typebox10.Type.Record(import_typebox10.Type.String(), import_typebox10.Type.String()),
  messages: import_typebox10.Type.Array(import_typebox10.Type.Union([Message2, MessageSlot]))
});

// ../sdk/dist/persistence/store.js
init_dist();

// ../sdk/dist/persistence/batchedIO.js
var import_debug6 = __toESM(require_browser(), 1);
var debug6 = (0, import_debug6.default)("sdk:batchedIO");

// ../sdk/dist/persistence/store.js
var import_debug7 = __toESM(require_browser(), 1);
var debug7 = (0, import_debug7.default)("sdk:store");

// ../sdk/dist/loadProject.js
var import_debug8 = __toESM(require_browser(), 1);
var debug8 = (0, import_debug8.default)("sdk:loadProject");
var settingsCompiler = import_compiler3.TypeCompiler.Compile(ProjectSettings);

// src/helper/checkRequired.ts
var checkRequired = (schema2, property) => {
  if (schema2 && schema2.required && schema2.required.includes(property)) {
    return true;
  }
  return false;
};
var checkRequired_default = checkRequired;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/limit.js
var limit_default = (x2, low = 0, high = 1) => {
  return min(max(low, x2), high);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/clip_rgb.js
var clip_rgb_default = (rgb2) => {
  rgb2._clipped = false;
  rgb2._unclipped = rgb2.slice(0);
  for (let i4 = 0; i4 <= 3; i4++) {
    if (i4 < 3) {
      if (rgb2[i4] < 0 || rgb2[i4] > 255)
        rgb2._clipped = true;
      rgb2[i4] = limit_default(rgb2[i4], 0, 255);
    } else if (i4 === 3) {
      rgb2[i4] = limit_default(rgb2[i4], 0, 1);
    }
  }
  return rgb2;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/type.js
var classToType = {};
for (let name of [
  "Boolean",
  "Number",
  "String",
  "Function",
  "Array",
  "Date",
  "RegExp",
  "Undefined",
  "Null"
]) {
  classToType[`[object ${name}]`] = name.toLowerCase();
}
function type_default(obj) {
  return classToType[Object.prototype.toString.call(obj)] || "object";
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/unpack.js
var unpack_default = (args, keyOrder = null) => {
  if (args.length >= 3)
    return Array.prototype.slice.call(args);
  if (type_default(args[0]) == "object" && keyOrder) {
    return keyOrder.split("").filter((k2) => args[0][k2] !== void 0).map((k2) => args[0][k2]);
  }
  return args[0];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/last.js
var last_default = (args) => {
  if (args.length < 2)
    return null;
  const l2 = args.length - 1;
  if (type_default(args[l2]) == "string")
    return args[l2].toLowerCase();
  return null;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/index.js
var { PI, min, max } = Math;
var TWOPI = PI * 2;
var PITHIRD = PI / 3;
var DEG2RAD = PI / 180;
var RAD2DEG = 180 / PI;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/input.js
var input_default = {
  format: {},
  autodetect: []
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/Color.js
var Color = class {
  constructor(...args) {
    const me = this;
    if (type_default(args[0]) === "object" && args[0].constructor && args[0].constructor === this.constructor) {
      return args[0];
    }
    let mode = last_default(args);
    let autodetect = false;
    if (!mode) {
      autodetect = true;
      if (!input_default.sorted) {
        input_default.autodetect = input_default.autodetect.sort((a2, b2) => b2.p - a2.p);
        input_default.sorted = true;
      }
      for (let chk of input_default.autodetect) {
        mode = chk.test(...args);
        if (mode)
          break;
      }
    }
    if (input_default.format[mode]) {
      const rgb2 = input_default.format[mode].apply(
        null,
        autodetect ? args : args.slice(0, -1)
      );
      me._rgb = clip_rgb_default(rgb2);
    } else {
      throw new Error("unknown format: " + args);
    }
    if (me._rgb.length === 3)
      me._rgb.push(1);
  }
  toString() {
    if (type_default(this.hex) == "function")
      return this.hex();
    return `[${this._rgb.join(",")}]`;
  }
};
var Color_default = Color;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/version.js
var version2 = "2.6.0";

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/chroma.js
var chroma = (...args) => {
  return new chroma.Color(...args);
};
chroma.Color = Color_default;
chroma.version = version2;
var chroma_default = chroma;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/cmyk2rgb.js
var cmyk2rgb = (...args) => {
  args = unpack_default(args, "cmyk");
  const [c4, m2, y2, k2] = args;
  const alpha = args.length > 4 ? args[4] : 1;
  if (k2 === 1)
    return [0, 0, 0, alpha];
  return [
    c4 >= 1 ? 0 : 255 * (1 - c4) * (1 - k2),
    // r
    m2 >= 1 ? 0 : 255 * (1 - m2) * (1 - k2),
    // g
    y2 >= 1 ? 0 : 255 * (1 - y2) * (1 - k2),
    // b
    alpha
  ];
};
var cmyk2rgb_default = cmyk2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/rgb2cmyk.js
var { max: max2 } = Math;
var rgb2cmyk = (...args) => {
  let [r6, g2, b2] = unpack_default(args, "rgb");
  r6 = r6 / 255;
  g2 = g2 / 255;
  b2 = b2 / 255;
  const k2 = 1 - max2(r6, max2(g2, b2));
  const f4 = k2 < 1 ? 1 / (1 - k2) : 0;
  const c4 = (1 - r6 - k2) * f4;
  const m2 = (1 - g2 - k2) * f4;
  const y2 = (1 - b2 - k2) * f4;
  return [c4, m2, y2, k2];
};
var rgb2cmyk_default = rgb2cmyk;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/cmyk/index.js
Color_default.prototype.cmyk = function() {
  return rgb2cmyk_default(this._rgb);
};
chroma_default.cmyk = (...args) => new Color_default(...args, "cmyk");
input_default.format.cmyk = cmyk2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "cmyk");
    if (type_default(args) === "array" && args.length === 4) {
      return "cmyk";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/hsl2css.js
var rnd = (a2) => Math.round(a2 * 100) / 100;
var hsl2css = (...args) => {
  const hsla = unpack_default(args, "hsla");
  let mode = last_default(args) || "lsa";
  hsla[0] = rnd(hsla[0] || 0);
  hsla[1] = rnd(hsla[1] * 100) + "%";
  hsla[2] = rnd(hsla[2] * 100) + "%";
  if (mode === "hsla" || hsla.length > 3 && hsla[3] < 1) {
    hsla[3] = hsla.length > 3 ? hsla[3] : 1;
    mode = "hsla";
  } else {
    hsla.length = 3;
  }
  return `${mode}(${hsla.join(",")})`;
};
var hsl2css_default = hsl2css;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/rgb2hsl.js
var rgb2hsl = (...args) => {
  args = unpack_default(args, "rgba");
  let [r6, g2, b2] = args;
  r6 /= 255;
  g2 /= 255;
  b2 /= 255;
  const minRgb = min(r6, g2, b2);
  const maxRgb = max(r6, g2, b2);
  const l2 = (maxRgb + minRgb) / 2;
  let s2, h4;
  if (maxRgb === minRgb) {
    s2 = 0;
    h4 = Number.NaN;
  } else {
    s2 = l2 < 0.5 ? (maxRgb - minRgb) / (maxRgb + minRgb) : (maxRgb - minRgb) / (2 - maxRgb - minRgb);
  }
  if (r6 == maxRgb)
    h4 = (g2 - b2) / (maxRgb - minRgb);
  else if (g2 == maxRgb)
    h4 = 2 + (b2 - r6) / (maxRgb - minRgb);
  else if (b2 == maxRgb)
    h4 = 4 + (r6 - g2) / (maxRgb - minRgb);
  h4 *= 60;
  if (h4 < 0)
    h4 += 360;
  if (args.length > 3 && args[3] !== void 0)
    return [h4, s2, l2, args[3]];
  return [h4, s2, l2];
};
var rgb2hsl_default = rgb2hsl;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/rgb2css.js
var { round } = Math;
var rgb2css = (...args) => {
  const rgba = unpack_default(args, "rgba");
  let mode = last_default(args) || "rgb";
  if (mode.substr(0, 3) == "hsl") {
    return hsl2css_default(rgb2hsl_default(rgba), mode);
  }
  rgba[0] = round(rgba[0]);
  rgba[1] = round(rgba[1]);
  rgba[2] = round(rgba[2]);
  if (mode === "rgba" || rgba.length > 3 && rgba[3] < 1) {
    rgba[3] = rgba.length > 3 ? rgba[3] : 1;
    mode = "rgba";
  }
  return `${mode}(${rgba.slice(0, mode === "rgb" ? 3 : 4).join(",")})`;
};
var rgb2css_default = rgb2css;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/hsl2rgb.js
var { round: round2 } = Math;
var hsl2rgb = (...args) => {
  args = unpack_default(args, "hsl");
  const [h4, s2, l2] = args;
  let r6, g2, b2;
  if (s2 === 0) {
    r6 = g2 = b2 = l2 * 255;
  } else {
    const t32 = [0, 0, 0];
    const c4 = [0, 0, 0];
    const t22 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const t1 = 2 * l2 - t22;
    const h_ = h4 / 360;
    t32[0] = h_ + 1 / 3;
    t32[1] = h_;
    t32[2] = h_ - 1 / 3;
    for (let i4 = 0; i4 < 3; i4++) {
      if (t32[i4] < 0)
        t32[i4] += 1;
      if (t32[i4] > 1)
        t32[i4] -= 1;
      if (6 * t32[i4] < 1)
        c4[i4] = t1 + (t22 - t1) * 6 * t32[i4];
      else if (2 * t32[i4] < 1)
        c4[i4] = t22;
      else if (3 * t32[i4] < 2)
        c4[i4] = t1 + (t22 - t1) * (2 / 3 - t32[i4]) * 6;
      else
        c4[i4] = t1;
    }
    [r6, g2, b2] = [round2(c4[0] * 255), round2(c4[1] * 255), round2(c4[2] * 255)];
  }
  if (args.length > 3) {
    return [r6, g2, b2, args[3]];
  }
  return [r6, g2, b2, 1];
};
var hsl2rgb_default = hsl2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/css2rgb.js
var RE_RGB = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/;
var RE_RGBA = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/;
var RE_RGB_PCT = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
var RE_RGBA_PCT = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
var RE_HSL = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/;
var RE_HSLA = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/;
var { round: round3 } = Math;
var css2rgb = (css) => {
  css = css.toLowerCase().trim();
  let m2;
  if (input_default.format.named) {
    try {
      return input_default.format.named(css);
    } catch (e6) {
    }
  }
  if (m2 = css.match(RE_RGB)) {
    const rgb2 = m2.slice(1, 4);
    for (let i4 = 0; i4 < 3; i4++) {
      rgb2[i4] = +rgb2[i4];
    }
    rgb2[3] = 1;
    return rgb2;
  }
  if (m2 = css.match(RE_RGBA)) {
    const rgb2 = m2.slice(1, 5);
    for (let i4 = 0; i4 < 4; i4++) {
      rgb2[i4] = +rgb2[i4];
    }
    return rgb2;
  }
  if (m2 = css.match(RE_RGB_PCT)) {
    const rgb2 = m2.slice(1, 4);
    for (let i4 = 0; i4 < 3; i4++) {
      rgb2[i4] = round3(rgb2[i4] * 2.55);
    }
    rgb2[3] = 1;
    return rgb2;
  }
  if (m2 = css.match(RE_RGBA_PCT)) {
    const rgb2 = m2.slice(1, 5);
    for (let i4 = 0; i4 < 3; i4++) {
      rgb2[i4] = round3(rgb2[i4] * 2.55);
    }
    rgb2[3] = +rgb2[3];
    return rgb2;
  }
  if (m2 = css.match(RE_HSL)) {
    const hsl2 = m2.slice(1, 4);
    hsl2[1] *= 0.01;
    hsl2[2] *= 0.01;
    const rgb2 = hsl2rgb_default(hsl2);
    rgb2[3] = 1;
    return rgb2;
  }
  if (m2 = css.match(RE_HSLA)) {
    const hsl2 = m2.slice(1, 4);
    hsl2[1] *= 0.01;
    hsl2[2] *= 0.01;
    const rgb2 = hsl2rgb_default(hsl2);
    rgb2[3] = +m2[4];
    return rgb2;
  }
};
css2rgb.test = (s2) => {
  return RE_RGB.test(s2) || RE_RGBA.test(s2) || RE_RGB_PCT.test(s2) || RE_RGBA_PCT.test(s2) || RE_HSL.test(s2) || RE_HSLA.test(s2);
};
var css2rgb_default = css2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/css/index.js
Color_default.prototype.css = function(mode) {
  return rgb2css_default(this._rgb, mode);
};
chroma_default.css = (...args) => new Color_default(...args, "css");
input_default.format.css = css2rgb_default;
input_default.autodetect.push({
  p: 5,
  test: (h4, ...rest) => {
    if (!rest.length && type_default(h4) === "string" && css2rgb_default.test(h4)) {
      return "css";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/gl/index.js
input_default.format.gl = (...args) => {
  const rgb2 = unpack_default(args, "rgba");
  rgb2[0] *= 255;
  rgb2[1] *= 255;
  rgb2[2] *= 255;
  return rgb2;
};
chroma_default.gl = (...args) => new Color_default(...args, "gl");
Color_default.prototype.gl = function() {
  const rgb2 = this._rgb;
  return [rgb2[0] / 255, rgb2[1] / 255, rgb2[2] / 255, rgb2[3]];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/hcg2rgb.js
var { floor } = Math;
var hcg2rgb = (...args) => {
  args = unpack_default(args, "hcg");
  let [h4, c4, _g] = args;
  let r6, g2, b2;
  _g = _g * 255;
  const _c = c4 * 255;
  if (c4 === 0) {
    r6 = g2 = b2 = _g;
  } else {
    if (h4 === 360)
      h4 = 0;
    if (h4 > 360)
      h4 -= 360;
    if (h4 < 0)
      h4 += 360;
    h4 /= 60;
    const i4 = floor(h4);
    const f4 = h4 - i4;
    const p2 = _g * (1 - c4);
    const q2 = p2 + _c * (1 - f4);
    const t5 = p2 + _c * f4;
    const v2 = p2 + _c;
    switch (i4) {
      case 0:
        [r6, g2, b2] = [v2, t5, p2];
        break;
      case 1:
        [r6, g2, b2] = [q2, v2, p2];
        break;
      case 2:
        [r6, g2, b2] = [p2, v2, t5];
        break;
      case 3:
        [r6, g2, b2] = [p2, q2, v2];
        break;
      case 4:
        [r6, g2, b2] = [t5, p2, v2];
        break;
      case 5:
        [r6, g2, b2] = [v2, p2, q2];
        break;
    }
  }
  return [r6, g2, b2, args.length > 3 ? args[3] : 1];
};
var hcg2rgb_default = hcg2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/rgb2hcg.js
var rgb2hcg = (...args) => {
  const [r6, g2, b2] = unpack_default(args, "rgb");
  const minRgb = min(r6, g2, b2);
  const maxRgb = max(r6, g2, b2);
  const delta = maxRgb - minRgb;
  const c4 = delta * 100 / 255;
  const _g = minRgb / (255 - delta) * 100;
  let h4;
  if (delta === 0) {
    h4 = Number.NaN;
  } else {
    if (r6 === maxRgb)
      h4 = (g2 - b2) / delta;
    if (g2 === maxRgb)
      h4 = 2 + (b2 - r6) / delta;
    if (b2 === maxRgb)
      h4 = 4 + (r6 - g2) / delta;
    h4 *= 60;
    if (h4 < 0)
      h4 += 360;
  }
  return [h4, c4, _g];
};
var rgb2hcg_default = rgb2hcg;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hcg/index.js
Color_default.prototype.hcg = function() {
  return rgb2hcg_default(this._rgb);
};
chroma_default.hcg = (...args) => new Color_default(...args, "hcg");
input_default.format.hcg = hcg2rgb_default;
input_default.autodetect.push({
  p: 1,
  test: (...args) => {
    args = unpack_default(args, "hcg");
    if (type_default(args) === "array" && args.length === 3) {
      return "hcg";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/hex2rgb.js
var RE_HEX = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
var RE_HEXA = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/;
var hex2rgb = (hex) => {
  if (hex.match(RE_HEX)) {
    if (hex.length === 4 || hex.length === 7) {
      hex = hex.substr(1);
    }
    if (hex.length === 3) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    const u2 = parseInt(hex, 16);
    const r6 = u2 >> 16;
    const g2 = u2 >> 8 & 255;
    const b2 = u2 & 255;
    return [r6, g2, b2, 1];
  }
  if (hex.match(RE_HEXA)) {
    if (hex.length === 5 || hex.length === 9) {
      hex = hex.substr(1);
    }
    if (hex.length === 4) {
      hex = hex.split("");
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    const u2 = parseInt(hex, 16);
    const r6 = u2 >> 24 & 255;
    const g2 = u2 >> 16 & 255;
    const b2 = u2 >> 8 & 255;
    const a2 = Math.round((u2 & 255) / 255 * 100) / 100;
    return [r6, g2, b2, a2];
  }
  throw new Error(`unknown hex color: ${hex}`);
};
var hex2rgb_default = hex2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/rgb2hex.js
var { round: round4 } = Math;
var rgb2hex = (...args) => {
  let [r6, g2, b2, a2] = unpack_default(args, "rgba");
  let mode = last_default(args) || "auto";
  if (a2 === void 0)
    a2 = 1;
  if (mode === "auto") {
    mode = a2 < 1 ? "rgba" : "rgb";
  }
  r6 = round4(r6);
  g2 = round4(g2);
  b2 = round4(b2);
  const u2 = r6 << 16 | g2 << 8 | b2;
  let str = "000000" + u2.toString(16);
  str = str.substr(str.length - 6);
  let hxa = "0" + round4(a2 * 255).toString(16);
  hxa = hxa.substr(hxa.length - 2);
  switch (mode.toLowerCase()) {
    case "rgba":
      return `#${str}${hxa}`;
    case "argb":
      return `#${hxa}${str}`;
    default:
      return `#${str}`;
  }
};
var rgb2hex_default = rgb2hex;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hex/index.js
Color_default.prototype.hex = function(mode) {
  return rgb2hex_default(this._rgb, mode);
};
chroma_default.hex = (...args) => new Color_default(...args, "hex");
input_default.format.hex = hex2rgb_default;
input_default.autodetect.push({
  p: 4,
  test: (h4, ...rest) => {
    if (!rest.length && type_default(h4) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(h4.length) >= 0) {
      return "hex";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/hsi2rgb.js
var { cos } = Math;
var hsi2rgb = (...args) => {
  args = unpack_default(args, "hsi");
  let [h4, s2, i4] = args;
  let r6, g2, b2;
  if (isNaN(h4))
    h4 = 0;
  if (isNaN(s2))
    s2 = 0;
  if (h4 > 360)
    h4 -= 360;
  if (h4 < 0)
    h4 += 360;
  h4 /= 360;
  if (h4 < 1 / 3) {
    b2 = (1 - s2) / 3;
    r6 = (1 + s2 * cos(TWOPI * h4) / cos(PITHIRD - TWOPI * h4)) / 3;
    g2 = 1 - (b2 + r6);
  } else if (h4 < 2 / 3) {
    h4 -= 1 / 3;
    r6 = (1 - s2) / 3;
    g2 = (1 + s2 * cos(TWOPI * h4) / cos(PITHIRD - TWOPI * h4)) / 3;
    b2 = 1 - (r6 + g2);
  } else {
    h4 -= 2 / 3;
    g2 = (1 - s2) / 3;
    b2 = (1 + s2 * cos(TWOPI * h4) / cos(PITHIRD - TWOPI * h4)) / 3;
    r6 = 1 - (g2 + b2);
  }
  r6 = limit_default(i4 * r6 * 3);
  g2 = limit_default(i4 * g2 * 3);
  b2 = limit_default(i4 * b2 * 3);
  return [r6 * 255, g2 * 255, b2 * 255, args.length > 3 ? args[3] : 1];
};
var hsi2rgb_default = hsi2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/rgb2hsi.js
var { min: min2, sqrt, acos } = Math;
var rgb2hsi = (...args) => {
  let [r6, g2, b2] = unpack_default(args, "rgb");
  r6 /= 255;
  g2 /= 255;
  b2 /= 255;
  let h4;
  const min_ = min2(r6, g2, b2);
  const i4 = (r6 + g2 + b2) / 3;
  const s2 = i4 > 0 ? 1 - min_ / i4 : 0;
  if (s2 === 0) {
    h4 = NaN;
  } else {
    h4 = (r6 - g2 + (r6 - b2)) / 2;
    h4 /= sqrt((r6 - g2) * (r6 - g2) + (r6 - b2) * (g2 - b2));
    h4 = acos(h4);
    if (b2 > g2) {
      h4 = TWOPI - h4;
    }
    h4 /= TWOPI;
  }
  return [h4 * 360, s2, i4];
};
var rgb2hsi_default = rgb2hsi;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsi/index.js
Color_default.prototype.hsi = function() {
  return rgb2hsi_default(this._rgb);
};
chroma_default.hsi = (...args) => new Color_default(...args, "hsi");
input_default.format.hsi = hsi2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsi");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsi";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsl/index.js
Color_default.prototype.hsl = function() {
  return rgb2hsl_default(this._rgb);
};
chroma_default.hsl = (...args) => new Color_default(...args, "hsl");
input_default.format.hsl = hsl2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsl");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsl";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/hsv2rgb.js
var { floor: floor2 } = Math;
var hsv2rgb = (...args) => {
  args = unpack_default(args, "hsv");
  let [h4, s2, v2] = args;
  let r6, g2, b2;
  v2 *= 255;
  if (s2 === 0) {
    r6 = g2 = b2 = v2;
  } else {
    if (h4 === 360)
      h4 = 0;
    if (h4 > 360)
      h4 -= 360;
    if (h4 < 0)
      h4 += 360;
    h4 /= 60;
    const i4 = floor2(h4);
    const f4 = h4 - i4;
    const p2 = v2 * (1 - s2);
    const q2 = v2 * (1 - s2 * f4);
    const t5 = v2 * (1 - s2 * (1 - f4));
    switch (i4) {
      case 0:
        [r6, g2, b2] = [v2, t5, p2];
        break;
      case 1:
        [r6, g2, b2] = [q2, v2, p2];
        break;
      case 2:
        [r6, g2, b2] = [p2, v2, t5];
        break;
      case 3:
        [r6, g2, b2] = [p2, q2, v2];
        break;
      case 4:
        [r6, g2, b2] = [t5, p2, v2];
        break;
      case 5:
        [r6, g2, b2] = [v2, p2, q2];
        break;
    }
  }
  return [r6, g2, b2, args.length > 3 ? args[3] : 1];
};
var hsv2rgb_default = hsv2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/rgb2hsv.js
var { min: min3, max: max3 } = Math;
var rgb2hsl2 = (...args) => {
  args = unpack_default(args, "rgb");
  let [r6, g2, b2] = args;
  const min_ = min3(r6, g2, b2);
  const max_ = max3(r6, g2, b2);
  const delta = max_ - min_;
  let h4, s2, v2;
  v2 = max_ / 255;
  if (max_ === 0) {
    h4 = Number.NaN;
    s2 = 0;
  } else {
    s2 = delta / max_;
    if (r6 === max_)
      h4 = (g2 - b2) / delta;
    if (g2 === max_)
      h4 = 2 + (b2 - r6) / delta;
    if (b2 === max_)
      h4 = 4 + (r6 - g2) / delta;
    h4 *= 60;
    if (h4 < 0)
      h4 += 360;
  }
  return [h4, s2, v2];
};
var rgb2hsv_default = rgb2hsl2;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/hsv/index.js
Color_default.prototype.hsv = function() {
  return rgb2hsv_default(this._rgb);
};
chroma_default.hsv = (...args) => new Color_default(...args, "hsv");
input_default.format.hsv = hsv2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "hsv");
    if (type_default(args) === "array" && args.length === 3) {
      return "hsv";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/lab-constants.js
var lab_constants_default = {
  // Corresponds roughly to RGB brighter/darker
  Kn: 18,
  // D65 standard referent
  Xn: 0.95047,
  Yn: 1,
  Zn: 1.08883,
  t0: 0.137931034,
  // 4 / 29
  t1: 0.206896552,
  // 6 / 29
  t2: 0.12841855,
  // 3 * t1 * t1
  t3: 8856452e-9
  // t1 * t1 * t1
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/lab2rgb.js
var { pow } = Math;
var lab2rgb = (...args) => {
  args = unpack_default(args, "lab");
  const [l2, a2, b2] = args;
  let x2, y2, z2, r6, g2, b_;
  y2 = (l2 + 16) / 116;
  x2 = isNaN(a2) ? y2 : y2 + a2 / 500;
  z2 = isNaN(b2) ? y2 : y2 - b2 / 200;
  y2 = lab_constants_default.Yn * lab_xyz(y2);
  x2 = lab_constants_default.Xn * lab_xyz(x2);
  z2 = lab_constants_default.Zn * lab_xyz(z2);
  r6 = xyz_rgb(3.2404542 * x2 - 1.5371385 * y2 - 0.4985314 * z2);
  g2 = xyz_rgb(-0.969266 * x2 + 1.8760108 * y2 + 0.041556 * z2);
  b_ = xyz_rgb(0.0556434 * x2 - 0.2040259 * y2 + 1.0572252 * z2);
  return [r6, g2, b_, args.length > 3 ? args[3] : 1];
};
var xyz_rgb = (r6) => {
  return 255 * (r6 <= 304e-5 ? 12.92 * r6 : 1.055 * pow(r6, 1 / 2.4) - 0.055);
};
var lab_xyz = (t5) => {
  return t5 > lab_constants_default.t1 ? t5 * t5 * t5 : lab_constants_default.t2 * (t5 - lab_constants_default.t0);
};
var lab2rgb_default = lab2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/rgb2lab.js
var { pow: pow2 } = Math;
var rgb2lab = (...args) => {
  const [r6, g2, b2] = unpack_default(args, "rgb");
  const [x2, y2, z2] = rgb2xyz(r6, g2, b2);
  const l2 = 116 * y2 - 16;
  return [l2 < 0 ? 0 : l2, 500 * (x2 - y2), 200 * (y2 - z2)];
};
var rgb_xyz = (r6) => {
  if ((r6 /= 255) <= 0.04045)
    return r6 / 12.92;
  return pow2((r6 + 0.055) / 1.055, 2.4);
};
var xyz_lab = (t5) => {
  if (t5 > lab_constants_default.t3)
    return pow2(t5, 1 / 3);
  return t5 / lab_constants_default.t2 + lab_constants_default.t0;
};
var rgb2xyz = (r6, g2, b2) => {
  r6 = rgb_xyz(r6);
  g2 = rgb_xyz(g2);
  b2 = rgb_xyz(b2);
  const x2 = xyz_lab(
    (0.4124564 * r6 + 0.3575761 * g2 + 0.1804375 * b2) / lab_constants_default.Xn
  );
  const y2 = xyz_lab(
    (0.2126729 * r6 + 0.7151522 * g2 + 0.072175 * b2) / lab_constants_default.Yn
  );
  const z2 = xyz_lab(
    (0.0193339 * r6 + 0.119192 * g2 + 0.9503041 * b2) / lab_constants_default.Zn
  );
  return [x2, y2, z2];
};
var rgb2lab_default = rgb2lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lab/index.js
Color_default.prototype.lab = function() {
  return rgb2lab_default(this._rgb);
};
chroma_default.lab = (...args) => new Color_default(...args, "lab");
input_default.format.lab = lab2rgb_default;
input_default.autodetect.push({
  p: 2,
  test: (...args) => {
    args = unpack_default(args, "lab");
    if (type_default(args) === "array" && args.length === 3) {
      return "lab";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lch2lab.js
var { sin, cos: cos2 } = Math;
var lch2lab = (...args) => {
  let [l2, c4, h4] = unpack_default(args, "lch");
  if (isNaN(h4))
    h4 = 0;
  h4 = h4 * DEG2RAD;
  return [l2, cos2(h4) * c4, sin(h4) * c4];
};
var lch2lab_default = lch2lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lch2rgb.js
var lch2rgb = (...args) => {
  args = unpack_default(args, "lch");
  const [l2, c4, h4] = args;
  const [L, a2, b_] = lch2lab_default(l2, c4, h4);
  const [r6, g2, b2] = lab2rgb_default(L, a2, b_);
  return [r6, g2, b2, args.length > 3 ? args[3] : 1];
};
var lch2rgb_default = lch2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/hcl2rgb.js
var hcl2rgb = (...args) => {
  const hcl = unpack_default(args, "hcl").reverse();
  return lch2rgb_default(...hcl);
};
var hcl2rgb_default = hcl2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/lab2lch.js
var { sqrt: sqrt2, atan2, round: round5 } = Math;
var lab2lch = (...args) => {
  const [l2, a2, b2] = unpack_default(args, "lab");
  const c4 = sqrt2(a2 * a2 + b2 * b2);
  let h4 = (atan2(b2, a2) * RAD2DEG + 360) % 360;
  if (round5(c4 * 1e4) === 0)
    h4 = Number.NaN;
  return [l2, c4, h4];
};
var lab2lch_default = lab2lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/rgb2lch.js
var rgb2lch = (...args) => {
  const [r6, g2, b2] = unpack_default(args, "rgb");
  const [l2, a2, b_] = rgb2lab_default(r6, g2, b2);
  return lab2lch_default(l2, a2, b_);
};
var rgb2lch_default = rgb2lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/lch/index.js
Color_default.prototype.lch = function() {
  return rgb2lch_default(this._rgb);
};
Color_default.prototype.hcl = function() {
  return rgb2lch_default(this._rgb).reverse();
};
chroma_default.lch = (...args) => new Color_default(...args, "lch");
chroma_default.hcl = (...args) => new Color_default(...args, "hcl");
input_default.format.lch = lch2rgb_default;
input_default.format.hcl = hcl2rgb_default;
["lch", "hcl"].forEach(
  (m2) => input_default.autodetect.push({
    p: 2,
    test: (...args) => {
      args = unpack_default(args, m2);
      if (type_default(args) === "array" && args.length === 3) {
        return m2;
      }
    }
  })
);

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/colors/w3cx11.js
var w3cx11 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
var w3cx11_default = w3cx11;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/named/index.js
Color_default.prototype.name = function() {
  const hex = rgb2hex_default(this._rgb, "rgb");
  for (let n5 of Object.keys(w3cx11_default)) {
    if (w3cx11_default[n5] === hex)
      return n5.toLowerCase();
  }
  return hex;
};
input_default.format.named = (name) => {
  name = name.toLowerCase();
  if (w3cx11_default[name])
    return hex2rgb_default(w3cx11_default[name]);
  throw new Error("unknown color name: " + name);
};
input_default.autodetect.push({
  p: 5,
  test: (h4, ...rest) => {
    if (!rest.length && type_default(h4) === "string" && w3cx11_default[h4.toLowerCase()]) {
      return "named";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/num2rgb.js
var num2rgb = (num3) => {
  if (type_default(num3) == "number" && num3 >= 0 && num3 <= 16777215) {
    const r6 = num3 >> 16;
    const g2 = num3 >> 8 & 255;
    const b2 = num3 & 255;
    return [r6, g2, b2, 1];
  }
  throw new Error("unknown num color: " + num3);
};
var num2rgb_default = num2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/rgb2num.js
var rgb2num = (...args) => {
  const [r6, g2, b2] = unpack_default(args, "rgb");
  return (r6 << 16) + (g2 << 8) + b2;
};
var rgb2num_default = rgb2num;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/num/index.js
Color_default.prototype.num = function() {
  return rgb2num_default(this._rgb);
};
chroma_default.num = (...args) => new Color_default(...args, "num");
input_default.format.num = num2rgb_default;
input_default.autodetect.push({
  p: 5,
  test: (...args) => {
    if (args.length === 1 && type_default(args[0]) === "number" && args[0] >= 0 && args[0] <= 16777215) {
      return "num";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/rgb/index.js
var { round: round6 } = Math;
Color_default.prototype.rgb = function(rnd2 = true) {
  if (rnd2 === false)
    return this._rgb.slice(0, 3);
  return this._rgb.slice(0, 3).map(round6);
};
Color_default.prototype.rgba = function(rnd2 = true) {
  return this._rgb.slice(0, 4).map((v2, i4) => {
    return i4 < 3 ? rnd2 === false ? v2 : round6(v2) : v2;
  });
};
chroma_default.rgb = (...args) => new Color_default(...args, "rgb");
input_default.format.rgb = (...args) => {
  const rgba = unpack_default(args, "rgba");
  if (rgba[3] === void 0)
    rgba[3] = 1;
  return rgba;
};
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "rgba");
    if (type_default(args) === "array" && (args.length === 3 || args.length === 4 && type_default(args[3]) == "number" && args[3] >= 0 && args[3] <= 1)) {
      return "rgb";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/temperature2rgb.js
var { log: log3 } = Math;
var temperature2rgb = (kelvin) => {
  const temp = kelvin / 100;
  let r6, g2, b2;
  if (temp < 66) {
    r6 = 255;
    g2 = temp < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (g2 = temp - 2) + 104.49216199393888 * log3(g2);
    b2 = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b2 = temp - 10) + 115.67994401066147 * log3(b2);
  } else {
    r6 = 351.97690566805693 + 0.114206453784165 * (r6 = temp - 55) - 40.25366309332127 * log3(r6);
    g2 = 325.4494125711974 + 0.07943456536662342 * (g2 = temp - 50) - 28.0852963507957 * log3(g2);
    b2 = 255;
  }
  return [r6, g2, b2, 1];
};
var temperature2rgb_default = temperature2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/rgb2temperature.js
var { round: round7 } = Math;
var rgb2temperature = (...args) => {
  const rgb2 = unpack_default(args, "rgb");
  const r6 = rgb2[0], b2 = rgb2[2];
  let minTemp = 1e3;
  let maxTemp = 4e4;
  const eps = 0.4;
  let temp;
  while (maxTemp - minTemp > eps) {
    temp = (maxTemp + minTemp) * 0.5;
    const rgb3 = temperature2rgb_default(temp);
    if (rgb3[2] / rgb3[0] >= b2 / r6) {
      maxTemp = temp;
    } else {
      minTemp = temp;
    }
  }
  return round7(temp);
};
var rgb2temperature_default = rgb2temperature;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/temp/index.js
Color_default.prototype.temp = Color_default.prototype.kelvin = Color_default.prototype.temperature = function() {
  return rgb2temperature_default(this._rgb);
};
chroma_default.temp = chroma_default.kelvin = chroma_default.temperature = (...args) => new Color_default(...args, "temp");
input_default.format.temp = input_default.format.kelvin = input_default.format.temperature = temperature2rgb_default;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/oklab2rgb.js
var { pow: pow3, sign } = Math;
var oklab2rgb = (...args) => {
  args = unpack_default(args, "lab");
  const [L, a2, b2] = args;
  const l2 = pow3(L + 0.3963377774 * a2 + 0.2158037573 * b2, 3);
  const m2 = pow3(L - 0.1055613458 * a2 - 0.0638541728 * b2, 3);
  const s2 = pow3(L - 0.0894841775 * a2 - 1.291485548 * b2, 3);
  return [
    255 * lrgb2rgb(4.0767416621 * l2 - 3.3077115913 * m2 + 0.2309699292 * s2),
    255 * lrgb2rgb(-1.2684380046 * l2 + 2.6097574011 * m2 - 0.3413193965 * s2),
    255 * lrgb2rgb(-0.0041960863 * l2 - 0.7034186147 * m2 + 1.707614701 * s2),
    args.length > 3 ? args[3] : 1
  ];
};
var oklab2rgb_default = oklab2rgb;
function lrgb2rgb(c4) {
  const abs3 = Math.abs(c4);
  if (abs3 > 31308e-7) {
    return (sign(c4) || 1) * (1.055 * pow3(abs3, 1 / 2.4) - 0.055);
  }
  return c4 * 12.92;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/rgb2oklab.js
var { cbrt, pow: pow4, sign: sign2 } = Math;
var rgb2oklab = (...args) => {
  const [r6, g2, b2] = unpack_default(args, "rgb");
  const [lr, lg, lb] = [
    rgb2lrgb(r6 / 255),
    rgb2lrgb(g2 / 255),
    rgb2lrgb(b2 / 255)
  ];
  const l2 = cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
  const m2 = cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
  const s2 = cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);
  return [
    0.2104542553 * l2 + 0.793617785 * m2 - 0.0040720468 * s2,
    1.9779984951 * l2 - 2.428592205 * m2 + 0.4505937099 * s2,
    0.0259040371 * l2 + 0.7827717662 * m2 - 0.808675766 * s2
  ];
};
var rgb2oklab_default = rgb2oklab;
function rgb2lrgb(c4) {
  const abs3 = Math.abs(c4);
  if (abs3 < 0.04045) {
    return c4 / 12.92;
  }
  return (sign2(c4) || 1) * pow4((abs3 + 0.055) / 1.055, 2.4);
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklab/index.js
Color_default.prototype.oklab = function() {
  return rgb2oklab_default(this._rgb);
};
chroma_default.oklab = (...args) => new Color_default(...args, "oklab");
input_default.format.oklab = oklab2rgb_default;
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "oklab");
    if (type_default(args) === "array" && args.length === 3) {
      return "oklab";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/oklch2rgb.js
var oklch2rgb = (...args) => {
  args = unpack_default(args, "lch");
  const [l2, c4, h4] = args;
  const [L, a2, b_] = lch2lab_default(l2, c4, h4);
  const [r6, g2, b2] = oklab2rgb_default(L, a2, b_);
  return [r6, g2, b2, args.length > 3 ? args[3] : 1];
};
var oklch2rgb_default = oklch2rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/rgb2oklch.js
var rgb2oklch = (...args) => {
  const [r6, g2, b2] = unpack_default(args, "rgb");
  const [l2, a2, b_] = rgb2oklab_default(r6, g2, b2);
  return lab2lch_default(l2, a2, b_);
};
var rgb2oklch_default = rgb2oklch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/io/oklch/index.js
Color_default.prototype.oklch = function() {
  return rgb2oklch_default(this._rgb);
};
chroma_default.oklch = (...args) => new Color_default(...args, "oklch");
input_default.format.oklch = oklch2rgb_default;
input_default.autodetect.push({
  p: 3,
  test: (...args) => {
    args = unpack_default(args, "oklch");
    if (type_default(args) === "array" && args.length === 3) {
      return "oklch";
    }
  }
});

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/alpha.js
Color_default.prototype.alpha = function(a2, mutate = false) {
  if (a2 !== void 0 && type_default(a2) === "number") {
    if (mutate) {
      this._rgb[3] = a2;
      return this;
    }
    return new Color_default([this._rgb[0], this._rgb[1], this._rgb[2], a2], "rgb");
  }
  return this._rgb[3];
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/clipped.js
Color_default.prototype.clipped = function() {
  return this._rgb._clipped || false;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/darken.js
Color_default.prototype.darken = function(amount = 1) {
  const me = this;
  const lab2 = me.lab();
  lab2[0] -= lab_constants_default.Kn * amount;
  return new Color_default(lab2, "lab").alpha(me.alpha(), true);
};
Color_default.prototype.brighten = function(amount = 1) {
  return this.darken(-amount);
};
Color_default.prototype.darker = Color_default.prototype.darken;
Color_default.prototype.brighter = Color_default.prototype.brighten;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/get.js
Color_default.prototype.get = function(mc) {
  const [mode, channel] = mc.split(".");
  const src = this[mode]();
  if (channel) {
    const i4 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
    if (i4 > -1)
      return src[i4];
    throw new Error(`unknown channel ${channel} in mode ${mode}`);
  } else {
    return src;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/luminance.js
var { pow: pow5 } = Math;
var EPS = 1e-7;
var MAX_ITER = 20;
Color_default.prototype.luminance = function(lum, mode = "rgb") {
  if (lum !== void 0 && type_default(lum) === "number") {
    if (lum === 0) {
      return new Color_default([0, 0, 0, this._rgb[3]], "rgb");
    }
    if (lum === 1) {
      return new Color_default([255, 255, 255, this._rgb[3]], "rgb");
    }
    let cur_lum = this.luminance();
    let max_iter = MAX_ITER;
    const test = (low, high) => {
      const mid = low.interpolate(high, 0.5, mode);
      const lm = mid.luminance();
      if (Math.abs(lum - lm) < EPS || !max_iter--) {
        return mid;
      }
      return lm > lum ? test(low, mid) : test(mid, high);
    };
    const rgb2 = (cur_lum > lum ? test(new Color_default([0, 0, 0]), this) : test(this, new Color_default([255, 255, 255]))).rgb();
    return new Color_default([...rgb2, this._rgb[3]]);
  }
  return rgb2luminance(...this._rgb.slice(0, 3));
};
var rgb2luminance = (r6, g2, b2) => {
  r6 = luminance_x(r6);
  g2 = luminance_x(g2);
  b2 = luminance_x(b2);
  return 0.2126 * r6 + 0.7152 * g2 + 0.0722 * b2;
};
var luminance_x = (x2) => {
  x2 /= 255;
  return x2 <= 0.03928 ? x2 / 12.92 : pow5((x2 + 0.055) / 1.055, 2.4);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/index.js
var interpolator_default = {};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/mix.js
var mix_default = (col1, col2, f4 = 0.5, ...rest) => {
  let mode = rest[0] || "lrgb";
  if (!interpolator_default[mode] && !rest.length) {
    mode = Object.keys(interpolator_default)[0];
  }
  if (!interpolator_default[mode]) {
    throw new Error(`interpolation mode ${mode} is not defined`);
  }
  if (type_default(col1) !== "object")
    col1 = new Color_default(col1);
  if (type_default(col2) !== "object")
    col2 = new Color_default(col2);
  return interpolator_default[mode](col1, col2, f4).alpha(
    col1.alpha() + f4 * (col2.alpha() - col1.alpha())
  );
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/mix.js
Color_default.prototype.mix = Color_default.prototype.interpolate = function(col2, f4 = 0.5, ...rest) {
  return mix_default(this, col2, f4, ...rest);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/premultiply.js
Color_default.prototype.premultiply = function(mutate = false) {
  const rgb2 = this._rgb;
  const a2 = rgb2[3];
  if (mutate) {
    this._rgb = [rgb2[0] * a2, rgb2[1] * a2, rgb2[2] * a2, a2];
    return this;
  } else {
    return new Color_default([rgb2[0] * a2, rgb2[1] * a2, rgb2[2] * a2, a2], "rgb");
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/saturate.js
Color_default.prototype.saturate = function(amount = 1) {
  const me = this;
  const lch2 = me.lch();
  lch2[1] += lab_constants_default.Kn * amount;
  if (lch2[1] < 0)
    lch2[1] = 0;
  return new Color_default(lch2, "lch").alpha(me.alpha(), true);
};
Color_default.prototype.desaturate = function(amount = 1) {
  return this.saturate(-amount);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/set.js
Color_default.prototype.set = function(mc, value, mutate = false) {
  const [mode, channel] = mc.split(".");
  const src = this[mode]();
  if (channel) {
    const i4 = mode.indexOf(channel) - (mode.substr(0, 2) === "ok" ? 2 : 0);
    if (i4 > -1) {
      if (type_default(value) == "string") {
        switch (value.charAt(0)) {
          case "+":
            src[i4] += +value;
            break;
          case "-":
            src[i4] += +value;
            break;
          case "*":
            src[i4] *= +value.substr(1);
            break;
          case "/":
            src[i4] /= +value.substr(1);
            break;
          default:
            src[i4] = +value;
        }
      } else if (type_default(value) === "number") {
        src[i4] = value;
      } else {
        throw new Error(`unsupported value for Color.set`);
      }
      const out = new Color_default(src, mode);
      if (mutate) {
        this._rgb = out._rgb;
        return this;
      }
      return out;
    }
    throw new Error(`unknown channel ${channel} in mode ${mode}`);
  } else {
    return src;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/ops/shade.js
Color_default.prototype.tint = function(f4 = 0.5, ...rest) {
  return mix_default(this, "white", f4, ...rest);
};
Color_default.prototype.shade = function(f4 = 0.5, ...rest) {
  return mix_default(this, "black", f4, ...rest);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/rgb.js
var rgb = (col1, col2, f4) => {
  const xyz0 = col1._rgb;
  const xyz1 = col2._rgb;
  return new Color_default(
    xyz0[0] + f4 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f4 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f4 * (xyz1[2] - xyz0[2]),
    "rgb"
  );
};
interpolator_default.rgb = rgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lrgb.js
var { sqrt: sqrt3, pow: pow6 } = Math;
var lrgb = (col1, col2, f4) => {
  const [x1, y1, z1] = col1._rgb;
  const [x2, y2, z2] = col2._rgb;
  return new Color_default(
    sqrt3(pow6(x1, 2) * (1 - f4) + pow6(x2, 2) * f4),
    sqrt3(pow6(y1, 2) * (1 - f4) + pow6(y2, 2) * f4),
    sqrt3(pow6(z1, 2) * (1 - f4) + pow6(z2, 2) * f4),
    "rgb"
  );
};
interpolator_default.lrgb = lrgb;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lab.js
var lab = (col1, col2, f4) => {
  const xyz0 = col1.lab();
  const xyz1 = col2.lab();
  return new Color_default(
    xyz0[0] + f4 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f4 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f4 * (xyz1[2] - xyz0[2]),
    "lab"
  );
};
interpolator_default.lab = lab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/_hsx.js
var hsx_default = (col1, col2, f4, m2) => {
  let xyz0, xyz1;
  if (m2 === "hsl") {
    xyz0 = col1.hsl();
    xyz1 = col2.hsl();
  } else if (m2 === "hsv") {
    xyz0 = col1.hsv();
    xyz1 = col2.hsv();
  } else if (m2 === "hcg") {
    xyz0 = col1.hcg();
    xyz1 = col2.hcg();
  } else if (m2 === "hsi") {
    xyz0 = col1.hsi();
    xyz1 = col2.hsi();
  } else if (m2 === "lch" || m2 === "hcl") {
    m2 = "hcl";
    xyz0 = col1.hcl();
    xyz1 = col2.hcl();
  } else if (m2 === "oklch") {
    xyz0 = col1.oklch().reverse();
    xyz1 = col2.oklch().reverse();
  }
  let hue0, hue1, sat0, sat1, lbv0, lbv1;
  if (m2.substr(0, 1) === "h" || m2 === "oklch") {
    [hue0, sat0, lbv0] = xyz0;
    [hue1, sat1, lbv1] = xyz1;
  }
  let sat, hue, lbv, dh;
  if (!isNaN(hue0) && !isNaN(hue1)) {
    if (hue1 > hue0 && hue1 - hue0 > 180) {
      dh = hue1 - (hue0 + 360);
    } else if (hue1 < hue0 && hue0 - hue1 > 180) {
      dh = hue1 + 360 - hue0;
    } else {
      dh = hue1 - hue0;
    }
    hue = hue0 + f4 * dh;
  } else if (!isNaN(hue0)) {
    hue = hue0;
    if ((lbv1 == 1 || lbv1 == 0) && m2 != "hsv")
      sat = sat0;
  } else if (!isNaN(hue1)) {
    hue = hue1;
    if ((lbv0 == 1 || lbv0 == 0) && m2 != "hsv")
      sat = sat1;
  } else {
    hue = Number.NaN;
  }
  if (sat === void 0)
    sat = sat0 + f4 * (sat1 - sat0);
  lbv = lbv0 + f4 * (lbv1 - lbv0);
  return m2 === "oklch" ? new Color_default([lbv, sat, hue], m2) : new Color_default([hue, sat, lbv], m2);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/lch.js
var lch = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "lch");
};
interpolator_default.lch = lch;
interpolator_default.hcl = lch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/num.js
var num2 = (col1, col2, f4) => {
  const c1 = col1.num();
  const c22 = col2.num();
  return new Color_default(c1 + f4 * (c22 - c1), "num");
};
interpolator_default.num = num2;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hcg.js
var hcg = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hcg");
};
interpolator_default.hcg = hcg;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsi.js
var hsi = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hsi");
};
interpolator_default.hsi = hsi;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsl.js
var hsl = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hsl");
};
interpolator_default.hsl = hsl;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/hsv.js
var hsv = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "hsv");
};
interpolator_default.hsv = hsv;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/oklab.js
var oklab = (col1, col2, f4) => {
  const xyz0 = col1.oklab();
  const xyz1 = col2.oklab();
  return new Color_default(
    xyz0[0] + f4 * (xyz1[0] - xyz0[0]),
    xyz0[1] + f4 * (xyz1[1] - xyz0[1]),
    xyz0[2] + f4 * (xyz1[2] - xyz0[2]),
    "oklab"
  );
};
interpolator_default.oklab = oklab;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/interpolator/oklch.js
var oklch = (col1, col2, f4) => {
  return hsx_default(col1, col2, f4, "oklch");
};
interpolator_default.oklch = oklch;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/average.js
var { pow: pow7, sqrt: sqrt4, PI: PI2, cos: cos3, sin: sin2, atan2: atan22 } = Math;
var average_default = (colors, mode = "lrgb", weights = null) => {
  const l2 = colors.length;
  if (!weights)
    weights = Array.from(new Array(l2)).map(() => 1);
  const k2 = l2 / weights.reduce(function(a2, b2) {
    return a2 + b2;
  });
  weights.forEach((w2, i4) => {
    weights[i4] *= k2;
  });
  colors = colors.map((c4) => new Color_default(c4));
  if (mode === "lrgb") {
    return _average_lrgb(colors, weights);
  }
  const first = colors.shift();
  const xyz = first.get(mode);
  const cnt = [];
  let dx = 0;
  let dy = 0;
  for (let i4 = 0; i4 < xyz.length; i4++) {
    xyz[i4] = (xyz[i4] || 0) * weights[0];
    cnt.push(isNaN(xyz[i4]) ? 0 : weights[0]);
    if (mode.charAt(i4) === "h" && !isNaN(xyz[i4])) {
      const A = xyz[i4] / 180 * PI2;
      dx += cos3(A) * weights[0];
      dy += sin2(A) * weights[0];
    }
  }
  let alpha = first.alpha() * weights[0];
  colors.forEach((c4, ci) => {
    const xyz2 = c4.get(mode);
    alpha += c4.alpha() * weights[ci + 1];
    for (let i4 = 0; i4 < xyz.length; i4++) {
      if (!isNaN(xyz2[i4])) {
        cnt[i4] += weights[ci + 1];
        if (mode.charAt(i4) === "h") {
          const A = xyz2[i4] / 180 * PI2;
          dx += cos3(A) * weights[ci + 1];
          dy += sin2(A) * weights[ci + 1];
        } else {
          xyz[i4] += xyz2[i4] * weights[ci + 1];
        }
      }
    }
  });
  for (let i4 = 0; i4 < xyz.length; i4++) {
    if (mode.charAt(i4) === "h") {
      let A = atan22(dy / cnt[i4], dx / cnt[i4]) / PI2 * 180;
      while (A < 0)
        A += 360;
      while (A >= 360)
        A -= 360;
      xyz[i4] = A;
    } else {
      xyz[i4] = xyz[i4] / cnt[i4];
    }
  }
  alpha /= l2;
  return new Color_default(xyz, mode).alpha(alpha > 0.99999 ? 1 : alpha, true);
};
var _average_lrgb = (colors, weights) => {
  const l2 = colors.length;
  const xyz = [0, 0, 0, 0];
  for (let i4 = 0; i4 < colors.length; i4++) {
    const col = colors[i4];
    const f4 = weights[i4] / l2;
    const rgb2 = col._rgb;
    xyz[0] += pow7(rgb2[0], 2) * f4;
    xyz[1] += pow7(rgb2[1], 2) * f4;
    xyz[2] += pow7(rgb2[2], 2) * f4;
    xyz[3] += rgb2[3] * f4;
  }
  xyz[0] = sqrt4(xyz[0]);
  xyz[1] = sqrt4(xyz[1]);
  xyz[2] = sqrt4(xyz[2]);
  if (xyz[3] > 0.9999999)
    xyz[3] = 1;
  return new Color_default(clip_rgb_default(xyz));
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/scale.js
var { pow: pow8 } = Math;
function scale_default(colors) {
  let _mode = "rgb";
  let _nacol = chroma_default("#ccc");
  let _spread = 0;
  let _domain = [0, 1];
  let _pos = [];
  let _padding = [0, 0];
  let _classes = false;
  let _colors = [];
  let _out = false;
  let _min = 0;
  let _max = 1;
  let _correctLightness = false;
  let _colorCache = {};
  let _useCache = true;
  let _gamma = 1;
  const setColors = function(colors2) {
    colors2 = colors2 || ["#fff", "#000"];
    if (colors2 && type_default(colors2) === "string" && chroma_default.brewer && chroma_default.brewer[colors2.toLowerCase()]) {
      colors2 = chroma_default.brewer[colors2.toLowerCase()];
    }
    if (type_default(colors2) === "array") {
      if (colors2.length === 1) {
        colors2 = [colors2[0], colors2[0]];
      }
      colors2 = colors2.slice(0);
      for (let c4 = 0; c4 < colors2.length; c4++) {
        colors2[c4] = chroma_default(colors2[c4]);
      }
      _pos.length = 0;
      for (let c4 = 0; c4 < colors2.length; c4++) {
        _pos.push(c4 / (colors2.length - 1));
      }
    }
    resetCache();
    return _colors = colors2;
  };
  const getClass = function(value) {
    if (_classes != null) {
      const n5 = _classes.length - 1;
      let i4 = 0;
      while (i4 < n5 && value >= _classes[i4]) {
        i4++;
      }
      return i4 - 1;
    }
    return 0;
  };
  let tMapLightness = (t5) => t5;
  let tMapDomain = (t5) => t5;
  const getColor2 = function(val, bypassMap) {
    let col, t5;
    if (bypassMap == null) {
      bypassMap = false;
    }
    if (isNaN(val) || val === null) {
      return _nacol;
    }
    if (!bypassMap) {
      if (_classes && _classes.length > 2) {
        const c4 = getClass(val);
        t5 = c4 / (_classes.length - 2);
      } else if (_max !== _min) {
        t5 = (val - _min) / (_max - _min);
      } else {
        t5 = 1;
      }
    } else {
      t5 = val;
    }
    t5 = tMapDomain(t5);
    if (!bypassMap) {
      t5 = tMapLightness(t5);
    }
    if (_gamma !== 1) {
      t5 = pow8(t5, _gamma);
    }
    t5 = _padding[0] + t5 * (1 - _padding[0] - _padding[1]);
    t5 = limit_default(t5, 0, 1);
    const k2 = Math.floor(t5 * 1e4);
    if (_useCache && _colorCache[k2]) {
      col = _colorCache[k2];
    } else {
      if (type_default(_colors) === "array") {
        for (let i4 = 0; i4 < _pos.length; i4++) {
          const p2 = _pos[i4];
          if (t5 <= p2) {
            col = _colors[i4];
            break;
          }
          if (t5 >= p2 && i4 === _pos.length - 1) {
            col = _colors[i4];
            break;
          }
          if (t5 > p2 && t5 < _pos[i4 + 1]) {
            t5 = (t5 - p2) / (_pos[i4 + 1] - p2);
            col = chroma_default.interpolate(
              _colors[i4],
              _colors[i4 + 1],
              t5,
              _mode
            );
            break;
          }
        }
      } else if (type_default(_colors) === "function") {
        col = _colors(t5);
      }
      if (_useCache) {
        _colorCache[k2] = col;
      }
    }
    return col;
  };
  var resetCache = () => _colorCache = {};
  setColors(colors);
  const f4 = function(v2) {
    const c4 = chroma_default(getColor2(v2));
    if (_out && c4[_out]) {
      return c4[_out]();
    } else {
      return c4;
    }
  };
  f4.classes = function(classes) {
    if (classes != null) {
      if (type_default(classes) === "array") {
        _classes = classes;
        _domain = [classes[0], classes[classes.length - 1]];
      } else {
        const d2 = chroma_default.analyze(_domain);
        if (classes === 0) {
          _classes = [d2.min, d2.max];
        } else {
          _classes = chroma_default.limits(d2, "e", classes);
        }
      }
      return f4;
    }
    return _classes;
  };
  f4.domain = function(domain) {
    if (!arguments.length) {
      return _domain;
    }
    _min = domain[0];
    _max = domain[domain.length - 1];
    _pos = [];
    const k2 = _colors.length;
    if (domain.length === k2 && _min !== _max) {
      for (let d2 of Array.from(domain)) {
        _pos.push((d2 - _min) / (_max - _min));
      }
    } else {
      for (let c4 = 0; c4 < k2; c4++) {
        _pos.push(c4 / (k2 - 1));
      }
      if (domain.length > 2) {
        const tOut = domain.map((d2, i4) => i4 / (domain.length - 1));
        const tBreaks = domain.map((d2) => (d2 - _min) / (_max - _min));
        if (!tBreaks.every((val, i4) => tOut[i4] === val)) {
          tMapDomain = (t5) => {
            if (t5 <= 0 || t5 >= 1)
              return t5;
            let i4 = 0;
            while (t5 >= tBreaks[i4 + 1])
              i4++;
            const f5 = (t5 - tBreaks[i4]) / (tBreaks[i4 + 1] - tBreaks[i4]);
            const out = tOut[i4] + f5 * (tOut[i4 + 1] - tOut[i4]);
            return out;
          };
        }
      }
    }
    _domain = [_min, _max];
    return f4;
  };
  f4.mode = function(_m) {
    if (!arguments.length) {
      return _mode;
    }
    _mode = _m;
    resetCache();
    return f4;
  };
  f4.range = function(colors2, _pos2) {
    setColors(colors2, _pos2);
    return f4;
  };
  f4.out = function(_o) {
    _out = _o;
    return f4;
  };
  f4.spread = function(val) {
    if (!arguments.length) {
      return _spread;
    }
    _spread = val;
    return f4;
  };
  f4.correctLightness = function(v2) {
    if (v2 == null) {
      v2 = true;
    }
    _correctLightness = v2;
    resetCache();
    if (_correctLightness) {
      tMapLightness = function(t5) {
        const L0 = getColor2(0, true).lab()[0];
        const L1 = getColor2(1, true).lab()[0];
        const pol = L0 > L1;
        let L_actual = getColor2(t5, true).lab()[0];
        const L_ideal = L0 + (L1 - L0) * t5;
        let L_diff = L_actual - L_ideal;
        let t0 = 0;
        let t1 = 1;
        let max_iter = 20;
        while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
          (function() {
            if (pol) {
              L_diff *= -1;
            }
            if (L_diff < 0) {
              t0 = t5;
              t5 += (t1 - t5) * 0.5;
            } else {
              t1 = t5;
              t5 += (t0 - t5) * 0.5;
            }
            L_actual = getColor2(t5, true).lab()[0];
            return L_diff = L_actual - L_ideal;
          })();
        }
        return t5;
      };
    } else {
      tMapLightness = (t5) => t5;
    }
    return f4;
  };
  f4.padding = function(p2) {
    if (p2 != null) {
      if (type_default(p2) === "number") {
        p2 = [p2, p2];
      }
      _padding = p2;
      return f4;
    } else {
      return _padding;
    }
  };
  f4.colors = function(numColors, out) {
    if (arguments.length < 2) {
      out = "hex";
    }
    let result = [];
    if (arguments.length === 0) {
      result = _colors.slice(0);
    } else if (numColors === 1) {
      result = [f4(0.5)];
    } else if (numColors > 1) {
      const dm = _domain[0];
      const dd = _domain[1] - dm;
      result = __range__(0, numColors, false).map(
        (i4) => f4(dm + i4 / (numColors - 1) * dd)
      );
    } else {
      colors = [];
      let samples = [];
      if (_classes && _classes.length > 2) {
        for (let i4 = 1, end = _classes.length, asc = 1 <= end; asc ? i4 < end : i4 > end; asc ? i4++ : i4--) {
          samples.push((_classes[i4 - 1] + _classes[i4]) * 0.5);
        }
      } else {
        samples = _domain;
      }
      result = samples.map((v2) => f4(v2));
    }
    if (chroma_default[out]) {
      result = result.map((c4) => c4[out]());
    }
    return result;
  };
  f4.cache = function(c4) {
    if (c4 != null) {
      _useCache = c4;
      return f4;
    } else {
      return _useCache;
    }
  };
  f4.gamma = function(g2) {
    if (g2 != null) {
      _gamma = g2;
      return f4;
    } else {
      return _gamma;
    }
  };
  f4.nodata = function(d2) {
    if (d2 != null) {
      _nacol = chroma_default(d2);
      return f4;
    } else {
      return _nacol;
    }
  };
  return f4;
}
function __range__(left, right, inclusive) {
  let range = [];
  let ascending = left < right;
  let end = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (let i4 = left; ascending ? i4 < end : i4 > end; ascending ? i4++ : i4--) {
    range.push(i4);
  }
  return range;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/bezier.js
var binom_row = function(n5) {
  let row = [1, 1];
  for (let i4 = 1; i4 < n5; i4++) {
    let newrow = [1];
    for (let j2 = 1; j2 <= row.length; j2++) {
      newrow[j2] = (row[j2] || 0) + row[j2 - 1];
    }
    row = newrow;
  }
  return row;
};
var bezier = function(colors) {
  let I2, lab0, lab1, lab2;
  colors = colors.map((c4) => new Color_default(c4));
  if (colors.length === 2) {
    [lab0, lab1] = colors.map((c4) => c4.lab());
    I2 = function(t5) {
      const lab3 = [0, 1, 2].map((i4) => lab0[i4] + t5 * (lab1[i4] - lab0[i4]));
      return new Color_default(lab3, "lab");
    };
  } else if (colors.length === 3) {
    [lab0, lab1, lab2] = colors.map((c4) => c4.lab());
    I2 = function(t5) {
      const lab3 = [0, 1, 2].map(
        (i4) => (1 - t5) * (1 - t5) * lab0[i4] + 2 * (1 - t5) * t5 * lab1[i4] + t5 * t5 * lab2[i4]
      );
      return new Color_default(lab3, "lab");
    };
  } else if (colors.length === 4) {
    let lab3;
    [lab0, lab1, lab2, lab3] = colors.map((c4) => c4.lab());
    I2 = function(t5) {
      const lab4 = [0, 1, 2].map(
        (i4) => (1 - t5) * (1 - t5) * (1 - t5) * lab0[i4] + 3 * (1 - t5) * (1 - t5) * t5 * lab1[i4] + 3 * (1 - t5) * t5 * t5 * lab2[i4] + t5 * t5 * t5 * lab3[i4]
      );
      return new Color_default(lab4, "lab");
    };
  } else if (colors.length >= 5) {
    let labs, row, n5;
    labs = colors.map((c4) => c4.lab());
    n5 = colors.length - 1;
    row = binom_row(n5);
    I2 = function(t5) {
      const u2 = 1 - t5;
      const lab3 = [0, 1, 2].map(
        (i4) => labs.reduce(
          (sum, el, j2) => sum + row[j2] * u2 ** (n5 - j2) * t5 ** j2 * el[i4],
          0
        )
      );
      return new Color_default(lab3, "lab");
    };
  } else {
    throw new RangeError("No point in running bezier with only one color.");
  }
  return I2;
};
var bezier_default = (colors) => {
  const f4 = bezier(colors);
  f4.scale = () => scale_default(f4);
  return f4;
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/blend.js
var blend = (bottom, top, mode) => {
  if (!blend[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blend[mode](bottom, top);
};
var blend_f = (f4) => (bottom, top) => {
  const c0 = chroma_default(top).rgb();
  const c1 = chroma_default(bottom).rgb();
  return chroma_default.rgb(f4(c0, c1));
};
var each = (f4) => (c0, c1) => {
  const out = [];
  out[0] = f4(c0[0], c1[0]);
  out[1] = f4(c0[1], c1[1]);
  out[2] = f4(c0[2], c1[2]);
  return out;
};
var normal = (a2) => a2;
var multiply = (a2, b2) => a2 * b2 / 255;
var darken = (a2, b2) => a2 > b2 ? b2 : a2;
var lighten = (a2, b2) => a2 > b2 ? a2 : b2;
var screen = (a2, b2) => 255 * (1 - (1 - a2 / 255) * (1 - b2 / 255));
var overlay = (a2, b2) => b2 < 128 ? 2 * a2 * b2 / 255 : 255 * (1 - 2 * (1 - a2 / 255) * (1 - b2 / 255));
var burn = (a2, b2) => 255 * (1 - (1 - b2 / 255) / (a2 / 255));
var dodge = (a2, b2) => {
  if (a2 === 255)
    return 255;
  a2 = 255 * (b2 / 255) / (1 - a2 / 255);
  return a2 > 255 ? 255 : a2;
};
blend.normal = blend_f(each(normal));
blend.multiply = blend_f(each(multiply));
blend.screen = blend_f(each(screen));
blend.overlay = blend_f(each(overlay));
blend.darken = blend_f(each(darken));
blend.lighten = blend_f(each(lighten));
blend.dodge = blend_f(each(dodge));
blend.burn = blend_f(each(burn));
var blend_default = blend;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/cubehelix.js
var { pow: pow9, sin: sin3, cos: cos4 } = Math;
function cubehelix_default(start = 300, rotations = -1.5, hue = 1, gamma = 1, lightness = [0, 1]) {
  let dh = 0, dl;
  if (type_default(lightness) === "array") {
    dl = lightness[1] - lightness[0];
  } else {
    dl = 0;
    lightness = [lightness, lightness];
  }
  const f4 = function(fract) {
    const a2 = TWOPI * ((start + 120) / 360 + rotations * fract);
    const l2 = pow9(lightness[0] + dl * fract, gamma);
    const h4 = dh !== 0 ? hue[0] + fract * dh : hue;
    const amp = h4 * l2 * (1 - l2) / 2;
    const cos_a = cos4(a2);
    const sin_a = sin3(a2);
    const r6 = l2 + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
    const g2 = l2 + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
    const b2 = l2 + amp * (1.97294 * cos_a);
    return chroma_default(clip_rgb_default([r6 * 255, g2 * 255, b2 * 255, 1]));
  };
  f4.start = function(s2) {
    if (s2 == null) {
      return start;
    }
    start = s2;
    return f4;
  };
  f4.rotations = function(r6) {
    if (r6 == null) {
      return rotations;
    }
    rotations = r6;
    return f4;
  };
  f4.gamma = function(g2) {
    if (g2 == null) {
      return gamma;
    }
    gamma = g2;
    return f4;
  };
  f4.hue = function(h4) {
    if (h4 == null) {
      return hue;
    }
    hue = h4;
    if (type_default(hue) === "array") {
      dh = hue[1] - hue[0];
      if (dh === 0) {
        hue = hue[1];
      }
    } else {
      dh = 0;
    }
    return f4;
  };
  f4.lightness = function(h4) {
    if (h4 == null) {
      return lightness;
    }
    if (type_default(h4) === "array") {
      lightness = h4;
      dl = h4[1] - h4[0];
    } else {
      lightness = [h4, h4];
      dl = 0;
    }
    return f4;
  };
  f4.scale = () => chroma_default.scale(f4);
  f4.hue(hue);
  return f4;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/generator/random.js
var digits = "0123456789abcdef";
var { floor: floor3, random } = Math;
var random_default = () => {
  let code = "#";
  for (let i4 = 0; i4 < 6; i4++) {
    code += digits.charAt(floor3(random() * 16));
  }
  return new Color_default(code, "hex");
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/analyze.js
var { log: log4, pow: pow10, floor: floor4, abs } = Math;
function analyze2(data, key = null) {
  const r6 = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  if (type_default(data) === "object") {
    data = Object.values(data);
  }
  data.forEach((val) => {
    if (key && type_default(val) === "object")
      val = val[key];
    if (val !== void 0 && val !== null && !isNaN(val)) {
      r6.values.push(val);
      r6.sum += val;
      if (val < r6.min)
        r6.min = val;
      if (val > r6.max)
        r6.max = val;
      r6.count += 1;
    }
  });
  r6.domain = [r6.min, r6.max];
  r6.limits = (mode, num3) => limits(r6, mode, num3);
  return r6;
}
function limits(data, mode = "equal", num3 = 7) {
  if (type_default(data) == "array") {
    data = analyze2(data);
  }
  const { min: min6, max: max6 } = data;
  const values = data.values.sort((a2, b2) => a2 - b2);
  if (num3 === 1) {
    return [min6, max6];
  }
  const limits2 = [];
  if (mode.substr(0, 1) === "c") {
    limits2.push(min6);
    limits2.push(max6);
  }
  if (mode.substr(0, 1) === "e") {
    limits2.push(min6);
    for (let i4 = 1; i4 < num3; i4++) {
      limits2.push(min6 + i4 / num3 * (max6 - min6));
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "l") {
    if (min6 <= 0) {
      throw new Error(
        "Logarithmic scales are only possible for values > 0"
      );
    }
    const min_log = Math.LOG10E * log4(min6);
    const max_log = Math.LOG10E * log4(max6);
    limits2.push(min6);
    for (let i4 = 1; i4 < num3; i4++) {
      limits2.push(pow10(10, min_log + i4 / num3 * (max_log - min_log)));
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "q") {
    limits2.push(min6);
    for (let i4 = 1; i4 < num3; i4++) {
      const p2 = (values.length - 1) * i4 / num3;
      const pb = floor4(p2);
      if (pb === p2) {
        limits2.push(values[pb]);
      } else {
        const pr = p2 - pb;
        limits2.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
      }
    }
    limits2.push(max6);
  } else if (mode.substr(0, 1) === "k") {
    let cluster;
    const n5 = values.length;
    const assignments = new Array(n5);
    const clusterSizes = new Array(num3);
    let repeat = true;
    let nb_iters = 0;
    let centroids = null;
    centroids = [];
    centroids.push(min6);
    for (let i4 = 1; i4 < num3; i4++) {
      centroids.push(min6 + i4 / num3 * (max6 - min6));
    }
    centroids.push(max6);
    while (repeat) {
      for (let j2 = 0; j2 < num3; j2++) {
        clusterSizes[j2] = 0;
      }
      for (let i4 = 0; i4 < n5; i4++) {
        const value = values[i4];
        let mindist = Number.MAX_VALUE;
        let best;
        for (let j2 = 0; j2 < num3; j2++) {
          const dist = abs(centroids[j2] - value);
          if (dist < mindist) {
            mindist = dist;
            best = j2;
          }
          clusterSizes[best]++;
          assignments[i4] = best;
        }
      }
      const newCentroids = new Array(num3);
      for (let j2 = 0; j2 < num3; j2++) {
        newCentroids[j2] = null;
      }
      for (let i4 = 0; i4 < n5; i4++) {
        cluster = assignments[i4];
        if (newCentroids[cluster] === null) {
          newCentroids[cluster] = values[i4];
        } else {
          newCentroids[cluster] += values[i4];
        }
      }
      for (let j2 = 0; j2 < num3; j2++) {
        newCentroids[j2] *= 1 / clusterSizes[j2];
      }
      repeat = false;
      for (let j2 = 0; j2 < num3; j2++) {
        if (newCentroids[j2] !== centroids[j2]) {
          repeat = true;
          break;
        }
      }
      centroids = newCentroids;
      nb_iters++;
      if (nb_iters > 200) {
        repeat = false;
      }
    }
    const kClusters = {};
    for (let j2 = 0; j2 < num3; j2++) {
      kClusters[j2] = [];
    }
    for (let i4 = 0; i4 < n5; i4++) {
      cluster = assignments[i4];
      kClusters[cluster].push(values[i4]);
    }
    let tmpKMeansBreaks = [];
    for (let j2 = 0; j2 < num3; j2++) {
      tmpKMeansBreaks.push(kClusters[j2][0]);
      tmpKMeansBreaks.push(kClusters[j2][kClusters[j2].length - 1]);
    }
    tmpKMeansBreaks = tmpKMeansBreaks.sort((a2, b2) => a2 - b2);
    limits2.push(tmpKMeansBreaks[0]);
    for (let i4 = 1; i4 < tmpKMeansBreaks.length; i4 += 2) {
      const v2 = tmpKMeansBreaks[i4];
      if (!isNaN(v2) && limits2.indexOf(v2) === -1) {
        limits2.push(v2);
      }
    }
  }
  return limits2;
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/contrast.js
var contrast_default = (a2, b2) => {
  a2 = new Color_default(a2);
  b2 = new Color_default(b2);
  const l1 = a2.luminance();
  const l2 = b2.luminance();
  return l1 > l2 ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05);
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/delta-e.js
var { sqrt: sqrt5, pow: pow11, min: min4, max: max4, atan2: atan23, abs: abs2, cos: cos5, sin: sin4, exp, PI: PI3 } = Math;
function delta_e_default(a2, b2, Kl = 1, Kc = 1, Kh = 1) {
  var rad2deg = function(rad) {
    return 360 * rad / (2 * PI3);
  };
  var deg2rad = function(deg) {
    return 2 * PI3 * deg / 360;
  };
  a2 = new Color_default(a2);
  b2 = new Color_default(b2);
  const [L1, a1, b1] = Array.from(a2.lab());
  const [L2, a22, b22] = Array.from(b2.lab());
  const avgL = (L1 + L2) / 2;
  const C1 = sqrt5(pow11(a1, 2) + pow11(b1, 2));
  const C2 = sqrt5(pow11(a22, 2) + pow11(b22, 2));
  const avgC = (C1 + C2) / 2;
  const G2 = 0.5 * (1 - sqrt5(pow11(avgC, 7) / (pow11(avgC, 7) + pow11(25, 7))));
  const a1p = a1 * (1 + G2);
  const a2p = a22 * (1 + G2);
  const C1p = sqrt5(pow11(a1p, 2) + pow11(b1, 2));
  const C2p = sqrt5(pow11(a2p, 2) + pow11(b22, 2));
  const avgCp = (C1p + C2p) / 2;
  const arctan1 = rad2deg(atan23(b1, a1p));
  const arctan2 = rad2deg(atan23(b22, a2p));
  const h1p = arctan1 >= 0 ? arctan1 : arctan1 + 360;
  const h2p = arctan2 >= 0 ? arctan2 : arctan2 + 360;
  const avgHp = abs2(h1p - h2p) > 180 ? (h1p + h2p + 360) / 2 : (h1p + h2p) / 2;
  const T2 = 1 - 0.17 * cos5(deg2rad(avgHp - 30)) + 0.24 * cos5(deg2rad(2 * avgHp)) + 0.32 * cos5(deg2rad(3 * avgHp + 6)) - 0.2 * cos5(deg2rad(4 * avgHp - 63));
  let deltaHp = h2p - h1p;
  deltaHp = abs2(deltaHp) <= 180 ? deltaHp : h2p <= h1p ? deltaHp + 360 : deltaHp - 360;
  deltaHp = 2 * sqrt5(C1p * C2p) * sin4(deg2rad(deltaHp) / 2);
  const deltaL = L2 - L1;
  const deltaCp = C2p - C1p;
  const sl = 1 + 0.015 * pow11(avgL - 50, 2) / sqrt5(20 + pow11(avgL - 50, 2));
  const sc = 1 + 0.045 * avgCp;
  const sh = 1 + 0.015 * avgCp * T2;
  const deltaTheta = 30 * exp(-pow11((avgHp - 275) / 25, 2));
  const Rc = 2 * sqrt5(pow11(avgCp, 7) / (pow11(avgCp, 7) + pow11(25, 7)));
  const Rt2 = -Rc * sin4(2 * deg2rad(deltaTheta));
  const result = sqrt5(
    pow11(deltaL / (Kl * sl), 2) + pow11(deltaCp / (Kc * sc), 2) + pow11(deltaHp / (Kh * sh), 2) + Rt2 * (deltaCp / (Kc * sc)) * (deltaHp / (Kh * sh))
  );
  return max4(0, min4(100, result));
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/distance.js
function distance_default(a2, b2, mode = "lab") {
  a2 = new Color_default(a2);
  b2 = new Color_default(b2);
  const l1 = a2.get(mode);
  const l2 = b2.get(mode);
  let sum_sq = 0;
  for (let i4 in l1) {
    const d2 = (l1[i4] || 0) - (l2[i4] || 0);
    sum_sq += d2 * d2;
  }
  return Math.sqrt(sum_sq);
}

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/valid.js
var valid_default = (...args) => {
  try {
    new Color_default(...args);
    return true;
  } catch (e6) {
    return false;
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/utils/scales.js
var scales_default = {
  cool() {
    return scale_default([chroma_default.hsl(180, 1, 0.9), chroma_default.hsl(250, 0.7, 0.4)]);
  },
  hot() {
    return scale_default(["#000", "#f00", "#ff0", "#fff"], [0, 0.25, 0.75, 1]).mode(
      "rgb"
    );
  }
};

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/src/colors/colorbrewer.js
var colorbrewer = {
  // sequential
  OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
  PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
  BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
  Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
  BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
  YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
  YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
  Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
  RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
  Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
  YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
  Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
  GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
  Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
  YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
  PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
  Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
  PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
  Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
  // diverging
  Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
  RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
  RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
  PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
  PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
  RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
  BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
  RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
  PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
  // qualitative
  Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
  Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
  Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
  Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
  Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
  Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
  Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
  Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
};
for (let key of Object.keys(colorbrewer)) {
  colorbrewer[key.toLowerCase()] = colorbrewer[key];
}
var colorbrewer_default = colorbrewer;

// ../../../node_modules/.pnpm/chroma-js@2.6.0/node_modules/chroma-js/index.js
Object.assign(chroma_default, {
  average: average_default,
  bezier: bezier_default,
  blend: blend_default,
  cubehelix: cubehelix_default,
  mix: mix_default,
  interpolate: mix_default,
  random: random_default,
  scale: scale_default,
  analyze: analyze2,
  contrast: contrast_default,
  deltaE: delta_e_default,
  distance: distance_default,
  limits,
  valid: valid_default,
  scales: scales_default,
  input: input_default,
  colors: w3cx11_default,
  brewer: colorbrewer_default
});
var chroma_js_default = chroma_default;

// src/helper/overridePrimitiveColors.ts
var overridePrimitiveColors = () => {
  const inlangSettings = document.querySelector("inlang-settings");
  if (!inlangSettings)
    return void 0;
  const primitives = ["primary", "success", "warning", "danger", "neutral"];
  for (const primitive of primitives) {
    const unformattedColor = window.getComputedStyle(inlangSettings).getPropertyValue(`--inlang-color-${primitive}`).trim();
    if (unformattedColor !== "") {
      const colorShades = getPalette(unformattedColor);
      appendCSSProperties(colorShades, primitive, inlangSettings);
    }
  }
};
var appendCSSProperties = (colorShades, primitive, element) => {
  let textContent = Object.entries(colorShades).map(([index2, shade]) => `--sl-color-${primitive}-${index2}: ${shade} !important;`).join("\n");
  textContent = ":host { " + textContent + " }";
  const shadowRoot = element.shadowRoot || element.attachShadow({ mode: "open" });
  const style = document.createElement("style");
  style.textContent = textContent;
  shadowRoot.appendChild(style);
};
var getColor = (unformattedColor) => chroma_js_default(unformattedColor);
var getPalette = (unformattedColor) => {
  const color = getColor(unformattedColor);
  const colors = chroma_js_default.scale(["white", color, "black"]).domain([0, 0.6, 1]).mode("lrgb");
  const palette = {};
  palette[50] = colors(0.05).hex();
  for (let i4 = 0.1; i4 < 0.9; i4 += 0.1) {
    palette[Math.round(i4 * 1e3)] = colors(i4).hex();
  }
  palette[950] = colors(0.95).hex();
  return palette;
};
var overridePrimitiveColors_default = overridePrimitiveColors;

// ../marketplace-registry/dist/registry.js
var registry = [
  {
    uniqueID: "zu942ln6",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "app.inlang.badge",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/badge/assets/images/badge-icon.jpg",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/badge-marketplace-cover.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/badge-gallery/badge-gallery-image-1.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/badge-gallery/badge-gallery-image-2.jpg"
    ],
    displayName: {
      en: "Translation status badge"
    },
    description: {
      en: "Badge showing missing messages in your codebase. Perfect for your README.md file."
    },
    pages: {
      "/": "./inlang/source-code/badge/README.md",
      "/changelog": "./inlang/source-code/badge/CHANGELOG.md"
    },
    keywords: [
      "apps",
      "badge",
      "markdown",
      "translation",
      "status",
      "lix",
      "svelte",
      "nextjs",
      "astro",
      "inlang",
      "solid"
    ],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0",
    pricing: "Free"
  },
  {
    uniqueID: "2qj2w8pu",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "app.inlang.cli",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/cli/assets/cli-icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/cli-marketplace-cover.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/cli-gallery/cli-gallery-image-1.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/cli-gallery/cli-gallery-image-2.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/cli-gallery/cli-gallery-image-3.jpg"
    ],
    displayName: {
      en: "CLI - Translation Automation"
    },
    description: {
      en: "Command line interface for inlang projects. Many commands and the possibility to do translation automation."
    },
    pages: {
      "/": "./inlang/source-code/cli/README.md",
      "/changelog": "./inlang/source-code/cli/CHANGELOG.md"
    },
    keywords: [
      "cli",
      "commands",
      "application",
      "website",
      "developer",
      "ai",
      "ci/cd",
      "lix",
      "svelte",
      "nextjs",
      "astro",
      "remix",
      "inlang",
      "solid"
    ],
    pricing: "free",
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "tdozzpar",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "app.inlang.finkLocalizationEditor",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/editor/assets/new-fink-logo.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/editor-marketplace-cover.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/editor-gallery/editor-gallery-image-1.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/editor-gallery/editor-gallery-image-2.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/editor-gallery/editor-gallery-image-3.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/editor-gallery/editor-gallery-image-4.jpg"
    ],
    displayName: {
      en: "Fink \u2013 Localization Editor"
    },
    description: {
      en: "Your translation workflow with no-code setup and repository-based operation \u2014 the ideal i18n solution for translators."
    },
    pages: {
      Overview: {
        "/": "./inlang/source-code/editor/README.md",
        "/supported-i18n-libraries": "./inlang/source-code/editor/docs/supported-i18n-libraries.md"
      },
      Guides: {
        Usage: "/g/6ddyhpoi/guide-nilsjacobsen-contributeTranslationsWithFink",
        "What is inlang?": "/g/7777asdy/guide-nilsjacobsen-ecosystemCompatible"
      }
    },
    keywords: [
      "editor",
      "web",
      "apps",
      "website",
      "translator",
      "lix",
      "fink",
      "inlang",
      "astro",
      "remix",
      "nextjs",
      "svelte",
      "solid"
    ],
    recommends: ["m/3gk8n4n4", "m/gerre34r", "m/reootnfj", "m/4cxm3eqi"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://fink.inlang.com/",
    license: "PolyForm Noncommercial License 1.0.0",
    pricing: "Free Beta"
  },
  {
    uniqueID: "92fst3wd",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "app.inlang.globelens",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/globelens/assets/GlobeLens-logo.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/globelens/assets/GlobeLens-01.png"
    ],
    displayName: {
      en: "GlobeLens \u2013 i18n SEO Analysis"
    },
    description: {
      en: "Check how your pages perform in different markets. GlobeLens is a tool for international SEO analysis."
    },
    pages: {
      "/": "./inlang/source-code/globelens/README.md"
    },
    keywords: ["analysis", "i18n", "apps", "seo", "test", "url", "keyword", "inlang"],
    pricing: "FREE BETA",
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "r7kp499g",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "app.inlang.ideExtension",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/vscode_extension-marketplace-cover.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/vscode_extension-gallery/vscode_extension-gallery-image-1.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/vscode_extension-gallery/vscode_extension-gallery-image-2.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/vscode_extension-gallery/vscode_extension-gallery-image-3.jpg"
    ],
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/ide-extension/assets/sherlock-logo.png",
    displayName: {
      en: "Sherlock - VS Code extension"
    },
    description: {
      en: "Visualize, edit & lint translated strings at a glance via Inline Decorations & Hover Support, and extract new strings with a single click."
    },
    pages: {
      "": {
        "/": "./inlang/source-code/ide-extension/MARKETPLACE.md"
      },
      "Getting Started": {
        "/quick-start": "./inlang/source-code/ide-extension/docs/quick-start.md",
        "/customization": "./inlang/source-code/ide-extension/docs/customization.md",
        "/supported-i18n-libraries": "./inlang/source-code/ide-extension/docs/supported-i18n-libraries.md",
        "/video-tour": "./inlang/source-code/ide-extension/docs/video-tour.md"
      },
      Appendix: {
        "/changelog": "./inlang/source-code/ide-extension/CHANGELOG.md"
      }
    },
    keywords: [
      "apps",
      "website",
      "developer",
      "vscode",
      "ide",
      "extension",
      "lix",
      "Sherlock",
      "inspector",
      "svelte",
      "nextjs",
      "remix",
      "astro",
      "inlang",
      "solid"
    ],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://marketplace.visualstudio.com/items?itemName=inlang.vs-code-extension",
    license: "PolyForm Noncommercial License 1.0.0",
    pricing: "Free"
  },
  {
    uniqueID: "3gk8n4n4",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "app.inlang.ninjaI18nAction",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/github-lint-action/assets/ninja-logo.png",
    gallery: [],
    displayName: {
      en: "Ninja i18n - GitHub Lint Action"
    },
    description: {
      en: "This action checks for translation issues within your PRs."
    },
    pages: {
      "/": "./inlang/source-code/github-lint-action/MARKETPLACE.md",
      "/changelog": "./inlang/source-code/github-lint-action/CHANGELOG.md"
    },
    keywords: [
      "developer",
      "ci/cd",
      "github",
      "lint",
      "action",
      "application",
      "website",
      "translation",
      "localization",
      "i18n",
      "inlang"
    ],
    recommends: ["g/ssryldhd", "g/6ddyhpoi", "m/r7kp499g", "m/tdozzpar"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://github.com/marketplace/actions/ninja-i18n",
    license: "Apache-2.0",
    pricing: "Free"
  },
  {
    uniqueID: "gkrpgoir",
    id: "app.parrot.figmaPlugin",
    icon: "https://cdn.jsdelivr.net/gh/parrot-global/parrot@main/parrot-logo.svg",
    gallery: [
      "https://cdn.jsdelivr.net/gh/parrot-global/parrot@main/cover.png",
      "https://cdn.jsdelivr.net/gh/parrot-global/parrot@main/layers.png",
      "https://cdn.jsdelivr.net/gh/parrot-global/parrot@main/messages.png"
    ],
    displayName: {
      en: "Parrot \u2013 i18n Figma plugin"
    },
    description: {
      en: "Parrot simplifies the translation management process right within Figma. If you deal with multilingual design projects and want to streamline your translation workflow, this plugin is for you!"
    },
    readme: {
      en: "https://cdn.jsdelivr.net/gh/parrot-global/parrot@latest/README.md"
    },
    keywords: ["editor", "web", "figma", "application", "website", "translator", "lix"],
    publisherName: "Parrot.global",
    publisherIcon: "https://cdn.jsdelivr.net/gh/parrot-global/parrot@main/parrot-logo.svg",
    license: "PolyForm Strict License 1.0.0"
  },
  {
    uniqueID: "940fn8mg",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.floriankiem.i18nMistakes",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/i18n-mistakes/assets/computer-icon.jpg",
    displayName: {
      en: "Localization Mistakes and How to Avoid Them when Internationalizing (i18n) your App"
    },
    description: {
      en: "This guide will help you avoid common mistakes when localizing your app. It will also help you understand the importance of localization and how to do it right."
    },
    readme: {
      en: "./inlang/guides/i18n-mistakes/i18n-mistakes.md"
    },
    keywords: [
      "i18n",
      "mistakes",
      "error",
      "not working",
      "how to",
      "avoid",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "guides-i18n"
    ],
    recommends: ["g/38fnf03n", "m/3i8bor92", "g/3go4f04m", "g/6ddyhpoi"],
    publisherName: "Florian Kiem",
    publisherIcon: "https://avatars.githubusercontent.com/u/92092993?v=4",
    license: "Apache-2.0"
  },
  {
    uniqueID: "38fnf03n",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.floriankiem.localizationStrategy",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/localization-strategy/assets/pin-icon.jpg",
    displayName: {
      en: "Localization Strategy: Best Practices for SEO and Global Ranking"
    },
    description: {
      en: "Learn how to avoid common pitfalls and implement best practices in app localization with this comprehensive guide. Discover practical tips to enhance your global ranking and ensure a successful localization strategy."
    },
    readme: {
      en: "./inlang/guides/localization-strategy/localization-strategy.md"
    },
    keywords: [
      "i18n",
      "localization",
      "l10n",
      "strategy",
      "how to do localization",
      "how to do i18n",
      "how to do l10n",
      "globalization",
      "internationalization",
      "guide",
      "localization guide",
      "guides-i18n"
    ],
    recommends: ["g/940fn8mg", "g/3go4f04m", "g/6ddyhpoi"],
    publisherName: "Florian Kiem",
    publisherIcon: "https://avatars.githubusercontent.com/u/92092993?v=4",
    license: "Apache-2.0"
  },
  {
    uniqueID: "94ng94n4",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.inlang.buildOwnApp",
    displayName: {
      en: "How to build an inlang app"
    },
    description: {
      en: "This guide gives you an introduction on how to build your own inlang app."
    },
    readme: {
      en: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/how-to-inlang-app/how-to-inlang-app.md"
    },
    keywords: ["app", "build", "applicaton", "website", "guides-general"],
    publisherName: "Felix H\xE4berle",
    publisherIcon: "https://avatars.githubusercontent.com/u/34959078?v=4",
    license: "Apache-2.0"
  },
  {
    uniqueID: "pposhsfh",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.kevinccbsg.useParaglideJsWithRemix",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo/inlang/external-projects/remix-paraglidejs/assets/remix.svg",
    displayName: {
      en: "Use ParaglideJS with Remix"
    },
    description: {
      en: "This guide covers how to integrate ParaglideJS into a Remix project."
    },
    readme: {
      en: "./inlang/guides/use-paraglide-with-remix/use-paraglide-with-remix.md"
    },
    keywords: [
      "application",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "react",
      "build",
      "javascript",
      "ide",
      "guide",
      "remix",
      "react",
      "i18n routing",
      "guides-developer"
    ],
    recommends: ["m/fnhuwzrx", "m/gerre34r", "m/r7kp499g"],
    publisherName: "Kevin Mart\xEDnez",
    publisherIcon: "https://avatars.githubusercontent.com/u/12685053?v=4",
    publisherLink: "https://github.com/BRIKEV",
    license: "Apache-2.0"
  },
  {
    uniqueID: "utqgkmzp",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.lorissigrist.buildAGlobalAstroApp",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/build-an-internationalized-astro-app-using-paraglide/icon.svg",
    displayName: {
      en: "Build an internationalized Astro App using Paraglide"
    },
    description: {
      en: "Learn how to set up Paraglide in an Astro project."
    },
    readme: {
      en: "./inlang/guides/build-an-internationalized-astro-app-using-paraglide/build-an-internationalized-astro-app-using-paraglide.md"
    },
    keywords: [
      "libraries",
      "developer",
      "paraglide",
      "i18n",
      "internationalization",
      "astro",
      "astro.build",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "javascript",
      "typescript",
      "ide",
      "guide",
      "guides-developer"
    ],
    recommends: ["g/3go4f04m", "g/00162hsd", "g/38fnf03n"],
    publisherName: "LorisSigrist",
    publisherIcon: "https://avatars.githubusercontent.com/u/43482866?v=4",
    publisherLink: "https://github.com/LorisSigrist",
    license: "Apache-2.0"
  },
  {
    uniqueID: "lubhdyua",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.lorissigrist.buildAGlobalSolidStartApp",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/build-a-global-solidstart-app/icon.png",
    displayName: {
      en: "Build a Global SolidStart App"
    },
    description: {
      en: "A complete guide on how to adopt inlang with paraglide.js and message-format-plugin in your SolidStart project."
    },
    readme: {
      en: "./inlang/guides/build-a-global-solidstart-app/build-a-global-solidstart-app.md"
    },
    keywords: [
      "libraries",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "solid",
      "solidstart",
      "javascript",
      "ide",
      "guide",
      "guides-developer"
    ],
    recommends: ["g/3go4f04m", "g/00162hsd", "g/38fnf03n"],
    publisherName: "LorisSigrist",
    publisherIcon: "https://avatars.githubusercontent.com/u/43482866?v=4",
    publisherLink: "https://github.com/LorisSigrist",
    license: "Apache-2.0"
  },
  {
    uniqueID: "mqlyfa7l",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.lorissigrist.dontlazyload",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/dont-lazy-load/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/dont-lazy-load/assets/thumbnail.png"
    ],
    displayName: {
      en: "Don't Lazy-Load Translations"
    },
    description: {
      en: "Lazy-loading translations can seriously hurt your web-vitals. Here is what to do instead."
    },
    readme: {
      en: "./inlang/guides/dont-lazy-load/README.md"
    },
    keywords: [
      "i18n",
      "l10n",
      "developer",
      "contribute",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "ecosystem",
      "compatible",
      "ecosystem compatible",
      "astro",
      "remix",
      "vue",
      "angular",
      "flutter",
      "guides-general",
      "guides-developer"
    ],
    recommends: ["m/gerre34r", "g/00162hsd", "g/wxcebbig", "g/uxohikde"],
    publisherName: "Loris Sigrist",
    publisherIcon: "https://avatars.githubusercontent.com/u/43482866?v=4",
    publisherLink: "https://github.com/LorisSigrist",
    license: "Apache-2.0"
  },
  {
    uniqueID: "wxcebbig",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.lorissigrist.useParaglideJsWithNextjsAppRouter",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/use-paraglide-with-nextjs-app-router/app-router-logo.png",
    displayName: {
      en: "Use ParaglideJS with the NextJS App Router"
    },
    description: {
      en: "This guide covers how to integrate ParaglideJS into a NextJS project using the app router. It will cover server & client components, i18n routing and more!"
    },
    readme: {
      en: "./inlang/guides/use-paraglide-with-nextjs-app-router/use-paraglide-with-nextjs-app-router.md"
    },
    keywords: [
      "application",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "react",
      "build",
      "javascript",
      "ide",
      "guide",
      "next",
      "nextjs",
      "react",
      "app router",
      "server components",
      "server component",
      "RSC",
      "client component",
      "client components",
      "i18n routing",
      "guides-developer"
    ],
    recommends: ["g/uxohikde", "g/2fg8ng94", "g/00162hsd"],
    publisherName: "Loris Sigrist",
    publisherIcon: "https://avatars.githubusercontent.com/u/43482866?v=4",
    publisherLink: "https://github.com/LorisSigrist",
    license: "Apache-2.0"
  },
  {
    uniqueID: "uxohikde",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.lorissigrist.useParaglideJsWithNextjsPagesRouter",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/use-paraglide-with-nextjs-pages-router/pages-router-logo.png",
    displayName: {
      en: "Use ParaglideJS with the NextJS Pages Router"
    },
    description: {
      en: "This guide covers how to integrate ParaglideJS into a NextJS project using the pages router. It will cover i18n routing and SEO Pitfalls and more!"
    },
    readme: {
      en: "./inlang/guides/use-paraglide-with-nextjs-pages-router/use-paraglide-with-nextjs-pages-router.md"
    },
    keywords: [
      "application",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "react",
      "build",
      "javascript",
      "ide",
      "guide",
      "next",
      "nextjs",
      "react",
      "pages router",
      "i18n routing",
      "guides-developer"
    ],
    recommends: ["g/wxcebbig", "g/2fg8ng94", "g/00162hsd"],
    publisherName: "Loris Sigrist",
    publisherIcon: "https://avatars.githubusercontent.com/u/43482866?v=4",
    publisherLink: "https://github.com/LorisSigrist",
    license: "Apache-2.0"
  },
  {
    uniqueID: "3go4f04m",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.niklasbuchfink.whatIsInlang",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/what-is-inlang/question-mark-logo.webp",
    displayName: {
      en: "What is inlang?"
    },
    description: {
      en: "Understand general concept of inlang ecosystem and its benefits."
    },
    readme: {
      en: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/what-is-inlang/what-is-inlang.md"
    },
    keywords: [
      "application",
      "website",
      "developer",
      "translator",
      "inlang",
      "getting-started",
      "i18n",
      "localization",
      "guide",
      "guides-general"
    ],
    recommends: ["g/00162hsd", "g/6ddyhpoi", "g/38fnf03n"],
    publisherName: "Niklas Buchfink",
    publisherIcon: "https://avatars.githubusercontent.com/u/59048346?v=4",
    license: "Apache-2.0"
  },
  {
    uniqueID: "ssryldhd",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.automationSystem",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/translation-automation/assets/logo.png",
    displayName: {
      en: "Translation Automation"
    },
    description: {
      en: "How can you achieve continuous translation?"
    },
    readme: {
      en: "./inlang/guides/translation-automation/README.md"
    },
    keywords: [
      "i18n",
      "developer",
      "translator",
      "designer",
      "editor",
      "contribute",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "ecosystem",
      "compatible",
      "ecosystem compatible",
      "automation",
      "system",
      "cli",
      "ci/cd",
      "build",
      "test",
      "svelte",
      "astro",
      "guides-change-control"
    ],
    recommends: ["g/oostafhs", "g/38fnf03n", "g/940fn8mg", "g/3go4f04m"],
    publisherName: "Nils Jacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    publisherLink: "https://github.com/NilsJacobsen",
    license: "Apache-2.0"
  },
  {
    uniqueID: "2fg8ng94",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.buildAGlobalSvelteApp",
    icon: "https://avatars.githubusercontent.com/u/23617963?s=200&v=4",
    displayName: {
      en: "Build a Global Svelte App"
    },
    description: {
      en: "A complete guide on how to adopt inlang with paraglide.js and message-format-plugin"
    },
    readme: {
      en: "./inlang/guides/build-a-global-svelte-app/build-a-global-svelte-app.md"
    },
    keywords: [
      "libraries",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "svelte",
      "javascript",
      "ide",
      "guide",
      "guides-developer"
    ],
    recommends: ["g/3go4f04m", "g/00162hsd", "g/wxcebbig", "g/uxohikde"],
    publisherName: "Nils Jacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    publisherLink: "https://github.com/NilsJacobsen",
    license: "Apache-2.0"
  },
  {
    uniqueID: "6ddyhpoi",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.contributeTranslationsWithFink",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/contribute-translations-with-fink/bird-contribute.png?raw=true",
    displayName: {
      en: "Contribute Translations with Fink"
    },
    description: {
      en: "You can create or improve community translations through the Fink i18n editor."
    },
    readme: {
      en: "./inlang/guides/contribute-translations-with-fink/README.md"
    },
    keywords: [
      "i18n",
      "fink",
      "messages",
      "translations",
      "editor",
      "contribute",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "guides-translator"
    ],
    recommends: ["g/2fg8ng94", "g/00162hsd", "g/wxcebbig", "g/uxohikde"],
    publisherName: "Nils Jacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    publisherLink: "https://github.com/NilsJacobsen",
    license: "Apache-2.0"
  },
  {
    uniqueID: "7777asdy",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.ecosystemCompatible",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/ecosystem-compatible/assets/compatible-badge.png",
    displayName: {
      en: "inlang ecosystem compatible"
    },
    description: {
      en: "What does this term mean and why is the approach important?"
    },
    readme: {
      en: "./inlang/guides/ecosystem-compatible/README.md"
    },
    keywords: [
      "i18n",
      "developer",
      "translator",
      "designer",
      "editor",
      "contribute",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "ecosystem",
      "compatible",
      "ecosystem compatible",
      "astro",
      "nextjs",
      "remix",
      "svelte",
      "guides-general"
    ],
    recommends: ["g/2fg8ng94", "g/00162hsd", "g/wxcebbig", "g/uxohikde"],
    publisherName: "Nils Jacobsen",
    publisherLink: "https://github.com/NilsJacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    license: "Apache-2.0"
  },
  {
    uniqueID: "hhfueysj",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.nextIntlIdeExtension",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/next-intl-with-ide-extension/assets/iconv3.png",
    displayName: {
      en: "Setting Up next-intl with the Sherlock VS Code extension."
    },
    description: {
      en: "I'll walk you through the integration of the next-intl internationalization library with the Sherlock VS Code extension."
    },
    readme: {
      en: "./inlang/guides/next-intl-with-ide-extension/README.md"
    },
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/next-intl-with-ide-extension/assets/next-intl-guide.png"
    ],
    keywords: [
      "i18n",
      "developer",
      "translator",
      "designer",
      "editor",
      "contribute",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "ecosystem",
      "compatible",
      "ecosystem compatible",
      "next-intl",
      "vscode",
      "sherlock",
      "ide-extension",
      "guides-developer"
    ],
    recommends: ["g/2fg8ng94", "g/00162hsd", "g/wxcebbig", "g/uxohikde"],
    publisherName: "Nils Jacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    publisherLink: "https://github.com/NilsJacobsen",
    license: "Apache-2.0"
  },
  {
    uniqueID: "oostafhs",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.reviewSystem",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/translation-review-system/assets/logo.png",
    displayName: {
      en: "Translation Review System"
    },
    description: {
      en: "The aim of this system is to meet specific standards for translations."
    },
    readme: {
      en: "./inlang/guides/translation-review-system/README.md"
    },
    keywords: [
      "i18n",
      "developer",
      "translator",
      "designer",
      "editor",
      "contribute",
      "localization",
      "globalization",
      "internationalization",
      "guide",
      "ecosystem",
      "compatible",
      "ecosystem compatible",
      "review",
      "system",
      "svelte",
      "astro",
      "guides-change-control"
    ],
    recommends: ["g/ssryldhd", "g/38fnf03n", "g/940fn8mg", "g/3go4f04m"],
    publisherName: "Nils Jacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    publisherLink: "https://github.com/NilsJacobsen",
    license: "Apache-2.0"
  },
  {
    uniqueID: "00162hsd",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "guide.nilsjacobsen.whatArePlugins",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/what-are-plugins/electric-plug-logo.webp",
    displayName: {
      en: "What are Plugins?"
    },
    description: {
      en: "Discover the benefits of using plugins: freedom and low-cost adoption."
    },
    readme: {
      en: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/guides/what-are-plugins/what-are-plugins.md"
    },
    keywords: [
      "application",
      "website",
      "inlang",
      "getting-started",
      "guide",
      "plugins",
      "plugin",
      "svelte",
      "guides-developer"
    ],
    recommends: ["g/2fg8ng94", "g/00162hsd", "g/wxcebbig", "g/uxohikde"],
    publisherName: "Nils Jacobsen",
    publisherIcon: "https://avatars.githubusercontent.com/u/58360188?s=96&v=4",
    publisherLink: "https://github.com/NilsJacobsen",
    license: "Apache-2.0"
  },
  {
    uniqueID: "fnhuwzrx",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.brikev.remix-paraglidejs",
    slug: "paraglide-remix-i18n",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo/inlang/external-projects/remix-paraglidejs/assets/remix.svg",
    displayName: {
      en: "Remix-ParaglideJS"
    },
    description: {
      en: "Remix utils and examples to work with ParaglideJS"
    },
    readme: {
      en: "https://cdn.jsdelivr.net/gh/BRIKEV/remix-paraglidejs/README.md"
    },
    keywords: [
      "libraries",
      "remix",
      "remix-run",
      "react",
      "developer",
      "i18n",
      "inlang",
      "community"
    ],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g"],
    publisherName: "BRIKEV",
    publisherIcon: "https://avatars.githubusercontent.com/u/59850028?v=4",
    publisherLink: "https://github.com/BRIKEV",
    website: "https://github.com/BRIKEV/remix-paraglidejs",
    license: "MIT License",
    pricing: "Free"
  },
  {
    uniqueID: "8y8sxj09",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.languageTag",
    icon: "https://images.emojiterra.com/google/android-12l/512px/1f4db.png",
    displayName: {
      en: "Language Tag"
    },
    description: {
      en: "A library containing BCP-47 language tags types and validators, used by inlang."
    },
    pages: {
      "/": "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/versioned-interfaces/language-tag/README.md"
    },
    keywords: [
      "libraries",
      "website",
      "developer",
      "lang",
      "language tag",
      "bcp-47",
      "validator",
      "interface",
      "types",
      "typescript",
      "library",
      "unlisted"
    ],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "gerre34r",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.paraglideJs",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-js/assets/paraglideNoBg.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-js/assets/og.png",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/paraglide-gallery/paraglide-gallery-image-1.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/paraglide-gallery/paraglide-gallery-image-2.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/paraglide-gallery/paraglide-gallery-image-3.jpg",
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/paraglide-gallery/paraglide-gallery-image-4.jpg"
    ],
    displayName: {
      en: "Paraglide JS"
    },
    description: {
      en: "Simple, adaptable and tiny i18n library that integrates with any framework"
    },
    pages: {
      "": {
        "/": "./inlang/source-code/paraglide/paraglide-js/docs/why-paraglide.md",
        "/getting-started": "./inlang/source-code/paraglide/paraglide-js/README.md",
        "/usage": "./inlang/source-code/paraglide/paraglide-js/docs/usage.md",
        "/scaling": "./inlang/source-code/paraglide/paraglide-js/docs/scaling.md",
        "/architecture": "./inlang/source-code/paraglide/paraglide-js/docs/architecture.md",
        "/manual-setup": "./inlang/source-code/paraglide/paraglide-js/docs/manual-setup.md",
        "/changelog": "./inlang/source-code/paraglide/paraglide-js/CHANGELOG.md"
      },
      "Framework Libraries": {
        NextJS: "/m/osslbuzt/paraglide-next-i18n",
        SvelteKit: "/m/dxnzrydw/paraglide-sveltekit-i18n",
        Astro: "/m/iljlwzfs/paraglide-astro-i18n",
        SolidStart: "/m/n860p17j/paraglide-solidstart-i18n",
        Remix: "/m/fnhuwzrx/paraglide-remix-i18n",
        "/framework-libraries/build-your-own": "./inlang/source-code/paraglide/paraglide-js/docs/custom-framework-library.md"
      },
      Tooling: {
        "VsCode Extension": "/m/r7kp499g/app-inlang-ideExtension",
        "Machine Translation": "/m/2qj2w8pu/app-inlang-cli",
        "Translation Editor": "/m/tdozzpar/app-inlang-finkLocalizationEditor"
      }
    },
    keywords: [
      "paraglide js",
      "libraries",
      "apps",
      "website",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "svelte",
      "react",
      "nextjs",
      "remix",
      "vue",
      "astro",
      "javascript",
      "solid",
      "typescript",
      "inlang"
    ],
    recommends: ["m/reootnfj", "m/632iow21", "m/r7kp499g", "m/teldgniy"],
    pricing: "free",
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "iljlwzfs",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.paraglideJsAdapterAstro",
    slug: "paraglide-astro-i18n",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-astro/assets/icon.svg",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-astro/assets/og.png"
    ],
    displayName: {
      en: "Paraglide-Astro"
    },
    description: {
      en: "An Astro integration for ParaglideJS, providing you with everything you need to internationalize your Astro App"
    },
    pages: {
      "/": "./inlang/source-code/paraglide/paraglide-astro/README.md",
      "/changelog": "./inlang/source-code/paraglide/paraglide-astro/CHANGELOG.md"
    },
    keywords: [
      "paraglide js",
      "libraries",
      "website",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "astro",
      "astro integration",
      "islands",
      "vite",
      "javascript",
      "typescript",
      "inlang"
    ],
    recommends: ["m/reootnfj", "m/632iow21", "m/r7kp499g", "m/teldgniy"],
    pricing: "free",
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "osslbuzt",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.paraglideJsAdapterNextJs",
    slug: "paraglide-next-i18n",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-next/assets/next-logo.svg",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-next/assets/og.png"
    ],
    displayName: {
      en: "Paraglide-Next"
    },
    description: {
      en: "A NextJS integration for ParaglideJS, providing you with everything you need for i18n routing"
    },
    pages: {
      Setup: {
        "/": "./inlang/source-code/paraglide/paraglide-next/docs/why-paraglide-next.md",
        "/get-started": "./inlang/source-code/paraglide/paraglide-next/README.md"
      },
      "Localised Routing": {
        "/localized-routing/overview": "./inlang/source-code/paraglide/paraglide-next/docs/routing/overview.md",
        "/localized-routing/prefix-strategy": "./inlang/source-code/paraglide/paraglide-next/docs/routing/prefix-strategy.md",
        "/localized-routing/other-strategies": "./inlang/source-code/paraglide/paraglide-next/docs/routing/other-strategies.md"
      },
      "Advanced Usage": {
        "/advanced/seo": "./inlang/source-code/paraglide/paraglide-next/docs/advanced/seo.md",
        "/advanced/usage-on-the-server": "./inlang/source-code/paraglide/paraglide-next/docs/advanced/server.md"
      },
      Appendix: {
        "/pages-router": "./inlang/source-code/paraglide/paraglide-next/docs/pages-router.md",
        "/manual-setup": "./inlang/source-code/paraglide/paraglide-next/docs/manual-setup.md",
        "Vanilla ParaglideJS": "/m/gerre34r/library-inlang-paraglideJs",
        "/roadmap": "./inlang/source-code/paraglide/paraglide-next/docs/roadmap.md",
        "/changelog": "./inlang/source-code/paraglide/paraglide-next/CHANGELOG.md"
      }
    },
    keywords: [
      "paraglide js",
      "libraries",
      "website",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "next",
      "next-js",
      "react",
      "vercel",
      "vite",
      "javascript",
      "typescript",
      "inlang"
    ],
    recommends: ["m/reootnfj", "m/632iow21", "m/r7kp499g", "m/teldgniy"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0",
    pricing: "Free"
  },
  {
    uniqueID: "n860p17j",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.paraglideJsAdapterSolidStart",
    slug: "paraglide-solidstart-i18n",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-solidstart/assets/icon.png",
    displayName: {
      en: "Paraglide-SolidStart"
    },
    description: {
      en: "A SolidStart integration for ParaglideJS, providing you with everything you need to take your solid app global."
    },
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-solidstart/assets/og.png"
    ],
    pages: {
      "/": "./inlang/source-code/paraglide/paraglide-solidstart/README.md",
      "/changelog": "./inlang/source-code/paraglide/paraglide-solidstart/CHANGELOG.md"
    },
    keywords: [
      "paraglide js",
      "libraries",
      "website",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "solid",
      "solid-start",
      "javascript",
      "typescript",
      "inlang"
    ],
    recommends: ["m/reootnfj", "m/632iow21", "m/r7kp499g", "m/teldgniy"],
    pricing: "free",
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "dxnzrydw",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.paraglideJsAdapterSvelteKit",
    slug: "paraglide-sveltekit-i18n",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-sveltekit/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/source-code/paraglide/paraglide-sveltekit/assets/og.png"
    ],
    displayName: {
      en: "Paraglide-SvelteKit"
    },
    description: {
      en: "A SvelteKit integration for ParaglideJS, providing you with everything you need for i18n routing"
    },
    pages: {
      "": {
        "/": "./inlang/source-code/paraglide/paraglide-sveltekit/docs/why-paraglide.md",
        "/getting-started": "./inlang/source-code/paraglide/paraglide-sveltekit/README.md",
        "/localised-routing": "./inlang/source-code/paraglide/paraglide-sveltekit/docs/localised-routing.md",
        "/advanced-usage": "./inlang/source-code/paraglide/paraglide-sveltekit/docs/advanced-usage.md",
        "/deployment": "./inlang/source-code/paraglide/paraglide-sveltekit/docs/deployment.md"
      },
      Appendix: {
        "/manual-setup": "./inlang/source-code/paraglide/paraglide-sveltekit/docs/manual-setup.md",
        "/roadmap-and-caveats": "./inlang/source-code/paraglide/paraglide-sveltekit/docs/roadmap.md",
        "/changelog": "./inlang/source-code/paraglide/paraglide-sveltekit/CHANGELOG.md",
        StackBlitz: "https://stackblitz.com/~/github.com/lorissigrist/paraglide-sveltekit-example"
      }
    },
    keywords: [
      "paraglide js",
      "libraries",
      "website",
      "developer",
      "paraglide",
      "i18n",
      "library",
      "localization",
      "sdk",
      "sdk-js",
      "svelte",
      "sveltekit",
      "vite",
      "javascript",
      "typescript",
      "inlang"
    ],
    recommends: ["m/reootnfj", "m/632iow21", "m/r7kp499g", "m/teldgniy"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0",
    pricing: "Free"
  },
  {
    uniqueID: "ezdlll4o",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "library.inlang.translatable",
    icon: "https://images.emojiterra.com/google/noto-emoji/unicode-15/color/svg/1f310.svg",
    displayName: {
      en: "Translatable"
    },
    description: {
      en: "This library allows you to add translation logic to your application without having to rewrite large parts."
    },
    pages: {
      "/": "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/versioned-interfaces/translatable/README.md"
    },
    keywords: [
      "libraries",
      "website",
      "developer",
      "translatable",
      "adoptable",
      "interface",
      "types",
      "typescript",
      "library",
      "unlisted"
    ],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0"
  },
  {
    uniqueID: "ewkole66",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.camelCaseId",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/camelCaseId/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/camel_case_id-cover.jpg"
    ],
    displayName: {
      en: "Camel case id"
    },
    description: {
      en: "Checks for messages to have a camel case formatted message id (e.g. 'myMessage')."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/camelCaseId/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/camelCaseId/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "id", "format", "camel", "case", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.camelCaseId",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-camel-case-id@latest/dist/index.js"
  },
  {
    uniqueID: "y0eo8f66",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.emptyPattern",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/emptyPattern/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/empty_pattern-marketplace-cover.jpg"
    ],
    displayName: {
      en: "Empty pattern"
    },
    description: {
      en: "Checks for empty pattern in a language tag. If a message exists in the reference resource but the pattern in a target resource is empty, it is likely that the message has not been translated yet."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/emptyPattern/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/emptyPattern/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "empty pattern", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.emptyPattern",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@latest/dist/index.js"
  },
  {
    uniqueID: "asvuch18",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.identicalPattern",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/identicalPattern/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/identical_pattern-marketplace-cover.jpg"
    ],
    displayName: {
      en: "Identical pattern"
    },
    description: {
      en: "Checks for identical patterns in different languages.  A message with identical wording in multiple languages can indicate that the translations are redundant or can be combined into a single message to reduce translation effort."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/identicalPattern/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/identicalPattern/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "itentical pattern", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.identicalPattern",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-identical-pattern@latest/dist/index.js"
  },
  {
    uniqueID: "10l6oyv1",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.messageWithoutSource",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/messageWithoutSource/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/without_source-marketplace-cover.jpg"
    ],
    displayName: {
      en: "Message without source"
    },
    description: {
      en: "Checks for likely outdated messages.  A message with a missing source is usually an indication that the message (id) is no longer used in source code, but messages have not been updated accordingly."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/messageWithoutSource/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/messageWithoutSource/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "source", "missing", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.messageWithoutSource",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@latest/dist/index.js"
  },
  {
    uniqueID: "4cxm3eqi",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.missingTranslation",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/missingTranslation/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/missing_translation-marketplace-cover.jpg"
    ],
    displayName: {
      en: "Missing translation"
    },
    description: {
      en: "Checks for missing variants for a specific languageTag.  If a variant exists for the sourceLanguageTag but is missing for a listed languageTag, it is likely that the message has not been translated for this languageTag yet."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/missingTranslation/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/missingTranslation/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "missing", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.missingTranslation",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@latest/dist/index.js"
  },
  {
    uniqueID: "gkerinvo",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.snakeCaseId",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/snakeCaseId/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/snake_case_id-cover.jpg"
    ],
    displayName: {
      en: "Snake case id"
    },
    description: {
      en: "Checks for messages to have a snake case formatted message id (e.g. 'my_message_id')."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/snakeCaseId/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/snakeCaseId/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "id", "format", "snake", "case", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.snakeCaseId",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-snake-case-id@latest/dist/index.js"
  },
  {
    uniqueID: "teldgniy",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "messageLintRule.inlang.validJsIdentifier",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/message-lint-rules/validJsIdentifier/assets/icon.png",
    gallery: [
      "https://cdn.jsdelivr.net/gh/opral/monorepo@latest/inlang/assets/marketplace/valid_js_identifier_id.jpg"
    ],
    displayName: {
      en: "Valid JS Identifier"
    },
    description: {
      en: "Make sure that all message IDs are valid JavaScript identifiers."
    },
    pages: {
      "/": "./inlang/source-code/message-lint-rules/validJsIdentifier/README.md",
      "/changelog": "./inlang/source-code/message-lint-rules/validJsIdentifier/CHANGELOG.md"
    },
    keywords: ["message", "lint rule", "javascript", "paraglide", "website"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=messageLintRule.inlang.validJsIdentifier",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-valid-js-identifier@latest/dist/index.js"
  },
  {
    uniqueID: "neh2d6w7",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    displayName: {
      en: "Xcode String Catalogs"
    },
    publisherIcon: "https://hechenbros.com/favicon.png",
    publisherLink: "https://hechenbros.com",
    id: "plugin.hechenbros.xcstrings",
    description: {
      en: "An inlang plugin to handle Xcode String Catalogs"
    },
    keywords: ["inlang", "plugin", "xcstrings", "xcode", "translation", "ios", "mac"],
    license: "MIT",
    module: "https://cdn.jsdelivr.net/npm/inlang-plugin-xcstrings@latest/out/index.js",
    readme: "https://cdn.jsdelivr.net/npm/inlang-plugin-xcstrings@latest/README.md",
    pages: {
      "/": "https://cdn.jsdelivr.net/npm/inlang-plugin-xcstrings@latest/README.md",
      "/changelog": "https://cdn.jsdelivr.net/npm/inlang-plugin-xcstrings@latest/CHANGELOG.md"
    },
    publisherName: "Hechenbros"
  },
  {
    uniqueID: "3i8bor92",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.i18next",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/plugins/i18next/assets/icon.png",
    displayName: {
      en: "i18next"
    },
    description: {
      en: "A plugin for inlang projects that works with i18next and reads + writes resources."
    },
    pages: {
      "/": "./inlang/source-code/plugins/i18next/README.md",
      "/changelog": "./inlang/source-code/plugins/i18next/CHANGELOG.md"
    },
    keywords: [
      "i18next",
      "javascript",
      "react",
      "nextjs",
      "website",
      "load",
      "save",
      "import",
      "export",
      "messages",
      "plugin",
      "svelte",
      "solid",
      "astro"
    ],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g", "m/gerre34r"],
    publisherName: "inlang",
    website: "https://manage.inlang.com/install?module=plugin.inlang.i18next",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@latest/dist/index.js"
  },
  {
    uniqueID: "ig84ng0o",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.json",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/plugins/json/assets/icon.png",
    displayName: {
      en: "JSON translation files"
    },
    description: {
      en: "This plugin enables using JSON files for messages. It is not library specific and can be used with any framework."
    },
    pages: {
      "/": "./inlang/source-code/plugins/json/README.md",
      "/changelog": "./inlang/source-code/plugins/json/CHANGELOG.md"
    },
    keywords: [
      "json",
      "flutter",
      "generic",
      "website",
      "javascript",
      "load",
      "save",
      "import",
      "export",
      "messages",
      "plugin",
      "svelte",
      "nextjs",
      "solid",
      "astro"
    ],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g", "m/gerre34r"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=plugin.inlang.json",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-json@latest/dist/index.js"
  },
  {
    uniqueID: "reootnfj",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.messageFormat",
    displayName: {
      en: "inlang message format"
    },
    description: {
      en: "The simplest storage plugin for inlang."
    },
    pages: {
      "/": "./inlang/source-code/plugins/inlang-message-format/README.md",
      "/changelog": "./inlang/source-code/plugins/inlang-message-format/CHANGELOG.md"
    },
    keywords: [
      "website",
      "svelte",
      "react",
      "nextjs",
      "vue",
      "javascript",
      "storage",
      "save",
      "load",
      "import",
      "export",
      "messages",
      "plugin",
      "solid",
      "astro"
    ],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g", "m/gerre34r"],
    publisherName: "inlang",
    website: "https://manage.inlang.com/install?module=plugin.inlang.messageFormat",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@latest/dist/index.js"
  },
  {
    uniqueID: "632iow21",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.mFunctionMatcher",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/plugins/m-function-matcher/assets/m.png",
    displayName: {
      en: "m-function-matcher"
    },
    description: {
      en: "Enables the inlang Visual Studio Code extension (Sherlock) to work with paraglide"
    },
    pages: {
      "/": "./inlang/source-code/plugins/m-function-matcher/README.md",
      "/changelog": "./inlang/source-code/plugins/m-function-matcher/CHANGELOG.md"
    },
    keywords: [
      "website",
      "vscode",
      "react",
      "nextjs",
      "sveltekit",
      "svelte",
      "vue",
      "plugin",
      "solid",
      "astro"
    ],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g", "m/gerre34r"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=plugin.inlang.mFunctionMatcher",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@latest/dist/index.js"
  },
  {
    uniqueID: "193hsyds",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.nextIntl",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/plugins/next-intl/assets/plugin-next-intl-logo.png",
    displayName: {
      en: "next-intl plugin"
    },
    description: {
      en: "A plugin to make next-intl ecosystem compatible with inlang"
    },
    pages: {
      "/": "./inlang/source-code/plugins/next-intl/README.md",
      "/changelog": "./inlang/source-code/plugins/next-intl/CHANGELOG.md"
    },
    keywords: [
      "next-intl",
      "javascript",
      "react",
      "nextjs",
      "website",
      "load",
      "save",
      "import",
      "export",
      "messages",
      "plugin"
    ],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g", "m/gerre34r"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=plugin.inlang.nextIntl",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-next-intl@latest/dist/index.js"
  },
  {
    uniqueID: "wrh36dfb",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.sapUI5",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/plugins/sap-ui5/assets/icon.png",
    displayName: {
      en: "SAP UI5 plugin"
    },
    description: {
      en: "Enables the inlang Visual Studio Code extension (Sherlock) to work with SAP UI5"
    },
    pages: {
      "/": "./inlang/source-code/plugins/sap-ui5/README.md",
      "/changelog": "./inlang/source-code/plugins/sap-ui5/CHANGELOG.md"
    },
    keywords: ["website", "vscode", "sap", "sapui5", "plugin"],
    recommends: ["m/tdozzpar", "m/2qj2w8pu", "m/r7kp499g", "m/gerre34r"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=plugin.inlang.sapUI5",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-sap-ui5@latest/dist/index.js"
  },
  {
    uniqueID: "698iow33",
    $schema: "https://inlang.com/schema/marketplace-manifest",
    id: "plugin.inlang.tFunctionMatcher",
    icon: "https://cdn.jsdelivr.net/gh/opral/monorepo@main/inlang/source-code/plugins/t-function-matcher/assets/t.png",
    displayName: {
      en: "t-function-matcher"
    },
    description: {
      en: "Enables the inlang Visual Studio Code extension (Sherlock) to work with t-functions"
    },
    pages: {
      "/": "./inlang/source-code/plugins/t-function-matcher/README.md",
      "/changelog": "./inlang/source-code/plugins/t-function-matcher/CHANGELOG.md"
    },
    keywords: [
      "website",
      "vscode",
      "react",
      "nextjs",
      "sveltekit",
      "svelte",
      "vue",
      "plugin",
      "solid",
      "astro"
    ],
    recommends: ["m/r7kp499g", "m/3i8bor92"],
    publisherName: "inlang",
    publisherIcon: "https://inlang.com/favicon/safari-pinned-tab.svg",
    website: "https://manage.inlang.com/install?module=plugin.inlang.tFunctionMatcher",
    license: "Apache-2.0",
    module: "https://cdn.jsdelivr.net/npm/@inlang/plugin-t-function-matcher@latest/dist/index.js"
  }
];

// src/stories/field-header.ts
var FieldHeader = class extends h3 {
  constructor() {
    super(...arguments);
    this.optional = false;
  }
  render() {
    return ke` <div class="header">
			${this.fieldTitle && ke`<h3 part="property-title">
				${this.fieldTitle}${this.optional ? ke`<span class="optinal">${" (optional)"}</span>` : ""}
			</h3>`}
			${this.description && ke`<p part="property-paragraph" class="help-text">${this.description}</p>`}
			${this.examples ? ke`<div class="example-container">
						<p class="help-text">Examples:</p>
						${this.examples.map((example) => ke`<p class="example">${example}</p>`)}
				  </div>` : ``}
		</div>`;
  }
};
FieldHeader.styles = [
  //baseStyling,
  i`
			.header {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
			h3 {
				margin: 0;
				font-size: 14px;
				font-weight: 800;
				line-height: 1.5;
			}
			.help-text {
				font-size: 14px;
				color: var(--sl-input-help-text-color);
				margin: 0;
				line-height: 1.5;
			}
			.optinal {
				font-size: 14px;
				font-style: italic;
				font-weight: 500;
				color: var(--sl-input-help-text-color);
			}
			.example-container {
				display: flex;
				flex-wrap: wrap;
				gap: 4px;
			}
			.example {
				background-color: var(--sl-input-background-color-disabled);
				width: fit-content;
				padding: 0px 6px;
				border-radius: 2px;
				font-size: 14px;
				display: flex;
				align-items: center;
				justify-content: center;
				color: var(--sl-input-color-disabled);
				margin: 0;
				line-height: 1.5;
			}
		`
];
__decorateClass([
  n4()
], FieldHeader.prototype, "fieldTitle", 2);
__decorateClass([
  n4()
], FieldHeader.prototype, "description", 2);
__decorateClass([
  n4({ type: Array })
], FieldHeader.prototype, "examples", 2);
__decorateClass([
  n4({ type: Boolean })
], FieldHeader.prototype, "optional", 2);
FieldHeader = __decorateClass([
  t2("field-header")
], FieldHeader);

// src/stories/input-fields/string/string-input.ts
var StringInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = "";
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _examples() {
    return this.schema.examples;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  render() {
    return ke` <div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.examples=${this._examples}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			<sl-input
				value=${this.value}
				size="small"
				@input=${(e6) => {
      this.handleInlangProjectChange(
        e6.target.value,
        this.property,
        this.moduleId
      );
    }}
			>
			</sl-input>
		</div>`;
  }
};
StringInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			h3 {
				margin: 0;
				font-size: 14px;
				font-weight: 800;
			}
			.help-text {
				font-size: 14px;
				color: var(--sl-input-help-text-color);
				margin: 0;
				line-height: 1.5;
			}
			.description-container {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
		`
];
__decorateClass([
  n4()
], StringInput.prototype, "property", 2);
__decorateClass([
  n4()
], StringInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], StringInput.prototype, "value", 2);
__decorateClass([
  n4()
], StringInput.prototype, "schema", 2);
__decorateClass([
  n4()
], StringInput.prototype, "required", 2);
__decorateClass([
  n4()
], StringInput.prototype, "handleInlangProjectChange", 2);
StringInput = __decorateClass([
  t2("string-input")
], StringInput);

// src/stories/input-fields/array/default-array-input.ts
var DefaultArrayInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._inputValue = void 0;
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  handleInputChange(e6) {
    const inputElement = e6.target;
    this._inputValue = inputElement.value;
  }
  handleAddItemClick() {
    if (this._inputValue && this._inputValue.trim() !== "") {
      this.value ? this.value.push(this._inputValue) : this.value = [this._inputValue];
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  handleDeleteItemClick(index2) {
    if (this.value) {
      this.value.splice(index2, 1);
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  render() {
    return ke`<div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			${this.value && this.value.length > 0 ? ke`<div class="item-container">
						${this.value.map((arrayItem, index2) => {
      return ke`<sl-input
								class="disabled-input"
								size="small"
								value=${arrayItem}
								disabled
								filled
							>
								<div
									slot="suffix"
									class="icon-wrapper"
									@click=${() => {
        this.handleDeleteItemClick(index2);
      }}
								>
									<svg class="icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
										<path
											xmlns="http://www.w3.org/2000/svg"
											d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"
										/>
									</svg>
								</div>
							</sl-input>`;
    })}
				  </div>` : void 0}
			<div class="new-line-container">
				<sl-input
					class="add-input"
					size="small"
					placeholder="Add new item"
					@input=${(e6) => this.handleInputChange(e6)}
					@keydown=${(e6) => {
      if (e6.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputValue}
				>
				</sl-input>
				<sl-button
					exportparts="base:button"
					size="small"
					variant="neutral"
					@click=${() => {
      this.handleAddItemClick();
    }}
				>
					Add
				</sl-button>
			</div>
		</div>`;
  }
};
DefaultArrayInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.item-container {
				display: flex;
				flex-direction: column;
				gap: 4px;
				padding-bottom: 8px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input {
				flex-grow: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.new-line-container {
				display: flex;
				gap: 4px;
			}
			.icon-wrapper {
				display: flex;
			}
		`
];
__decorateClass([
  n4()
], DefaultArrayInput.prototype, "property", 2);
__decorateClass([
  n4()
], DefaultArrayInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], DefaultArrayInput.prototype, "value", 2);
__decorateClass([
  n4()
], DefaultArrayInput.prototype, "schema", 2);
__decorateClass([
  n4()
], DefaultArrayInput.prototype, "required", 2);
__decorateClass([
  n4()
], DefaultArrayInput.prototype, "handleInlangProjectChange", 2);
__decorateClass([
  r4()
], DefaultArrayInput.prototype, "_inputValue", 2);
DefaultArrayInput = __decorateClass([
  t2("default-array-input")
], DefaultArrayInput);

// src/stories/input-fields/array/languageTags-input.ts
var LanguageTagsInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._inputValue = void 0;
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  handleInputChange(e6) {
    const inputElement = e6.target;
    this._inputValue = inputElement.value;
  }
  handleAddItemClick() {
    if (this._inputValue && this._inputValue.trim() !== "") {
      this.value ? this.value.push(this._inputValue) : this.value = [this._inputValue];
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  handleDeleteItemClick(index2) {
    if (this.value) {
      this.value.splice(index2, 1);
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
    }
  }
  render() {
    return ke`<div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			<div class="tags-container">
				${this.value && this.value.map((arrayItem, index2) => {
      return ke`
						<sl-tag
							@sl-remove=${() => {
        this.handleDeleteItemClick(index2);
      }}
							removable
							size="small"
							>${arrayItem}</sl-tag
						>
					`;
    })}
			</div>
			<div class="new-line-container">
				<sl-input
					class="add-input"
					size="small"
					placeholder="Enter languageTag ..."
					@input=${(e6) => this.handleInputChange(e6)}
					@keydown=${(e6) => {
      if (e6.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputValue}
				>
				</sl-input>
				<sl-button
					exportparts="base:button"
					size="small"
					variant="neutral"
					@click=${() => {
      this.handleAddItemClick();
    }}
				>
					Add
				</sl-button>
			</div>
		</div>`;
  }
};
LanguageTagsInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.tags-container {
				display: flex;
				flex-wrap: wrap;
				gap: 4px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input {
				flex-grow: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.new-line-container {
				display: flex;
				gap: 4px;
			}
			sl-tag::part(base) {
				background-color: var(--sl-input-filled-background-color-disabled);
				color: var(--sl-input-color);
				border-color: transparent;
				border-radius: var(--sl-input-border-radius-small);
			}
			sl-tag::part(remove-button) {
				color: var(--sl-input-placeholder-color);
			}
			sl-tag::part(remove-button):hover {
				color: var(--sl-input-color);
			}
		`
];
__decorateClass([
  n4()
], LanguageTagsInput.prototype, "property", 2);
__decorateClass([
  n4()
], LanguageTagsInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], LanguageTagsInput.prototype, "value", 2);
__decorateClass([
  n4()
], LanguageTagsInput.prototype, "schema", 2);
__decorateClass([
  n4()
], LanguageTagsInput.prototype, "required", 2);
__decorateClass([
  n4()
], LanguageTagsInput.prototype, "handleInlangProjectChange", 2);
__decorateClass([
  r4()
], LanguageTagsInput.prototype, "_inputValue", 2);
LanguageTagsInput = __decorateClass([
  t2("language-tags-input")
], LanguageTagsInput);

// src/stories/input-fields/array/reference-pattern-input.ts
var ReferencePatternInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  get _examples() {
    return this.schema.examples;
  }
  render() {
    return ke`<div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.description=${this._description}
				.examples=${this._examples}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			<div class="new-line-container">
				<sl-input
					class="add-input"
					size="small"
					label="Opening pattern"
					placeholder="Enter pattern ..."
					value=${this.value ? this.value[0] : ""}
					@input=${(e6) => {
      if (this.value === void 0)
        this.value = [];
      this.value[0] = e6.target.value;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
    }}
				>
				</sl-input>
				<sl-input
					class="add-input"
					size="small"
					label="Closing pattern"
					placeholder="Enter pattern ..."
					?disabled=${!this.value}
					value=${this.value ? this.value[1] : ""}
					@input=${(e6) => {
      if (this.value === void 0)
        this.value = [];
      this.value[1] = e6.target.value;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
    }}
				>
				</sl-input>
			</div>
		</div>`;
  }
};
ReferencePatternInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input::part(form-control-label) {
				color: var(--sl-input-help-text-color);
				font-size: 0.8rem;
				padding-left: 0.2rem;
				padding-bottom: 0.2rem;
			}
			.add-input {
				flex-grow: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.new-line-container {
				display: flex;
				gap: 4px;
			}
			sl-input::part(input) {
				width: inherit;
			}
		`
];
__decorateClass([
  n4()
], ReferencePatternInput.prototype, "property", 2);
__decorateClass([
  n4()
], ReferencePatternInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], ReferencePatternInput.prototype, "value", 2);
__decorateClass([
  n4()
], ReferencePatternInput.prototype, "schema", 2);
__decorateClass([
  n4()
], ReferencePatternInput.prototype, "required", 2);
__decorateClass([
  n4()
], ReferencePatternInput.prototype, "handleInlangProjectChange", 2);
ReferencePatternInput = __decorateClass([
  t2("reference-pattern-input")
], ReferencePatternInput);

// src/stories/input-fields/array/array-input.ts
var ArrayInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = [];
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  render() {
    const schemaPattern = this.schema.items.pattern;
    if (schemaPattern && schemaPattern === "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$") {
      return ke`
				<language-tags-input
					exportparts="property, property-title, property-paragraph, button"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></language-tags-input>
			`;
    } else if (this.property === "variableReferencePattern") {
      return ke`
				<reference-pattern-input
					exportparts="property, property-title, property-paragraph"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></reference-pattern-input>
			`;
    } else {
      return ke`
				<default-array-input
					exportparts="property, property-title, property-paragraph, button"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></default-array-input>
			`;
    }
  }
};
__decorateClass([
  n4()
], ArrayInput.prototype, "property", 2);
__decorateClass([
  n4()
], ArrayInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], ArrayInput.prototype, "value", 2);
__decorateClass([
  n4()
], ArrayInput.prototype, "schema", 2);
__decorateClass([
  n4()
], ArrayInput.prototype, "required", 2);
__decorateClass([
  n4()
], ArrayInput.prototype, "handleInlangProjectChange", 2);
ArrayInput = __decorateClass([
  t2("array-input")
], ArrayInput);

// src/stories/input-fields/object/default-object-input.ts
var DefaultObjectInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.keyPlaceholder = "Enter key";
    this.valuePlaceholder = "Enter value";
    this.value = {};
    this.schema = {};
    this.withTitle = true;
    this.withDescription = true;
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._inputValue = void 0;
    this._inputKey = void 0;
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  handleAddItemClick() {
    if (this._inputValue && this._inputKey && this._inputValue.trim() !== "" && this._inputKey.trim() !== "") {
      if (!this.value) {
        this.value = {};
      }
      this.value[this._inputKey] = this._inputValue;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
      this._inputKey = "null";
      this._inputKey = void 0;
    }
  }
  handleDeleteItemClick(key) {
    if (this.value) {
      delete this.value[key];
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
      this._inputValue = "null";
      this._inputValue = void 0;
      this._inputKey = "null";
      this._inputKey = void 0;
    }
  }
  render() {
    return ke` <div part="property" class="property">
			<field-header
				.fieldTitle=${this.withTitle ? this._title ? this._title : this.property : void 0}
				.description=${this.withDescription ? this._description : ``}
				.optional=${this.required ? false : true}
				exportparts="property-title, property-paragraph"
			></field-header>
			${this.value ? ke`<div class="list-container">
						${this.value && Object.entries(this.value).map(([key, value]) => {
      return ke`<div class="add-item-container">
								<sl-input
									class="disabled-input add-item-side"
									size="small"
									value=${key}
									disabled
									filled
								>
								</sl-input>
								<sl-input
									class="disabled-input add-item-side"
									size="small"
									value=${value}
									disabled
									filled
								>
								</sl-input>
								<div class="remove-icon">
									<div
										@click=${() => {
        this.handleDeleteItemClick(key);
      }}
									>
										<svg
											class="icon"
											width="16"
											height="16"
											fill="currentColor"
											viewBox="0 0 16 16"
										>
											<path
												xmlns="http://www.w3.org/2000/svg"
												d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"
											/>
										</svg>
									</div>
								</div>
							</div>`;
    })}
				  </div>` : ``}
			<div class="add-item-container">
				<sl-input
					class="add-item-side"
					placeholder=${this.keyPlaceholder}
					size="small"
					@input=${(e6) => {
      this._inputKey = e6.target.value;
    }}
					@keydown=${(e6) => {
      if (e6.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputKey}
				>
				</sl-input>
				<sl-input
					class="add-item-side"
					placeholder=${this.valuePlaceholder}
					size="small"
					@input=${(e6) => {
      this._inputValue = e6.target.value;
    }}
					@keydown=${(e6) => {
      if (e6.key === "Enter") {
        this.handleAddItemClick();
      }
    }}
					value=${this._inputValue}
				>
				</sl-input>
				<sl-button
					exportparts="base:button"
					size="small"
					variant="neutral"
					@click=${() => {
      this.handleAddItemClick();
    }}
				>
					Add
				</sl-button>
			</div>
		</div>`;
  }
};
DefaultObjectInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.disabled-input::part(base) {
				cursor: unset;
				opacity: 1;
			}
			.disabled-input::part(suffix) {
				cursor: pointer;
				opacity: 0.5;
			}
			.disabled-input::part(suffix):hover {
				opacity: 1;
			}
			.add-input::part(suffix) {
				cursor: pointer;
			}
			.add-item-container {
				display: flex;
				align-items: center;
				gap: 4px;
			}
			.add-item-side {
				flex-grow: 1;
			}
			.remove-icon {
				width: 44px;
				display: flex;
				justify-content: flex-start;
				margin-left: 6px;
				cursor: pointer;
				color: var(--sl-input-placeholder-color);
			}
			.remove-icon:hover {
				color: var(--sl-input-color);
			}
			.list-container {
				display: flex;
				flex-direction: column;
				gap: 3px;
				padding-bottom: 8px;
			}
			.icon {
				padding-top: 0.5rem;
			}
			sl-input::part(input) {
				width: inherit;
			}
		`
];
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "property", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "keyPlaceholder", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "valuePlaceholder", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "value", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "schema", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "withTitle", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "withDescription", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "required", 2);
__decorateClass([
  n4()
], DefaultObjectInput.prototype, "handleInlangProjectChange", 2);
__decorateClass([
  r4()
], DefaultObjectInput.prototype, "_inputValue", 2);
__decorateClass([
  r4()
], DefaultObjectInput.prototype, "_inputKey", 2);
DefaultObjectInput = __decorateClass([
  t2("default-object-input")
], DefaultObjectInput);

// src/stories/input-fields/object/lint-rule-level-object-input.ts
var LintRuleLevelObjectInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = {};
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  get _description() {
    return this.schema.description || void 0;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  get _valueOptions() {
    const valuesOptions = Object.values(this.schema.patternProperties)[0]?.anyOf;
    return valuesOptions ? valuesOptions : void 0;
  }
  handleUpdate(key, value) {
    if (key && value) {
      if (!this.value) {
        this.value = {};
      }
      this.value[key] = value;
      this.handleInlangProjectChange(this.value, this.property, this.moduleId);
    }
  }
  async update(changedProperties) {
    super.update(changedProperties);
    if (changedProperties.has("value")) {
      await this.updateComplete;
      const newValue = changedProperties.get("value");
      if (newValue) {
        for (const moduleId of Object.keys(newValue)) {
          const slSelect = this.shadowRoot?.getElementById(moduleId);
          if (slSelect) {
            const input = slSelect.shadowRoot?.querySelector(".select__display-input");
            if (input && input.value) {
              input.value = this.value[moduleId] ? this.value[moduleId] : "warning";
            }
          }
        }
      }
    }
  }
  render() {
    return this.modules && this.modules.some((module) => module.id.split(".")[0] !== "plugin") ? ke` <div part="property" class="property">
					<div class="title-container">
						<field-header
							.fieldTitle=${this._title ? this._title : this.property}
							.description=${this._description}
							.optional=${this.required ? false : true}
							exportparts="property-title, property-paragraph"
						></field-header>
					</div>
					<div class="container">
						${this.modules && this.modules.map((module) => {
      return module.id.split(".")[0] !== "plugin" ? ke`<div class="rule-container">
										<sl-select
											id=${module.id}
											exportparts="listbox:option-wrapper"
											value=${this.value ? this.value[module.id] : "warning"}
											placeholder="warning"
											class="select"
											size="small"
											@sl-change=${(e6) => {
        this.handleUpdate(
          module.id,
          e6.target.value
        );
      }}
										>
											${this.value[module.id] === "error" ? ke`<svg
														class="level-icon danger"
														slot="prefix"
														width="20"
														height="20"
														viewBox="0 0 24 24"
												  >
														<path
															fill="currentColor"
															d="M12 17q.425 0 .713-.288T13 16t-.288-.712T12 15t-.712.288T11 16t.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7t-.712.288T11 8v4q0 .425.288.713T12 13m0 9q-2.075 0-3.9-.788t-3.175-2.137T2.788 15.9T2 12t.788-3.9t2.137-3.175T8.1 2.788T12 2t3.9.788t3.175 2.137T21.213 8.1T22 12t-.788 3.9t-2.137 3.175t-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12t-2.325-5.675T12 4T6.325 6.325T4 12t2.325 5.675T12 20m0-8"
														/>
												  </svg>` : ke`<svg
														class="level-icon"
														slot="prefix"
														width="20"
														height="20"
														viewBox="0 0 24 24"
												  >
														<path
															fill="currentColor"
															d="M12 17q.425 0 .713-.288T13 16t-.288-.712T12 15t-.712.288T11 16t.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7t-.712.288T11 8v4q0 .425.288.713T12 13m0 9q-2.075 0-3.9-.788t-3.175-2.137T2.788 15.9T2 12t.788-3.9t2.137-3.175T8.1 2.788T12 2t3.9.788t3.175 2.137T21.213 8.1T22 12t-.788 3.9t-2.137 3.175t-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12t-2.325-5.675T12 4T6.325 6.325T4 12t2.325 5.675T12 20m0-8"
														/>
												  </svg>`}
											${this._valueOptions?.map((option) => {
        return ke`<sl-option
													exportparts="base:option"
													value=${option.const}
													class="add-item-side"
												>
													${option.const}
												</sl-option>`;
      })}
										</sl-select>
										<p class="ruleId">${module.displayName.en}</p>
								  </div>` : void 0;
    })}
					</div>
			  </div>` : void 0;
  }
};
LintRuleLevelObjectInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			.container {
				display: flex;
				flex-direction: column;
				padding-top: 8px;
				gap: 12px;
			}
			.ruleId {
				font-size: 0.8rem;
				margin: 0;
				color: var(--sl-input-color);
			}
			.rule-container {
				display: flex;
				align-items: center;
				gap: 12px;
				flex-wrap: wrap;
			}
			.select {
				max-width: 140px;
				min-width: 100px;
			}
			.title-container {
				display: flex;
				gap: 8px;
			}
			sl-select::part(expand-icon) {
				color: var(--sl-input-placeholder-color);
			}
			sl-select::part(expand-icon):hover {
				color: var(--sl-input-color);
			}
			sl-select::part(base):hover {
				border: var(--sl-input-placeholder-color);
			}
			.level-icon {
				color: var(--sl-color-neutral-400);
				margin-top: 1px;
				margin-right: 6px;
			}
			.level-icon.danger {
				color: var(--sl-color-danger-600);
			}
		`
];
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "property", 2);
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "modules", 2);
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "value", 2);
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "schema", 2);
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "required", 2);
__decorateClass([
  n4()
], LintRuleLevelObjectInput.prototype, "handleInlangProjectChange", 2);
LintRuleLevelObjectInput = __decorateClass([
  t2("lint-rule-level-object-input")
], LintRuleLevelObjectInput);

// src/stories/input-fields/object/object-input.ts
var ObjectInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = {};
    this.schema = {};
    this.withTitle = true;
    this.withDescription = true;
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
  }
  render() {
    if (this.property === "messageLintRuleLevels") {
      return ke`<lint-rule-level-object-input
				exportparts="property, property-title, property-paragraph, option, option-wrapper"
				.property=${this.property}
				.moduleId=${this.moduleId}
				.modules=${this.modules}
				.value=${this.value}
				.schema=${this.schema}
				.handleInlangProjectChange=${this.handleInlangProjectChange}
				.required=${this.required}
			></lint-rule-level-object-input>`;
    } else {
      return ke`<default-object-input
				exportparts="property, property-title, property-paragraph, button"
				.property=${this.property}
				.moduleId=${this.moduleId}
				.value=${this.value}
				.schema=${this.schema}
				.keyPlaceholder=${this.keyPlaceholder}
				.valuePlaceholder=${this.valuePlaceholder}
				.handleInlangProjectChange=${this.handleInlangProjectChange}
				.withTitle=${this.withTitle}
				.withDescription=${this.withDescription}
				.required=${this.required}
			></default-object-input>`;
    }
  }
};
__decorateClass([
  n4()
], ObjectInput.prototype, "property", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "modules", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "keyPlaceholder", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "valuePlaceholder", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "value", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "schema", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "withTitle", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "withDescription", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "required", 2);
__decorateClass([
  n4()
], ObjectInput.prototype, "handleInlangProjectChange", 2);
ObjectInput = __decorateClass([
  t2("object-input")
], ObjectInput);

// src/stories/input-fields/union/path-pattern-input.ts
var PathPatternInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = "";
    this.schema = {};
    this.required = false;
    this.handleInlangProjectChange = () => {
    };
    this._isObject = void 0;
    this._isInitialized = false;
  }
  get _descriptionObject() {
    if (this.schema.description) {
      return this.schema.description;
    } else {
      return "Specify the pathPattern to locate language files of specific namespaces in your repository. The namespace is a string taht shouldn't include '.', the path must include `{languageTag}` and end with `.json`.";
    }
  }
  get _examplesObject() {
    return [
      '{ common: "./locales/{languageTag}/common.json", app: "./locales/{languageTag}/app.json" }'
    ];
  }
  get _descriptionString() {
    if (this.schema.description) {
      return this.schema.description;
    } else {
      return this.schema.anyOf[0].description || void 0;
    }
  }
  get _examplesString() {
    return this.schema.anyOf[0].examples;
  }
  get _title() {
    return this.schema.title || void 0;
  }
  render() {
    if (this._isInitialized === false) {
      if (typeof this.value === "object") {
        this._isObject = true;
      } else {
        this._isObject = false;
      }
      this._isInitialized = true;
    }
    return ke` <div part="property" class="property">
			<field-header
				.fieldTitle=${this._title ? this._title : this.property}
				.optional=${this.required ? false : true}
				exportparts="property-title"
			></field-header>
			<sl-checkbox
				?checked=${this._isObject}
				@input=${(e6) => {
      if (e6.target.checked) {
        this._isObject = true;
      } else {
        this._isObject = false;
      }
    }}
				>with namespaces</sl-checkbox
			>
			${this._isObject ? ke`<div part="property" class="property">
						<field-header
							.description=${this._descriptionObject}
							.examples=${this._examplesObject}
							.optional=${this.required ? false : true}
							exportparts="property-title, property-paragraph"
						></field-header>
						<object-input
							exportparts="button"
							.value=${typeof this.value === "object" ? this.value : ""}
							.keyPlaceholder=${"Namespace"}
							.valuePlaceholder=${"Path to resource [./**/*.json]"}
							.handleInlangProjectChange=${this.handleInlangProjectChange}
							.property=${this.property}
							.moduleId=${this.moduleId}
							.schema=${this.schema}
							.withTitle=${false}
							.withDescription=${false}
							.required=${this.required}
						>
						</object-input>
				  </div>` : ke`<div part="property" class="property">
						<field-header
							.description=${this._descriptionString}
							.examples=${this._examplesString}
							.optional=${this.required ? false : true}
							exportparts="property-title, property-paragraph"
						></field-header>
						<sl-input
							value=${typeof this.value === "object" ? "" : this.value}
							size="small"
							placeholder="Path to resource [./**/*.json]"
							@input=${(e6) => {
      this.handleInlangProjectChange(
        e6.target.value,
        this.property,
        this.moduleId
      );
    }}
						>
						</sl-input>
				  </div>`}
		</div>`;
  }
};
PathPatternInput.styles = [
  i`
			.property {
				display: flex;
				flex-direction: column;
				gap: 12px;
			}
			sl-checkbox::part(base) {
				font-size: 14px;
				color: var(--sl-input-help-text-color);
			}
			.description-container {
				display: flex;
				flex-direction: column;
				gap: 4px;
			}
		`
];
__decorateClass([
  n4()
], PathPatternInput.prototype, "property", 2);
__decorateClass([
  n4()
], PathPatternInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], PathPatternInput.prototype, "value", 2);
__decorateClass([
  n4()
], PathPatternInput.prototype, "schema", 2);
__decorateClass([
  n4()
], PathPatternInput.prototype, "required", 2);
__decorateClass([
  n4()
], PathPatternInput.prototype, "handleInlangProjectChange", 2);
__decorateClass([
  r4()
], PathPatternInput.prototype, "_isObject", 2);
__decorateClass([
  r4()
], PathPatternInput.prototype, "_isInitialized", 2);
PathPatternInput = __decorateClass([
  t2("path-pattern-input")
], PathPatternInput);

// src/stories/input-fields/general-input.ts
var GeneralInput = class extends h3 {
  constructor() {
    super(...arguments);
    this.property = "";
    this.value = "";
    this.schema = {};
    this.required = {};
    this.handleInlangProjectChange = () => {
    };
  }
  render() {
    if (this.schema.type) {
      if (this.schema.type === "string") {
        return ke` <div>
					<string-input
						exportparts="property, property-title, property-paragraph"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
					></string-input>
				</div>`;
      } else if (this.schema.type === "array") {
        return ke` <div>
					<array-input
						exportparts="property, property-title, property-paragraph, button"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
					></array-input>
				</div>`;
      } else if (this.schema.type === "object") {
        return ke` <div>
					<object-input
						exportparts="property, property-title, property-paragraph, option, option-wrapper, button"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.modules=${this.modules}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
						.withTitle=${true}
						.withDescription=${true}
						.keyPlaceholder=${"Enter key"}
						.valuePlaceholder=${"Enter value"}
					></object-input>
				</div>`;
      } else {
        return ke` <div>
					<string-input
						exportparts="property, property-title, property-paragraph"
						.property=${this.property}
						.moduleId=${this.moduleId}
						.value=${this.value}
						.schema=${this.schema}
						.handleInlangProjectChange=${this.handleInlangProjectChange}
						.required=${this.required}
					></string-input>
				</div>`;
      }
    } else if (this.property === "pathPattern" || this.property === "sourceLanguageFilePath") {
      return ke` <div>
				<path-pattern-input
					exportparts="property, property-title, property-paragraph, button"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></path-pattern-input>
			</div>`;
    } else {
      return ke` <div>
				<string-input
					exportparts="property, property-title, property-paragraph"
					.property=${this.property}
					.moduleId=${this.moduleId}
					.value=${this.value}
					.schema=${this.schema}
					.handleInlangProjectChange=${this.handleInlangProjectChange}
					.required=${this.required}
				></string-input>
			</div>`;
    }
  }
};
__decorateClass([
  n4()
], GeneralInput.prototype, "property", 2);
__decorateClass([
  n4()
], GeneralInput.prototype, "moduleId", 2);
__decorateClass([
  n4()
], GeneralInput.prototype, "modules", 2);
__decorateClass([
  n4()
], GeneralInput.prototype, "value", 2);
__decorateClass([
  n4()
], GeneralInput.prototype, "schema", 2);
__decorateClass([
  n4()
], GeneralInput.prototype, "required", 2);
__decorateClass([
  n4()
], GeneralInput.prototype, "handleInlangProjectChange", 2);
GeneralInput = __decorateClass([
  t2("general-input")
], GeneralInput);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.V2OL7VMD.js
var tag_styles_default = i`
  :host {
    display: inline-block;
  }

  .tag {
    display: flex;
    align-items: center;
    border: solid 1px;
    line-height: 1;
    white-space: nowrap;
    user-select: none;
    -webkit-user-select: none;
  }

  .tag__remove::part(base) {
    color: inherit;
    padding: 0;
  }

  /*
   * Variant modifiers
   */

  .tag--primary {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-200);
    color: var(--sl-color-primary-800);
  }

  .tag--primary:active > sl-icon-button {
    color: var(--sl-color-primary-600);
  }

  .tag--success {
    background-color: var(--sl-color-success-50);
    border-color: var(--sl-color-success-200);
    color: var(--sl-color-success-800);
  }

  .tag--success:active > sl-icon-button {
    color: var(--sl-color-success-600);
  }

  .tag--neutral {
    background-color: var(--sl-color-neutral-50);
    border-color: var(--sl-color-neutral-200);
    color: var(--sl-color-neutral-800);
  }

  .tag--neutral:active > sl-icon-button {
    color: var(--sl-color-neutral-600);
  }

  .tag--warning {
    background-color: var(--sl-color-warning-50);
    border-color: var(--sl-color-warning-200);
    color: var(--sl-color-warning-800);
  }

  .tag--warning:active > sl-icon-button {
    color: var(--sl-color-warning-600);
  }

  .tag--danger {
    background-color: var(--sl-color-danger-50);
    border-color: var(--sl-color-danger-200);
    color: var(--sl-color-danger-800);
  }

  .tag--danger:active > sl-icon-button {
    color: var(--sl-color-danger-600);
  }

  /*
   * Size modifiers
   */

  .tag--small {
    font-size: var(--sl-button-font-size-small);
    height: calc(var(--sl-input-height-small) * 0.8);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
    padding: 0 var(--sl-spacing-x-small);
  }

  .tag--medium {
    font-size: var(--sl-button-font-size-medium);
    height: calc(var(--sl-input-height-medium) * 0.8);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
    padding: 0 var(--sl-spacing-small);
  }

  .tag--large {
    font-size: var(--sl-button-font-size-large);
    height: calc(var(--sl-input-height-large) * 0.8);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
    padding: 0 var(--sl-spacing-medium);
  }

  .tag__remove {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  /*
   * Pill modifier
   */

  .tag--pill {
    border-radius: var(--sl-border-radius-pill);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.6I2T3DLI.js
var icon_button_styles_default = i`
  :host {
    display: inline-block;
    color: var(--sl-color-neutral-600);
  }

  .icon-button {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    background: none;
    border: none;
    border-radius: var(--sl-border-radius-medium);
    font-size: inherit;
    color: inherit;
    padding: var(--sl-spacing-x-small);
    cursor: pointer;
    transition: var(--sl-transition-x-fast) color;
    -webkit-appearance: none;
  }

  .icon-button:hover:not(.icon-button--disabled),
  .icon-button:focus-visible:not(.icon-button--disabled) {
    color: var(--sl-color-primary-600);
  }

  .icon-button:active:not(.icon-button--disabled) {
    color: var(--sl-color-primary-700);
  }

  .icon-button:focus {
    outline: none;
  }

  .icon-button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .icon-button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .icon-button__icon {
    pointer-events: none;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3Y6SB6QS.js
var basePath = "";
function setBasePath(path) {
  basePath = path;
}
function getBasePath(subpath = "") {
  if (!basePath) {
    const scripts = [...document.getElementsByTagName("script")];
    const configScript = scripts.find((script) => script.hasAttribute("data-shoelace"));
    if (configScript) {
      setBasePath(configScript.getAttribute("data-shoelace"));
    } else {
      const fallbackScript = scripts.find((s2) => {
        return /shoelace(\.min)?\.js($|\?)/.test(s2.src) || /shoelace-autoloader(\.min)?\.js($|\?)/.test(s2.src);
      });
      let path = "";
      if (fallbackScript) {
        path = fallbackScript.getAttribute("src");
      }
      setBasePath(path.split("/").slice(0, -1).join("/"));
    }
  }
  return basePath.replace(/\/$/, "") + (subpath ? `/${subpath.replace(/^\//, "")}` : ``);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.P7ZG6EMR.js
var library = {
  name: "default",
  resolver: (name) => getBasePath(`assets/icons/${name}.svg`)
};
var library_default_default = library;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3TFKS637.js
var icons = {
  caret: `
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
  `,
  check: `
    <svg part="checked-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor">
          <g transform="translate(3.428571, 3.428571)">
            <path d="M0,5.71428571 L3.42857143,9.14285714"></path>
            <path d="M9.14285714,0 L3.42857143,9.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "chevron-down": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  "chevron-left": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-left" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
    </svg>
  `,
  "chevron-right": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-right" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
    </svg>
  `,
  copy: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-copy" viewBox="0 0 16 16">
      <path fill-rule="evenodd" d="M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2Zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6ZM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2Z"/>
    </svg>
  `,
  eye: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye" viewBox="0 0 16 16">
      <path d="M16 8s-3-5.5-8-5.5S0 8 0 8s3 5.5 8 5.5S16 8 16 8zM1.173 8a13.133 13.133 0 0 1 1.66-2.043C4.12 4.668 5.88 3.5 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.133 13.133 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755C11.879 11.332 10.119 12.5 8 12.5c-2.12 0-3.879-1.168-5.168-2.457A13.134 13.134 0 0 1 1.172 8z"/>
      <path d="M8 5.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5zM4.5 8a3.5 3.5 0 1 1 7 0 3.5 3.5 0 0 1-7 0z"/>
    </svg>
  `,
  "eye-slash": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eye-slash" viewBox="0 0 16 16">
      <path d="M13.359 11.238C15.06 9.72 16 8 16 8s-3-5.5-8-5.5a7.028 7.028 0 0 0-2.79.588l.77.771A5.944 5.944 0 0 1 8 3.5c2.12 0 3.879 1.168 5.168 2.457A13.134 13.134 0 0 1 14.828 8c-.058.087-.122.183-.195.288-.335.48-.83 1.12-1.465 1.755-.165.165-.337.328-.517.486l.708.709z"/>
      <path d="M11.297 9.176a3.5 3.5 0 0 0-4.474-4.474l.823.823a2.5 2.5 0 0 1 2.829 2.829l.822.822zm-2.943 1.299.822.822a3.5 3.5 0 0 1-4.474-4.474l.823.823a2.5 2.5 0 0 0 2.829 2.829z"/>
      <path d="M3.35 5.47c-.18.16-.353.322-.518.487A13.134 13.134 0 0 0 1.172 8l.195.288c.335.48.83 1.12 1.465 1.755C4.121 11.332 5.881 12.5 8 12.5c.716 0 1.39-.133 2.02-.36l.77.772A7.029 7.029 0 0 1 8 13.5C3 13.5 0 8 0 8s.939-1.721 2.641-3.238l.708.709zm10.296 8.884-12-12 .708-.708 12 12-.708.708z"/>
    </svg>
  `,
  eyedropper: `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-eyedropper" viewBox="0 0 16 16">
      <path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708l-2-2zM2 12.707l7-7L10.293 7l-7 7H2v-1.293z"></path>
    </svg>
  `,
  "grip-vertical": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-grip-vertical" viewBox="0 0 16 16">
      <path d="M7 2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 5a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zM7 8a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm-3 3a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm3 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"></path>
    </svg>
  `,
  indeterminate: `
    <svg part="indeterminate-icon" class="checkbox__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
        <g stroke="currentColor" stroke-width="2">
          <g transform="translate(2.285714, 6.857143)">
            <path d="M10.2857143,1.14285714 L1.14285714,1.14285714"></path>
          </g>
        </g>
      </g>
    </svg>
  `,
  "person-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-person-fill" viewBox="0 0 16 16">
      <path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
    </svg>
  `,
  "play-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill" viewBox="0 0 16 16">
      <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"></path>
    </svg>
  `,
  "pause-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pause-fill" viewBox="0 0 16 16">
      <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"></path>
    </svg>
  `,
  radio: `
    <svg part="checked-icon" class="radio__icon" viewBox="0 0 16 16">
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor">
          <circle cx="8" cy="8" r="3.42857143"></circle>
        </g>
      </g>
    </svg>
  `,
  "star-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-star-fill" viewBox="0 0 16 16">
      <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
    </svg>
  `,
  "x-lg": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
      <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/>
    </svg>
  `,
  "x-circle-fill": `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-circle-fill" viewBox="0 0 16 16">
      <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z"></path>
    </svg>
  `
};
var systemLibrary = {
  name: "system",
  resolver: (name) => {
    if (name in icons) {
      return `data:image/svg+xml,${encodeURIComponent(icons[name])}`;
    }
    return "";
  }
};
var library_system_default = systemLibrary;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.ZL53POKZ.js
var registry2 = [library_default_default, library_system_default];
var watchedIcons = [];
function watchIcon(icon) {
  watchedIcons.push(icon);
}
function unwatchIcon(icon) {
  watchedIcons = watchedIcons.filter((el) => el !== icon);
}
function getIconLibrary(name) {
  return registry2.find((lib) => lib.name === name);
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QLXRCYS4.js
var icon_styles_default = i`
  :host {
    display: inline-block;
    width: 1em;
    height: 1em;
    box-sizing: content-box !important;
  }

  svg {
    display: block;
    height: 100%;
    width: 100%;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.IFDWM6P4.js
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __decorateClass2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.2FB5TK5H.js
function watch(propertyName, options) {
  const resolvedOptions = __spreadValues({
    waitUntilFirstUpdate: false
  }, options);
  return (proto, decoratedFnName) => {
    const { update: update2 } = proto;
    const watchedProperties = Array.isArray(propertyName) ? propertyName : [propertyName];
    proto.update = function(changedProps) {
      watchedProperties.forEach((property) => {
        const key = property;
        if (changedProps.has(key)) {
          const oldValue = changedProps.get(key);
          const newValue = this[key];
          if (oldValue !== newValue) {
            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {
              this[decoratedFnName](oldValue, newValue);
            }
          }
        }
      });
      update2.call(this, changedProps);
    };
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TUVJKY7S.js
var component_styles_default = i`
  :host {
    box-sizing: border-box;
  }

  :host *,
  :host *::before,
  :host *::after {
    box-sizing: inherit;
  }

  [hidden] {
    display: none !important;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RVOOE4AQ.js
var ShoelaceElement = class extends h3 {
  constructor() {
    super();
    Object.entries(this.constructor.dependencies).forEach(([name, component]) => {
      this.constructor.define(name, component);
    });
  }
  emit(name, options) {
    const event = new CustomEvent(name, __spreadValues({
      bubbles: true,
      cancelable: false,
      composed: true,
      detail: {}
    }, options));
    this.dispatchEvent(event);
    return event;
  }
  /* eslint-enable */
  static define(name, elementConstructor = this, options = {}) {
    const currentlyRegisteredConstructor = customElements.get(name);
    if (!currentlyRegisteredConstructor) {
      customElements.define(name, class extends elementConstructor {
      }, options);
      return;
    }
    let newVersion = " (unknown version)";
    let existingVersion = newVersion;
    if ("version" in elementConstructor && elementConstructor.version) {
      newVersion = " v" + elementConstructor.version;
    }
    if ("version" in currentlyRegisteredConstructor && currentlyRegisteredConstructor.version) {
      existingVersion = " v" + currentlyRegisteredConstructor.version;
    }
    if (newVersion && existingVersion && newVersion === existingVersion) {
      return;
    }
    console.warn(
      `Attempted to register <${name}>${newVersion}, but <${name}>${existingVersion} has already been registered.`
    );
  }
};
ShoelaceElement.version = "2.14.0";
ShoelaceElement.dependencies = {};
__decorateClass2([
  n4()
], ShoelaceElement.prototype, "dir", 2);
__decorateClass2([
  n4()
], ShoelaceElement.prototype, "lang", 2);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/directive-helpers.js
var { I: et2 } = si;
var nt = (o5, t5) => void 0 === t5 ? void 0 !== o5?._$litType$ : o5?._$litType$ === t5;
var rt = (o5) => void 0 === o5.strings;
var ht = {};
var dt = (o5, t5 = ht) => o5._$AH = t5;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7YG67M3U.js
var CACHEABLE_ERROR = Symbol();
var RETRYABLE_ERROR = Symbol();
var parser;
var iconCache = /* @__PURE__ */ new Map();
var SlIcon = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.initialRender = false;
    this.svg = null;
    this.label = "";
    this.library = "default";
  }
  /** Given a URL, this function returns the resulting SVG element or an appropriate error symbol. */
  async resolveIcon(url, library2) {
    var _a;
    let fileData;
    if (library2 == null ? void 0 : library2.spriteSheet) {
      return ke`<svg part="svg">
        <use part="use" href="${url}"></use>
      </svg>`;
    }
    try {
      fileData = await fetch(url, { mode: "cors" });
      if (!fileData.ok)
        return fileData.status === 410 ? CACHEABLE_ERROR : RETRYABLE_ERROR;
    } catch (e6) {
      return RETRYABLE_ERROR;
    }
    try {
      const div = document.createElement("div");
      div.innerHTML = await fileData.text();
      const svg = div.firstElementChild;
      if (((_a = svg == null ? void 0 : svg.tagName) == null ? void 0 : _a.toLowerCase()) !== "svg")
        return CACHEABLE_ERROR;
      if (!parser)
        parser = new DOMParser();
      const doc = parser.parseFromString(svg.outerHTML, "text/html");
      const svgEl = doc.body.querySelector("svg");
      if (!svgEl)
        return CACHEABLE_ERROR;
      svgEl.part.add("svg");
      return document.adoptNode(svgEl);
    } catch (e6) {
      return CACHEABLE_ERROR;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    watchIcon(this);
  }
  firstUpdated() {
    this.initialRender = true;
    this.setIcon();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    unwatchIcon(this);
  }
  getIconSource() {
    const library2 = getIconLibrary(this.library);
    if (this.name && library2) {
      return {
        url: library2.resolver(this.name),
        fromLibrary: true
      };
    }
    return {
      url: this.src,
      fromLibrary: false
    };
  }
  handleLabelChange() {
    const hasLabel = typeof this.label === "string" && this.label.length > 0;
    if (hasLabel) {
      this.setAttribute("role", "img");
      this.setAttribute("aria-label", this.label);
      this.removeAttribute("aria-hidden");
    } else {
      this.removeAttribute("role");
      this.removeAttribute("aria-label");
      this.setAttribute("aria-hidden", "true");
    }
  }
  async setIcon() {
    var _a;
    const { url, fromLibrary } = this.getIconSource();
    const library2 = fromLibrary ? getIconLibrary(this.library) : void 0;
    if (!url) {
      this.svg = null;
      return;
    }
    let iconResolver = iconCache.get(url);
    if (!iconResolver) {
      iconResolver = this.resolveIcon(url, library2);
      iconCache.set(url, iconResolver);
    }
    if (!this.initialRender) {
      return;
    }
    const svg = await iconResolver;
    if (svg === RETRYABLE_ERROR) {
      iconCache.delete(url);
    }
    if (url !== this.getIconSource().url) {
      return;
    }
    if (nt(svg)) {
      this.svg = svg;
      return;
    }
    switch (svg) {
      case RETRYABLE_ERROR:
      case CACHEABLE_ERROR:
        this.svg = null;
        this.emit("sl-error");
        break;
      default:
        this.svg = svg.cloneNode(true);
        (_a = library2 == null ? void 0 : library2.mutator) == null ? void 0 : _a.call(library2, this.svg);
        this.emit("sl-load");
    }
  }
  render() {
    return this.svg;
  }
};
SlIcon.styles = [component_styles_default, icon_styles_default];
__decorateClass2([
  r4()
], SlIcon.prototype, "svg", 2);
__decorateClass2([
  n4({ reflect: true })
], SlIcon.prototype, "name", 2);
__decorateClass2([
  n4()
], SlIcon.prototype, "src", 2);
__decorateClass2([
  n4()
], SlIcon.prototype, "label", 2);
__decorateClass2([
  n4({ reflect: true })
], SlIcon.prototype, "library", 2);
__decorateClass2([
  watch("label")
], SlIcon.prototype, "handleLabelChange", 1);
__decorateClass2([
  watch(["name", "src", "library"])
], SlIcon.prototype, "setIcon", 1);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/directive.js
var t3 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e5 = (t5) => (...e6) => ({ _$litDirective$: t5, values: e6 });
var i3 = class {
  constructor(t5) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t5, e6, i4) {
    this.t = t5, this._$AM = e6, this.i = i4;
  }
  _$AS(t5, e6) {
    return this.update(t5, e6);
  }
  update(t5, e6) {
    return this.render(...e6);
  }
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/directives/class-map.js
var Rt = e5(class extends i3 {
  constructor(s2) {
    if (super(s2), s2.type !== t3.ATTRIBUTE || "class" !== s2.name || s2.strings?.length > 2)
      throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t5) {
    return " " + Object.keys(t5).filter((s2) => t5[s2]).join(" ") + " ";
  }
  update(t5, [s2]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== t5.strings && (this.nt = new Set(t5.strings.join(" ").split(/\s/).filter((t6) => "" !== t6)));
      for (const t6 in s2)
        s2[t6] && !this.nt?.has(t6) && this.st.add(t6);
      return this.render(s2);
    }
    const i4 = t5.element.classList;
    for (const t6 of this.st)
      t6 in s2 || (i4.remove(t6), this.st.delete(t6));
    for (const t6 in s2) {
      const r6 = !!s2[t6];
      r6 === this.st.has(t6) || this.nt?.has(t6) || (r6 ? (i4.add(t6), this.st.add(t6)) : (i4.remove(t6), this.st.delete(t6)));
    }
    return R;
  }
});

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/static.js
var $e = Symbol.for("");
var xe = (t5) => {
  if (t5?.r === $e)
    return t5?._$litStatic$;
};
var er = (t5, ...r6) => ({ _$litStatic$: r6.reduce((r7, e6, a2) => r7 + ((t6) => {
  if (void 0 !== t6._$litStatic$)
    return t6._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t6}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e6) + t5[a2 + 1], t5[0]), r: $e });
var Te = /* @__PURE__ */ new Map();
var Ee = (t5) => (r6, ...e6) => {
  const a2 = e6.length;
  let o5, s2;
  const i4 = [], l2 = [];
  let n5, u2 = 0, c4 = false;
  for (; u2 < a2; ) {
    for (n5 = r6[u2]; u2 < a2 && void 0 !== (s2 = e6[u2], o5 = xe(s2)); )
      n5 += o5 + r6[++u2], c4 = true;
    u2 !== a2 && l2.push(s2), i4.push(n5), u2++;
  }
  if (u2 === a2 && i4.push(r6[a2]), c4) {
    const t6 = i4.join("$$lit$$");
    void 0 === (r6 = Te.get(t6)) && (i4.raw = i4, Te.set(t6, r6 = i4)), e6 = l2;
  }
  return t5(r6, ...e6);
};
var ke2 = Ee(ke);
var Oe2 = Ee(Oe);
var Se2 = Ee(Se);

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/directives/if-defined.js
var to = (t5) => t5 ?? D;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7XLSSP47.js
var SlIconButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.hasFocus = false;
    this.label = "";
    this.disabled = false;
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** Simulates a click on the icon button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the icon button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the icon button. */
  blur() {
    this.button.blur();
  }
  render() {
    const isLink = this.href ? true : false;
    const tag2 = isLink ? er`a` : er`button`;
    return ke2`
      <${tag2}
        part="base"
        class=${Rt({
      "icon-button": true,
      "icon-button--disabled": !isLink && this.disabled,
      "icon-button--focused": this.hasFocus
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : "button")}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink && this.target ? "noreferrer noopener" : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        aria-label="${this.label}"
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @click=${this.handleClick}
      >
        <sl-icon
          class="icon-button__icon"
          name=${to(this.name)}
          library=${to(this.library)}
          src=${to(this.src)}
          aria-hidden="true"
        ></sl-icon>
      </${tag2}>
    `;
  }
};
SlIconButton.styles = [component_styles_default, icon_button_styles_default];
SlIconButton.dependencies = { "sl-icon": SlIcon };
__decorateClass2([
  e4(".icon-button")
], SlIconButton.prototype, "button", 2);
__decorateClass2([
  r4()
], SlIconButton.prototype, "hasFocus", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "name", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "library", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "src", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "href", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "target", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "download", 2);
__decorateClass2([
  n4()
], SlIconButton.prototype, "label", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlIconButton.prototype, "disabled", 2);

// ../../../node_modules/.pnpm/@shoelace-style+localize@3.2.1/node_modules/@shoelace-style/localize/dist/index.js
var connectedElements = /* @__PURE__ */ new Set();
var translations = /* @__PURE__ */ new Map();
var fallback;
var documentDirection = "ltr";
var documentLanguage = "en";
var isClient = typeof MutationObserver !== "undefined" && typeof document !== "undefined" && typeof document.documentElement !== "undefined";
if (isClient) {
  const documentElementObserver = new MutationObserver(update);
  documentDirection = document.documentElement.dir || "ltr";
  documentLanguage = document.documentElement.lang || navigator.language;
  documentElementObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["dir", "lang"]
  });
}
function registerTranslation(...translation2) {
  translation2.map((t5) => {
    const code = t5.$code.toLowerCase();
    if (translations.has(code)) {
      translations.set(code, Object.assign(Object.assign({}, translations.get(code)), t5));
    } else {
      translations.set(code, t5);
    }
    if (!fallback) {
      fallback = t5;
    }
  });
  update();
}
function update() {
  if (isClient) {
    documentDirection = document.documentElement.dir || "ltr";
    documentLanguage = document.documentElement.lang || navigator.language;
  }
  [...connectedElements.keys()].map((el) => {
    if (typeof el.requestUpdate === "function") {
      el.requestUpdate();
    }
  });
}
var LocalizeController = class {
  constructor(host) {
    this.host = host;
    this.host.addController(this);
  }
  hostConnected() {
    connectedElements.add(this.host);
  }
  hostDisconnected() {
    connectedElements.delete(this.host);
  }
  dir() {
    return `${this.host.dir || documentDirection}`.toLowerCase();
  }
  lang() {
    return `${this.host.lang || documentLanguage}`.toLowerCase();
  }
  getTranslationData(lang) {
    var _a, _b;
    const locale = new Intl.Locale(lang.replace(/_/g, "-"));
    const language = locale === null || locale === void 0 ? void 0 : locale.language.toLowerCase();
    const region = (_b = (_a = locale === null || locale === void 0 ? void 0 : locale.region) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : "";
    const primary = translations.get(`${language}-${region}`);
    const secondary = translations.get(language);
    return { locale, language, region, primary, secondary };
  }
  exists(key, options) {
    var _a;
    const { primary, secondary } = this.getTranslationData((_a = options.lang) !== null && _a !== void 0 ? _a : this.lang());
    options = Object.assign({ includeFallback: false }, options);
    if (primary && primary[key] || secondary && secondary[key] || options.includeFallback && fallback && fallback[key]) {
      return true;
    }
    return false;
  }
  term(key, ...args) {
    const { primary, secondary } = this.getTranslationData(this.lang());
    let term;
    if (primary && primary[key]) {
      term = primary[key];
    } else if (secondary && secondary[key]) {
      term = secondary[key];
    } else if (fallback && fallback[key]) {
      term = fallback[key];
    } else {
      console.error(`No translation found for: ${String(key)}`);
      return String(key);
    }
    if (typeof term === "function") {
      return term(...args);
    }
    return term;
  }
  date(dateToFormat, options) {
    dateToFormat = new Date(dateToFormat);
    return new Intl.DateTimeFormat(this.lang(), options).format(dateToFormat);
  }
  number(numberToFormat, options) {
    numberToFormat = Number(numberToFormat);
    return isNaN(numberToFormat) ? "" : new Intl.NumberFormat(this.lang(), options).format(numberToFormat);
  }
  relativeTime(value, unit, options) {
    return new Intl.RelativeTimeFormat(this.lang(), options).format(value, unit);
  }
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.MAS2SHYD.js
var translation = {
  $code: "en",
  $name: "English",
  $dir: "ltr",
  carousel: "Carousel",
  clearEntry: "Clear entry",
  close: "Close",
  copied: "Copied",
  copy: "Copy",
  currentValue: "Current value",
  error: "Error",
  goToSlide: (slide, count) => `Go to slide ${slide} of ${count}`,
  hidePassword: "Hide password",
  loading: "Loading",
  nextSlide: "Next slide",
  numOptionsSelected: (num3) => {
    if (num3 === 0)
      return "No options selected";
    if (num3 === 1)
      return "1 option selected";
    return `${num3} options selected`;
  },
  previousSlide: "Previous slide",
  progress: "Progress",
  remove: "Remove",
  resize: "Resize",
  scrollToEnd: "Scroll to end",
  scrollToStart: "Scroll to start",
  selectAColorFromTheScreen: "Select a color from the screen",
  showPassword: "Show password",
  slideNum: (slide) => `Slide ${slide}`,
  toggleColorFormat: "Toggle color format"
};
registerTranslation(translation);
var en_default = translation;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.WLV3FVBR.js
var LocalizeController2 = class extends LocalizeController {
};
registerTranslation(en_default);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7J6CPMBU.js
var SlTag = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.variant = "neutral";
    this.size = "medium";
    this.pill = false;
    this.removable = false;
  }
  handleRemoveClick() {
    this.emit("sl-remove");
  }
  render() {
    return ke`
      <span
        part="base"
        class=${Rt({
      tag: true,
      // Types
      "tag--primary": this.variant === "primary",
      "tag--success": this.variant === "success",
      "tag--neutral": this.variant === "neutral",
      "tag--warning": this.variant === "warning",
      "tag--danger": this.variant === "danger",
      "tag--text": this.variant === "text",
      // Sizes
      "tag--small": this.size === "small",
      "tag--medium": this.size === "medium",
      "tag--large": this.size === "large",
      // Modifiers
      "tag--pill": this.pill,
      "tag--removable": this.removable
    })}
      >
        <slot part="content" class="tag__content"></slot>

        ${this.removable ? ke`
              <sl-icon-button
                part="remove-button"
                exportparts="base:remove-button__base"
                name="x-lg"
                library="system"
                label=${this.localize.term("remove")}
                class="tag__remove"
                @click=${this.handleRemoveClick}
                tabindex="-1"
              ></sl-icon-button>
            ` : ""}
      </span>
    `;
  }
};
SlTag.styles = [component_styles_default, tag_styles_default];
SlTag.dependencies = { "sl-icon-button": SlIconButton };
__decorateClass2([
  n4({ reflect: true })
], SlTag.prototype, "variant", 2);
__decorateClass2([
  n4({ reflect: true })
], SlTag.prototype, "size", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlTag.prototype, "pill", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlTag.prototype, "removable", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.AN6YZWTU.js
var select_styles_default = i`
  :host {
    display: block;
  }

  /** The popup */
  .select {
    flex: 1 1 auto;
    display: inline-flex;
    width: 100%;
    position: relative;
    vertical-align: middle;
  }

  .select::part(popup) {
    z-index: var(--sl-z-index-dropdown);
  }

  .select[data-current-placement^='top']::part(popup) {
    transform-origin: bottom;
  }

  .select[data-current-placement^='bottom']::part(popup) {
    transform-origin: top;
  }

  /* Combobox */
  .select__combobox {
    flex: 1;
    display: flex;
    width: 100%;
    min-width: 0;
    position: relative;
    align-items: center;
    justify-content: start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: pointer;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  .select__display-input {
    position: relative;
    width: 100%;
    font: inherit;
    border: none;
    background: none;
    color: var(--sl-input-color);
    cursor: inherit;
    overflow: hidden;
    padding: 0;
    margin: 0;
    -webkit-appearance: none;
  }

  .select__display-input::placeholder {
    color: var(--sl-input-placeholder-color);
  }

  .select:not(.select--disabled):hover .select__display-input {
    color: var(--sl-input-color-hover);
  }

  .select__display-input:focus {
    outline: none;
  }

  /* Visually hide the display input when multiple is enabled */
  .select--multiple:not(.select--placeholder-visible) .select__display-input {
    position: absolute;
    z-index: -1;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
  }

  .select__value-input {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 0;
    margin: 0;
    opacity: 0;
    z-index: -1;
  }

  .select__tags {
    display: flex;
    flex: 1;
    align-items: center;
    flex-wrap: wrap;
    margin-inline-start: var(--sl-spacing-2x-small);
  }

  .select__tags::slotted(sl-tag) {
    cursor: pointer !important;
  }

  .select--disabled .select__tags,
  .select--disabled .select__tags::slotted(sl-tag) {
    cursor: not-allowed !important;
  }

  /* Standard selects */
  .select--standard .select__combobox {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .select--standard.select--disabled .select__combobox {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    color: var(--sl-input-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
    outline: none;
  }

  .select--standard:not(.select--disabled).select--open .select__combobox,
  .select--standard:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  /* Filled selects */
  .select--filled .select__combobox {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .select--filled:hover:not(.select--disabled) .select__combobox {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .select--filled.select--disabled .select__combobox {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .select--filled:not(.select--disabled).select--open .select__combobox,
  .select--filled:not(.select--disabled).select--focused .select__combobox {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
  }

  /* Sizes */
  .select--small .select__combobox {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    min-height: var(--sl-input-height-small);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-small);
  }

  .select--small .select__clear {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .select--small .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .select--small.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-block: 2px;
    padding-inline-start: 0;
  }

  .select--small .select__tags {
    gap: 2px;
  }

  .select--medium .select__combobox {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    min-height: var(--sl-input-height-medium);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-medium);
  }

  .select--medium .select__clear {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .select--medium .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .select--medium.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 3px;
  }

  .select--medium .select__tags {
    gap: 3px;
  }

  .select--large .select__combobox {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    min-height: var(--sl-input-height-large);
    padding-block: 0;
    padding-inline: var(--sl-input-spacing-large);
  }

  .select--large .select__clear {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .select--large .select__prefix::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  .select--large.select--multiple:not(.select--placeholder-visible) .select__combobox {
    padding-inline-start: 0;
    padding-block: 4px;
  }

  .select--large .select__tags {
    gap: 4px;
  }

  /* Pills */
  .select--pill.select--small .select__combobox {
    border-radius: var(--sl-input-height-small);
  }

  .select--pill.select--medium .select__combobox {
    border-radius: var(--sl-input-height-medium);
  }

  .select--pill.select--large .select__combobox {
    border-radius: var(--sl-input-height-large);
  }

  /* Prefix */
  .select__prefix {
    flex: 0;
    display: inline-flex;
    align-items: center;
    color: var(--sl-input-placeholder-color);
  }

  /* Clear button */
  .select__clear {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .select__clear:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .select__clear:focus {
    outline: none;
  }

  /* Expand icon */
  .select__expand-icon {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    transition: var(--sl-transition-medium) rotate ease;
    rotate: 0;
    margin-inline-start: var(--sl-spacing-small);
  }

  .select--open .select__expand-icon {
    rotate: -180deg;
  }

  /* Listbox */
  .select__listbox {
    display: block;
    position: relative;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    box-shadow: var(--sl-shadow-large);
    background: var(--sl-panel-background-color);
    border: solid var(--sl-panel-border-width) var(--sl-panel-border-color);
    border-radius: var(--sl-border-radius-medium);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: 0;
    overflow: auto;
    overscroll-behavior: none;

    /* Make sure it adheres to the popup's auto size */
    max-width: var(--auto-size-available-width);
    max-height: var(--auto-size-available-height);
  }

  .select__listbox ::slotted(sl-divider) {
    --spacing: var(--sl-spacing-x-small);
  }

  .select__listbox ::slotted(small) {
    font-size: var(--sl-font-size-small);
    font-weight: var(--sl-font-weight-semibold);
    color: var(--sl-color-neutral-500);
    padding-block: var(--sl-spacing-x-small);
    padding-inline: var(--sl-spacing-x-large);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.RK73WSZS.js
function getOffset(element, parent) {
  return {
    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),
    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left)
  };
}
function scrollIntoView(element, container, direction = "vertical", behavior = "smooth") {
  const offset3 = getOffset(element, container);
  const offsetTop = offset3.top + container.scrollTop;
  const offsetLeft = offset3.left + container.scrollLeft;
  const minX = container.scrollLeft;
  const maxX = container.scrollLeft + container.offsetWidth;
  const minY = container.scrollTop;
  const maxY = container.scrollTop + container.offsetHeight;
  if (direction === "horizontal" || direction === "both") {
    if (offsetLeft < minX) {
      container.scrollTo({ left: offsetLeft, behavior });
    } else if (offsetLeft + element.clientWidth > maxX) {
      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });
    }
  }
  if (direction === "vertical" || direction === "both") {
    if (offsetTop < minY) {
      container.scrollTo({ top: offsetTop, behavior });
    } else if (offsetTop + element.clientHeight > maxY) {
      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });
    }
  }
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.SI4ACBFK.js
var form_control_styles_default = i`
  .form-control .form-control__label {
    display: none;
  }

  .form-control .form-control__help-text {
    display: none;
  }

  /* Label */
  .form-control--has-label .form-control__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    margin-bottom: var(--sl-spacing-3x-small);
  }

  .form-control--has-label.form-control--small .form-control__label {
    font-size: var(--sl-input-label-font-size-small);
  }

  .form-control--has-label.form-control--medium .form-control__label {
    font-size: var(--sl-input-label-font-size-medium);
  }

  .form-control--has-label.form-control--large .form-control__label {
    font-size: var(--sl-input-label-font-size-large);
  }

  :host([required]) .form-control--has-label .form-control__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
    color: var(--sl-input-required-content-color);
  }

  /* Help text */
  .form-control--has-help-text .form-control__help-text {
    display: block;
    color: var(--sl-input-help-text-color);
    margin-top: var(--sl-spacing-3x-small);
  }

  .form-control--has-help-text.form-control--small .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-small);
  }

  .form-control--has-help-text.form-control--medium .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-medium);
  }

  .form-control--has-help-text.form-control--large .form-control__help-text {
    font-size: var(--sl-input-help-text-font-size-large);
  }

  .form-control--has-help-text.form-control--radio-group .form-control__help-text {
    margin-top: var(--sl-spacing-2x-small);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.GI7VDIWX.js
var defaultValue = (propertyName = "value") => (proto, key) => {
  const ctor = proto.constructor;
  const attributeChangedCallback = ctor.prototype.attributeChangedCallback;
  ctor.prototype.attributeChangedCallback = function(name, old, value) {
    var _a;
    const options = ctor.getPropertyOptions(propertyName);
    const attributeName = typeof options.attribute === "string" ? options.attribute : propertyName;
    if (name === attributeName) {
      const converter = options.converter || u;
      const fromAttribute = typeof converter === "function" ? converter : (_a = converter == null ? void 0 : converter.fromAttribute) != null ? _a : u.fromAttribute;
      const newValue = fromAttribute(value, options.type);
      if (this[propertyName] !== newValue) {
        this[key] = newValue;
      }
    }
    attributeChangedCallback.call(this, name, old, value);
  };
};

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.3KSWVBQ5.js
var popup_styles_default = i`
  :host {
    --arrow-color: var(--sl-color-neutral-1000);
    --arrow-size: 6px;

    /*
     * These properties are computed to account for the arrow's dimensions after being rotated 45º. The constant
     * 0.7071 is derived from sin(45), which is the diagonal size of the arrow's container after rotating.
     */
    --arrow-size-diagonal: calc(var(--arrow-size) * 0.7071);
    --arrow-padding-offset: calc(var(--arrow-size-diagonal) - var(--arrow-size));

    display: contents;
  }

  .popup {
    position: absolute;
    isolation: isolate;
    max-width: var(--auto-size-available-width, none);
    max-height: var(--auto-size-available-height, none);
  }

  .popup--fixed {
    position: fixed;
  }

  .popup:not(.popup--active) {
    display: none;
  }

  .popup__arrow {
    position: absolute;
    width: calc(var(--arrow-size-diagonal) * 2);
    height: calc(var(--arrow-size-diagonal) * 2);
    rotate: 45deg;
    background: var(--arrow-color);
    z-index: -1;
  }

  /* Hover bridge */
  .popup-hover-bridge:not(.popup-hover-bridge--visible) {
    display: none;
  }

  .popup-hover-bridge {
    position: fixed;
    z-index: calc(var(--sl-z-index-dropdown) - 1);
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    clip-path: polygon(
      var(--hover-bridge-top-left-x, 0) var(--hover-bridge-top-left-y, 0),
      var(--hover-bridge-top-right-x, 0) var(--hover-bridge-top-right-y, 0),
      var(--hover-bridge-bottom-right-x, 0) var(--hover-bridge-bottom-right-y, 0),
      var(--hover-bridge-bottom-left-x, 0) var(--hover-bridge-bottom-left-y, 0)
    );
  }
`;

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min5 = Math.min;
var max5 = Math.max;
var round8 = Math.round;
var floor5 = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max5(start, min5(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}

// ../../../node_modules/.pnpm/@floating-ui+core@1.6.7/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i4 = 0; i4 < validMiddleware.length; i4++) {
    const {
      name,
      fn
    } = validMiddleware[i4];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i4 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min5(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min5(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max6 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max6);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max6 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min6 = mainAxisCoord + overflow[minSide];
        const max6 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min6, mainAxisCoord, max6);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min6 = crossAxisCoord + overflow[minSide];
        const max6 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min6, crossAxisCoord, max6);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min5(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min5(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min5(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min5(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max5(overflow.left, 0);
        const xMax = max5(overflow.right, 0);
        const yMin = max5(overflow.top, 0);
        const yMax = max5(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max5(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max5(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../../node_modules/.pnpm/@floating-ui+utils@0.2.7/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e6) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../../node_modules/.pnpm/@floating-ui+dom@1.6.10/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round8(width) !== offsetWidth || round8(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round8(rect.width) : rect.width) / width;
  let y2 = ($2 ? round8(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max5(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max5(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x2 += max5(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max5(rect.top, accRect.top);
    accRect.right = min5(rect.right, accRect.right);
    accRect.bottom = min5(rect.bottom, accRect.bottom);
    accRect.left = max5(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor5(top);
    const insetRight = floor5(root.clientWidth - (left + width));
    const insetBottom = floor5(root.clientHeight - (top + height));
    const insetLeft = floor5(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max5(0, min5(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e6) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../../node_modules/.pnpm/composed-offset-position@0.0.4/node_modules/composed-offset-position/dist/composed-offset-position.browser.min.mjs
function t4(t5) {
  return r5(t5);
}
function o4(t5) {
  return t5.assignedSlot ? t5.assignedSlot : t5.parentNode instanceof ShadowRoot ? t5.parentNode.host : t5.parentNode;
}
function r5(t5) {
  for (let e6 = t5; e6; e6 = o4(e6))
    if (e6 instanceof Element && "none" === getComputedStyle(e6).display)
      return null;
  for (let e6 = o4(t5); e6; e6 = o4(e6)) {
    if (!(e6 instanceof Element))
      continue;
    const t6 = getComputedStyle(e6);
    if ("contents" !== t6.display) {
      if ("static" !== t6.position || "none" !== t6.filter)
        return e6;
      if ("BODY" === e6.tagName)
        return e6;
    }
  }
  return null;
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.JLIBGQ2M.js
function isVirtualElement(e6) {
  return e6 !== null && typeof e6 === "object" && "getBoundingClientRect" in e6;
}
var SlPopup = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.active = false;
    this.placement = "top";
    this.strategy = "absolute";
    this.distance = 0;
    this.skidding = 0;
    this.arrow = false;
    this.arrowPlacement = "anchor";
    this.arrowPadding = 10;
    this.flip = false;
    this.flipFallbackPlacements = "";
    this.flipFallbackStrategy = "best-fit";
    this.flipPadding = 0;
    this.shift = false;
    this.shiftPadding = 0;
    this.autoSizePadding = 0;
    this.hoverBridge = false;
    this.updateHoverBridge = () => {
      if (this.hoverBridge && this.anchorEl) {
        const anchorRect = this.anchorEl.getBoundingClientRect();
        const popupRect = this.popup.getBoundingClientRect();
        const isVertical = this.placement.includes("top") || this.placement.includes("bottom");
        let topLeftX = 0;
        let topLeftY = 0;
        let topRightX = 0;
        let topRightY = 0;
        let bottomLeftX = 0;
        let bottomLeftY = 0;
        let bottomRightX = 0;
        let bottomRightY = 0;
        if (isVertical) {
          if (anchorRect.top < popupRect.top) {
            topLeftX = anchorRect.left;
            topLeftY = anchorRect.bottom;
            topRightX = anchorRect.right;
            topRightY = anchorRect.bottom;
            bottomLeftX = popupRect.left;
            bottomLeftY = popupRect.top;
            bottomRightX = popupRect.right;
            bottomRightY = popupRect.top;
          } else {
            topLeftX = popupRect.left;
            topLeftY = popupRect.bottom;
            topRightX = popupRect.right;
            topRightY = popupRect.bottom;
            bottomLeftX = anchorRect.left;
            bottomLeftY = anchorRect.top;
            bottomRightX = anchorRect.right;
            bottomRightY = anchorRect.top;
          }
        } else {
          if (anchorRect.left < popupRect.left) {
            topLeftX = anchorRect.right;
            topLeftY = anchorRect.top;
            topRightX = popupRect.left;
            topRightY = popupRect.top;
            bottomLeftX = anchorRect.right;
            bottomLeftY = anchorRect.bottom;
            bottomRightX = popupRect.left;
            bottomRightY = popupRect.bottom;
          } else {
            topLeftX = popupRect.right;
            topLeftY = popupRect.top;
            topRightX = anchorRect.left;
            topRightY = anchorRect.top;
            bottomLeftX = popupRect.right;
            bottomLeftY = popupRect.bottom;
            bottomRightX = anchorRect.left;
            bottomRightY = anchorRect.bottom;
          }
        }
        this.style.setProperty("--hover-bridge-top-left-x", `${topLeftX}px`);
        this.style.setProperty("--hover-bridge-top-left-y", `${topLeftY}px`);
        this.style.setProperty("--hover-bridge-top-right-x", `${topRightX}px`);
        this.style.setProperty("--hover-bridge-top-right-y", `${topRightY}px`);
        this.style.setProperty("--hover-bridge-bottom-left-x", `${bottomLeftX}px`);
        this.style.setProperty("--hover-bridge-bottom-left-y", `${bottomLeftY}px`);
        this.style.setProperty("--hover-bridge-bottom-right-x", `${bottomRightX}px`);
        this.style.setProperty("--hover-bridge-bottom-right-y", `${bottomRightY}px`);
      }
    };
  }
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    this.start();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stop();
  }
  async updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("active")) {
      if (this.active) {
        this.start();
      } else {
        this.stop();
      }
    }
    if (changedProps.has("anchor")) {
      this.handleAnchorChange();
    }
    if (this.active) {
      await this.updateComplete;
      this.reposition();
    }
  }
  async handleAnchorChange() {
    await this.stop();
    if (this.anchor && typeof this.anchor === "string") {
      const root = this.getRootNode();
      this.anchorEl = root.getElementById(this.anchor);
    } else if (this.anchor instanceof Element || isVirtualElement(this.anchor)) {
      this.anchorEl = this.anchor;
    } else {
      this.anchorEl = this.querySelector('[slot="anchor"]');
    }
    if (this.anchorEl instanceof HTMLSlotElement) {
      this.anchorEl = this.anchorEl.assignedElements({ flatten: true })[0];
    }
    if (this.anchorEl) {
      this.start();
    }
  }
  start() {
    if (!this.anchorEl) {
      return;
    }
    this.cleanup = autoUpdate(this.anchorEl, this.popup, () => {
      this.reposition();
    });
  }
  async stop() {
    return new Promise((resolve) => {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = void 0;
        this.removeAttribute("data-current-placement");
        this.style.removeProperty("--auto-size-available-width");
        this.style.removeProperty("--auto-size-available-height");
        requestAnimationFrame(() => resolve());
      } else {
        resolve();
      }
    });
  }
  /** Forces the popup to recalculate and reposition itself. */
  reposition() {
    if (!this.active || !this.anchorEl) {
      return;
    }
    const middleware = [
      // The offset middleware goes first
      offset2({ mainAxis: this.distance, crossAxis: this.skidding })
    ];
    if (this.sync) {
      middleware.push(
        size2({
          apply: ({ rects }) => {
            const syncWidth = this.sync === "width" || this.sync === "both";
            const syncHeight = this.sync === "height" || this.sync === "both";
            this.popup.style.width = syncWidth ? `${rects.reference.width}px` : "";
            this.popup.style.height = syncHeight ? `${rects.reference.height}px` : "";
          }
        })
      );
    } else {
      this.popup.style.width = "";
      this.popup.style.height = "";
    }
    if (this.flip) {
      middleware.push(
        flip2({
          boundary: this.flipBoundary,
          // @ts-expect-error - We're converting a string attribute to an array here
          fallbackPlacements: this.flipFallbackPlacements,
          fallbackStrategy: this.flipFallbackStrategy === "best-fit" ? "bestFit" : "initialPlacement",
          padding: this.flipPadding
        })
      );
    }
    if (this.shift) {
      middleware.push(
        shift2({
          boundary: this.shiftBoundary,
          padding: this.shiftPadding
        })
      );
    }
    if (this.autoSize) {
      middleware.push(
        size2({
          boundary: this.autoSizeBoundary,
          padding: this.autoSizePadding,
          apply: ({ availableWidth, availableHeight }) => {
            if (this.autoSize === "vertical" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-height", `${availableHeight}px`);
            } else {
              this.style.removeProperty("--auto-size-available-height");
            }
            if (this.autoSize === "horizontal" || this.autoSize === "both") {
              this.style.setProperty("--auto-size-available-width", `${availableWidth}px`);
            } else {
              this.style.removeProperty("--auto-size-available-width");
            }
          }
        })
      );
    } else {
      this.style.removeProperty("--auto-size-available-width");
      this.style.removeProperty("--auto-size-available-height");
    }
    if (this.arrow) {
      middleware.push(
        arrow2({
          element: this.arrowEl,
          padding: this.arrowPadding
        })
      );
    }
    const getOffsetParent2 = this.strategy === "absolute" ? (element) => platform.getOffsetParent(element, t4) : platform.getOffsetParent;
    computePosition2(this.anchorEl, this.popup, {
      placement: this.placement,
      middleware,
      strategy: this.strategy,
      platform: __spreadProps(__spreadValues({}, platform), {
        getOffsetParent: getOffsetParent2
      })
    }).then(({ x: x2, y: y2, middlewareData, placement }) => {
      const isRtl = getComputedStyle(this).direction === "rtl";
      const staticSide = { top: "bottom", right: "left", bottom: "top", left: "right" }[placement.split("-")[0]];
      this.setAttribute("data-current-placement", placement);
      Object.assign(this.popup.style, {
        left: `${x2}px`,
        top: `${y2}px`
      });
      if (this.arrow) {
        const arrowX = middlewareData.arrow.x;
        const arrowY = middlewareData.arrow.y;
        let top = "";
        let right = "";
        let bottom = "";
        let left = "";
        if (this.arrowPlacement === "start") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          top = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? value : "";
          left = isRtl ? "" : value;
        } else if (this.arrowPlacement === "end") {
          const value = typeof arrowX === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
          right = isRtl ? "" : value;
          left = isRtl ? value : "";
          bottom = typeof arrowY === "number" ? `calc(${this.arrowPadding}px - var(--arrow-padding-offset))` : "";
        } else if (this.arrowPlacement === "center") {
          left = typeof arrowX === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
          top = typeof arrowY === "number" ? `calc(50% - var(--arrow-size-diagonal))` : "";
        } else {
          left = typeof arrowX === "number" ? `${arrowX}px` : "";
          top = typeof arrowY === "number" ? `${arrowY}px` : "";
        }
        Object.assign(this.arrowEl.style, {
          top,
          right,
          bottom,
          left,
          [staticSide]: "calc(var(--arrow-size-diagonal) * -1)"
        });
      }
    });
    requestAnimationFrame(() => this.updateHoverBridge());
    this.emit("sl-reposition");
  }
  render() {
    return ke`
      <slot name="anchor" @slotchange=${this.handleAnchorChange}></slot>

      <span
        part="hover-bridge"
        class=${Rt({
      "popup-hover-bridge": true,
      "popup-hover-bridge--visible": this.hoverBridge && this.active
    })}
      ></span>

      <div
        part="popup"
        class=${Rt({
      popup: true,
      "popup--active": this.active,
      "popup--fixed": this.strategy === "fixed",
      "popup--has-arrow": this.arrow
    })}
      >
        <slot></slot>
        ${this.arrow ? ke`<div part="arrow" class="popup__arrow" role="presentation"></div>` : ""}
      </div>
    `;
  }
};
SlPopup.styles = [component_styles_default, popup_styles_default];
__decorateClass2([
  e4(".popup")
], SlPopup.prototype, "popup", 2);
__decorateClass2([
  e4(".popup__arrow")
], SlPopup.prototype, "arrowEl", 2);
__decorateClass2([
  n4()
], SlPopup.prototype, "anchor", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlPopup.prototype, "active", 2);
__decorateClass2([
  n4({ reflect: true })
], SlPopup.prototype, "placement", 2);
__decorateClass2([
  n4({ reflect: true })
], SlPopup.prototype, "strategy", 2);
__decorateClass2([
  n4({ type: Number })
], SlPopup.prototype, "distance", 2);
__decorateClass2([
  n4({ type: Number })
], SlPopup.prototype, "skidding", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlPopup.prototype, "arrow", 2);
__decorateClass2([
  n4({ attribute: "arrow-placement" })
], SlPopup.prototype, "arrowPlacement", 2);
__decorateClass2([
  n4({ attribute: "arrow-padding", type: Number })
], SlPopup.prototype, "arrowPadding", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlPopup.prototype, "flip", 2);
__decorateClass2([
  n4({
    attribute: "flip-fallback-placements",
    converter: {
      fromAttribute: (value) => {
        return value.split(" ").map((p2) => p2.trim()).filter((p2) => p2 !== "");
      },
      toAttribute: (value) => {
        return value.join(" ");
      }
    }
  })
], SlPopup.prototype, "flipFallbackPlacements", 2);
__decorateClass2([
  n4({ attribute: "flip-fallback-strategy" })
], SlPopup.prototype, "flipFallbackStrategy", 2);
__decorateClass2([
  n4({ type: Object })
], SlPopup.prototype, "flipBoundary", 2);
__decorateClass2([
  n4({ attribute: "flip-padding", type: Number })
], SlPopup.prototype, "flipPadding", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlPopup.prototype, "shift", 2);
__decorateClass2([
  n4({ type: Object })
], SlPopup.prototype, "shiftBoundary", 2);
__decorateClass2([
  n4({ attribute: "shift-padding", type: Number })
], SlPopup.prototype, "shiftPadding", 2);
__decorateClass2([
  n4({ attribute: "auto-size" })
], SlPopup.prototype, "autoSize", 2);
__decorateClass2([
  n4()
], SlPopup.prototype, "sync", 2);
__decorateClass2([
  n4({ type: Object })
], SlPopup.prototype, "autoSizeBoundary", 2);
__decorateClass2([
  n4({ attribute: "auto-size-padding", type: Number })
], SlPopup.prototype, "autoSizePadding", 2);
__decorateClass2([
  n4({ attribute: "hover-bridge", type: Boolean })
], SlPopup.prototype, "hoverBridge", 2);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DL5222VR.js
var formCollections = /* @__PURE__ */ new WeakMap();
var reportValidityOverloads = /* @__PURE__ */ new WeakMap();
var checkValidityOverloads = /* @__PURE__ */ new WeakMap();
var userInteractedControls = /* @__PURE__ */ new WeakSet();
var interactions = /* @__PURE__ */ new WeakMap();
var FormControlController = class {
  constructor(host, options) {
    this.handleFormData = (event) => {
      const disabled = this.options.disabled(this.host);
      const name = this.options.name(this.host);
      const value = this.options.value(this.host);
      const isButton = this.host.tagName.toLowerCase() === "sl-button";
      if (this.host.isConnected && !disabled && !isButton && typeof name === "string" && name.length > 0 && typeof value !== "undefined") {
        if (Array.isArray(value)) {
          value.forEach((val) => {
            event.formData.append(name, val.toString());
          });
        } else {
          event.formData.append(name, value.toString());
        }
      }
    };
    this.handleFormSubmit = (event) => {
      var _a;
      const disabled = this.options.disabled(this.host);
      const reportValidity = this.options.reportValidity;
      if (this.form && !this.form.noValidate) {
        (_a = formCollections.get(this.form)) == null ? void 0 : _a.forEach((control) => {
          this.setUserInteracted(control, true);
        });
      }
      if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
    this.handleFormReset = () => {
      this.options.setValue(this.host, this.options.defaultValue(this.host));
      this.setUserInteracted(this.host, false);
      interactions.set(this.host, []);
    };
    this.handleInteraction = (event) => {
      const emittedEvents = interactions.get(this.host);
      if (!emittedEvents.includes(event.type)) {
        emittedEvents.push(event.type);
      }
      if (emittedEvents.length === this.options.assumeInteractionOn.length) {
        this.setUserInteracted(this.host, true);
      }
    };
    this.checkFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.checkValidity === "function") {
            if (!element.checkValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    this.reportFormValidity = () => {
      if (this.form && !this.form.noValidate) {
        const elements = this.form.querySelectorAll("*");
        for (const element of elements) {
          if (typeof element.reportValidity === "function") {
            if (!element.reportValidity()) {
              return false;
            }
          }
        }
      }
      return true;
    };
    (this.host = host).addController(this);
    this.options = __spreadValues({
      form: (input) => {
        const formId = input.form;
        if (formId) {
          const root = input.getRootNode();
          const form = root.getElementById(formId);
          if (form) {
            return form;
          }
        }
        return input.closest("form");
      },
      name: (input) => input.name,
      value: (input) => input.value,
      defaultValue: (input) => input.defaultValue,
      disabled: (input) => {
        var _a;
        return (_a = input.disabled) != null ? _a : false;
      },
      reportValidity: (input) => typeof input.reportValidity === "function" ? input.reportValidity() : true,
      checkValidity: (input) => typeof input.checkValidity === "function" ? input.checkValidity() : true,
      setValue: (input, value) => input.value = value,
      assumeInteractionOn: ["sl-input"]
    }, options);
  }
  hostConnected() {
    const form = this.options.form(this.host);
    if (form) {
      this.attachForm(form);
    }
    interactions.set(this.host, []);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.addEventListener(event, this.handleInteraction);
    });
  }
  hostDisconnected() {
    this.detachForm();
    interactions.delete(this.host);
    this.options.assumeInteractionOn.forEach((event) => {
      this.host.removeEventListener(event, this.handleInteraction);
    });
  }
  hostUpdated() {
    const form = this.options.form(this.host);
    if (!form) {
      this.detachForm();
    }
    if (form && this.form !== form) {
      this.detachForm();
      this.attachForm(form);
    }
    if (this.host.hasUpdated) {
      this.setValidity(this.host.validity.valid);
    }
  }
  attachForm(form) {
    if (form) {
      this.form = form;
      if (formCollections.has(this.form)) {
        formCollections.get(this.form).add(this.host);
      } else {
        formCollections.set(this.form, /* @__PURE__ */ new Set([this.host]));
      }
      this.form.addEventListener("formdata", this.handleFormData);
      this.form.addEventListener("submit", this.handleFormSubmit);
      this.form.addEventListener("reset", this.handleFormReset);
      if (!reportValidityOverloads.has(this.form)) {
        reportValidityOverloads.set(this.form, this.form.reportValidity);
        this.form.reportValidity = () => this.reportFormValidity();
      }
      if (!checkValidityOverloads.has(this.form)) {
        checkValidityOverloads.set(this.form, this.form.checkValidity);
        this.form.checkValidity = () => this.checkFormValidity();
      }
    } else {
      this.form = void 0;
    }
  }
  detachForm() {
    if (!this.form)
      return;
    const formCollection = formCollections.get(this.form);
    if (!formCollection) {
      return;
    }
    formCollection.delete(this.host);
    if (formCollection.size <= 0) {
      this.form.removeEventListener("formdata", this.handleFormData);
      this.form.removeEventListener("submit", this.handleFormSubmit);
      this.form.removeEventListener("reset", this.handleFormReset);
      if (reportValidityOverloads.has(this.form)) {
        this.form.reportValidity = reportValidityOverloads.get(this.form);
        reportValidityOverloads.delete(this.form);
      }
      if (checkValidityOverloads.has(this.form)) {
        this.form.checkValidity = checkValidityOverloads.get(this.form);
        checkValidityOverloads.delete(this.form);
      }
      this.form = void 0;
    }
  }
  setUserInteracted(el, hasInteracted) {
    if (hasInteracted) {
      userInteractedControls.add(el);
    } else {
      userInteractedControls.delete(el);
    }
    el.requestUpdate();
  }
  doAction(type, submitter) {
    if (this.form) {
      const button = document.createElement("button");
      button.type = type;
      button.style.position = "absolute";
      button.style.width = "0";
      button.style.height = "0";
      button.style.clipPath = "inset(50%)";
      button.style.overflow = "hidden";
      button.style.whiteSpace = "nowrap";
      if (submitter) {
        button.name = submitter.name;
        button.value = submitter.value;
        ["formaction", "formenctype", "formmethod", "formnovalidate", "formtarget"].forEach((attr) => {
          if (submitter.hasAttribute(attr)) {
            button.setAttribute(attr, submitter.getAttribute(attr));
          }
        });
      }
      this.form.append(button);
      button.click();
      button.remove();
    }
  }
  /** Returns the associated `<form>` element, if one exists. */
  getForm() {
    var _a;
    return (_a = this.form) != null ? _a : null;
  }
  /** Resets the form, restoring all the control to their default value */
  reset(submitter) {
    this.doAction("reset", submitter);
  }
  /** Submits the form, triggering validation and form data injection. */
  submit(submitter) {
    this.doAction("submit", submitter);
  }
  /**
   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update
   * the host element immediately, i.e. before Lit updates the component in the next update.
   */
  setValidity(isValid) {
    const host = this.host;
    const hasInteracted = Boolean(userInteractedControls.has(host));
    const required = Boolean(host.required);
    host.toggleAttribute("data-required", required);
    host.toggleAttribute("data-optional", !required);
    host.toggleAttribute("data-invalid", !isValid);
    host.toggleAttribute("data-valid", isValid);
    host.toggleAttribute("data-user-invalid", !isValid && hasInteracted);
    host.toggleAttribute("data-user-valid", isValid && hasInteracted);
  }
  /**
   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything
   * that affects constraint validation changes so the component receives the correct validity states.
   */
  updateValidity() {
    const host = this.host;
    this.setValidity(host.validity.valid);
  }
  /**
   * Dispatches a non-bubbling, cancelable custom event of type `sl-invalid`.
   * If the `sl-invalid` event will be cancelled then the original `invalid`
   * event (which may have been passed as argument) will also be cancelled.
   * If no original `invalid` event has been passed then the `sl-invalid`
   * event will be cancelled before being dispatched.
   */
  emitInvalidEvent(originalInvalidEvent) {
    const slInvalidEvent = new CustomEvent("sl-invalid", {
      bubbles: false,
      composed: false,
      cancelable: true,
      detail: {}
    });
    if (!originalInvalidEvent) {
      slInvalidEvent.preventDefault();
    }
    if (!this.host.dispatchEvent(slInvalidEvent)) {
      originalInvalidEvent == null ? void 0 : originalInvalidEvent.preventDefault();
    }
  }
};
var validValidityState = Object.freeze({
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: true,
  valueMissing: false
});
var valueMissingValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  valueMissing: true
}));
var customErrorValidityState = Object.freeze(__spreadProps(__spreadValues({}, validValidityState), {
  valid: false,
  customError: true
}));

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.DHU6MIVB.js
var defaultAnimationRegistry = /* @__PURE__ */ new Map();
var customAnimationRegistry = /* @__PURE__ */ new WeakMap();
function ensureAnimation(animation) {
  return animation != null ? animation : { keyframes: [], options: { duration: 0 } };
}
function getLogicalAnimation(animation, dir) {
  if (dir.toLowerCase() === "rtl") {
    return {
      keyframes: animation.rtlKeyframes || animation.keyframes,
      options: animation.options
    };
  }
  return animation;
}
function setDefaultAnimation(animationName, animation) {
  defaultAnimationRegistry.set(animationName, ensureAnimation(animation));
}
function getAnimation(el, animationName, options) {
  const customAnimation = customAnimationRegistry.get(el);
  if (customAnimation == null ? void 0 : customAnimation[animationName]) {
    return getLogicalAnimation(customAnimation[animationName], options.dir);
  }
  const defaultAnimation = defaultAnimationRegistry.get(animationName);
  if (defaultAnimation) {
    return getLogicalAnimation(defaultAnimation, options.dir);
  }
  return {
    keyframes: [],
    options: { duration: 0 }
  };
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.B4BZKR24.js
function waitForEvent(el, eventName) {
  return new Promise((resolve) => {
    function done(event) {
      if (event.target === el) {
        el.removeEventListener(eventName, done);
        resolve();
      }
    }
    el.addEventListener(eventName, done);
  });
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.LHI6QEL2.js
function animateTo(el, keyframes, options) {
  return new Promise((resolve) => {
    if ((options == null ? void 0 : options.duration) === Infinity) {
      throw new Error("Promise-based animations must be finite.");
    }
    const animation = el.animate(keyframes, __spreadProps(__spreadValues({}, options), {
      duration: prefersReducedMotion() ? 0 : options.duration
    }));
    animation.addEventListener("cancel", resolve, { once: true });
    animation.addEventListener("finish", resolve, { once: true });
  });
}
function prefersReducedMotion() {
  const query = window.matchMedia("(prefers-reduced-motion: reduce)");
  return query.matches;
}
function stopAnimations(el) {
  return Promise.all(
    el.getAnimations().map((animation) => {
      return new Promise((resolve) => {
        animation.cancel();
        requestAnimationFrame(resolve);
      });
    })
  );
}

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.NYIIDP5N.js
var HasSlotController = class {
  constructor(host, ...slotNames) {
    this.slotNames = [];
    this.handleSlotChange = (event) => {
      const slot = event.target;
      if (this.slotNames.includes("[default]") && !slot.name || slot.name && this.slotNames.includes(slot.name)) {
        this.host.requestUpdate();
      }
    };
    (this.host = host).addController(this);
    this.slotNames = slotNames;
  }
  hasDefaultSlot() {
    return [...this.host.childNodes].some((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== "") {
        return true;
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        const el = node;
        const tagName = el.tagName.toLowerCase();
        if (tagName === "sl-visually-hidden") {
          return false;
        }
        if (!el.hasAttribute("slot")) {
          return true;
        }
      }
      return false;
    });
  }
  hasNamedSlot(name) {
    return this.host.querySelector(`:scope > [slot="${name}"]`) !== null;
  }
  test(slotName) {
    return slotName === "[default]" ? this.hasDefaultSlot() : this.hasNamedSlot(slotName);
  }
  hostConnected() {
    this.host.shadowRoot.addEventListener("slotchange", this.handleSlotChange);
  }
  hostDisconnected() {
    this.host.shadowRoot.removeEventListener("slotchange", this.handleSlotChange);
  }
};

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/directives/unsafe-html.js
var le = class extends i3 {
  constructor(i4) {
    if (super(i4), this.it = D, i4.type !== t3.CHILD)
      throw Error(this.constructor.directiveName + "() can only be used in child bindings");
  }
  render(t5) {
    if (t5 === D || null == t5)
      return this._t = void 0, this.it = t5;
    if (t5 === R)
      return t5;
    if ("string" != typeof t5)
      throw Error(this.constructor.directiveName + "() called with a non-string value");
    if (t5 === this.it)
      return this._t;
    this.it = t5;
    const i4 = [t5];
    return i4.raw = i4, this._t = { _$litType$: this.constructor.resultType, strings: i4, values: [] };
  }
};
le.directiveName = "unsafeHTML", le.resultType = 1;
var ae = e5(le);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.44XN5ATB.js
var SlSelect = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.typeToSelectString = "";
    this.hasFocus = false;
    this.displayLabel = "";
    this.selectedOptions = [];
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.placeholder = "";
    this.multiple = false;
    this.maxOptionsVisible = 3;
    this.disabled = false;
    this.clearable = false;
    this.open = false;
    this.hoist = false;
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.placement = "bottom";
    this.helpText = "";
    this.form = "";
    this.required = false;
    this.getTag = (option) => {
      return ke`
      <sl-tag
        part="tag"
        exportparts="
              base:tag__base,
              content:tag__content,
              remove-button:tag__remove-button,
              remove-button__base:tag__remove-button__base
            "
        ?pill=${this.pill}
        size=${this.size}
        removable
        @sl-remove=${(event) => this.handleTagRemove(event, option)}
      >
        ${option.getTextLabel()}
      </sl-tag>
    `;
    };
    this.handleDocumentFocusIn = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
    this.handleDocumentKeyDown = (event) => {
      const target = event.target;
      const isClearButton = target.closest(".select__clear") !== null;
      const isIconButton = target.closest("sl-icon-button") !== null;
      if (isClearButton || isIconButton) {
        return;
      }
      if (event.key === "Escape" && this.open && !this.closeWatcher) {
        event.preventDefault();
        event.stopPropagation();
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
      if (event.key === "Enter" || event.key === " " && this.typeToSelectString === "") {
        event.preventDefault();
        event.stopImmediatePropagation();
        if (!this.open) {
          this.show();
          return;
        }
        if (this.currentOption && !this.currentOption.disabled) {
          if (this.multiple) {
            this.toggleOptionSelection(this.currentOption);
          } else {
            this.setSelectedOptions(this.currentOption);
          }
          this.updateComplete.then(() => {
            this.emit("sl-input");
            this.emit("sl-change");
          });
          if (!this.multiple) {
            this.hide();
            this.displayInput.focus({ preventScroll: true });
          }
        }
        return;
      }
      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
        const allOptions = this.getAllOptions();
        const currentIndex = allOptions.indexOf(this.currentOption);
        let newIndex = Math.max(0, currentIndex);
        event.preventDefault();
        if (!this.open) {
          this.show();
          if (this.currentOption) {
            return;
          }
        }
        if (event.key === "ArrowDown") {
          newIndex = currentIndex + 1;
          if (newIndex > allOptions.length - 1)
            newIndex = 0;
        } else if (event.key === "ArrowUp") {
          newIndex = currentIndex - 1;
          if (newIndex < 0)
            newIndex = allOptions.length - 1;
        } else if (event.key === "Home") {
          newIndex = 0;
        } else if (event.key === "End") {
          newIndex = allOptions.length - 1;
        }
        this.setCurrentOption(allOptions[newIndex]);
      }
      if (event.key.length === 1 || event.key === "Backspace") {
        const allOptions = this.getAllOptions();
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }
        if (!this.open) {
          if (event.key === "Backspace") {
            return;
          }
          this.show();
        }
        event.stopPropagation();
        event.preventDefault();
        clearTimeout(this.typeToSelectTimeout);
        this.typeToSelectTimeout = window.setTimeout(() => this.typeToSelectString = "", 1e3);
        if (event.key === "Backspace") {
          this.typeToSelectString = this.typeToSelectString.slice(0, -1);
        } else {
          this.typeToSelectString += event.key.toLowerCase();
        }
        for (const option of allOptions) {
          const label = option.getTextLabel().toLowerCase();
          if (label.startsWith(this.typeToSelectString)) {
            this.setCurrentOption(option);
            break;
          }
        }
      }
    };
    this.handleDocumentMouseDown = (event) => {
      const path = event.composedPath();
      if (this && !path.includes(this)) {
        this.hide();
      }
    };
  }
  /** Gets the validity state object */
  get validity() {
    return this.valueInput.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.valueInput.validationMessage;
  }
  connectedCallback() {
    super.connectedCallback();
    this.open = false;
  }
  addOpenListeners() {
    var _a;
    const root = this.getRootNode();
    if ("CloseWatcher" in window) {
      (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
      this.closeWatcher = new CloseWatcher();
      this.closeWatcher.onclose = () => {
        if (this.open) {
          this.hide();
          this.displayInput.focus({ preventScroll: true });
        }
      };
    }
    root.addEventListener("focusin", this.handleDocumentFocusIn);
    root.addEventListener("keydown", this.handleDocumentKeyDown);
    root.addEventListener("mousedown", this.handleDocumentMouseDown);
  }
  removeOpenListeners() {
    var _a;
    const root = this.getRootNode();
    root.removeEventListener("focusin", this.handleDocumentFocusIn);
    root.removeEventListener("keydown", this.handleDocumentKeyDown);
    root.removeEventListener("mousedown", this.handleDocumentMouseDown);
    (_a = this.closeWatcher) == null ? void 0 : _a.destroy();
  }
  handleFocus() {
    this.hasFocus = true;
    this.displayInput.setSelectionRange(0, 0);
    this.emit("sl-focus");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleLabelClick() {
    this.displayInput.focus();
  }
  handleComboboxMouseDown(event) {
    const path = event.composedPath();
    const isIconButton = path.some((el) => el instanceof Element && el.tagName.toLowerCase() === "sl-icon-button");
    if (this.disabled || isIconButton) {
      return;
    }
    event.preventDefault();
    this.displayInput.focus({ preventScroll: true });
    this.open = !this.open;
  }
  handleComboboxKeyDown(event) {
    if (event.key === "Tab") {
      return;
    }
    event.stopPropagation();
    this.handleDocumentKeyDown(event);
  }
  handleClearClick(event) {
    event.stopPropagation();
    if (this.value !== "") {
      this.setSelectedOptions([]);
      this.displayInput.focus({ preventScroll: true });
      this.updateComplete.then(() => {
        this.emit("sl-clear");
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  handleClearMouseDown(event) {
    event.stopPropagation();
    event.preventDefault();
  }
  handleOptionClick(event) {
    const target = event.target;
    const option = target.closest("sl-option");
    const oldValue = this.value;
    if (option && !option.disabled) {
      if (this.multiple) {
        this.toggleOptionSelection(option);
      } else {
        this.setSelectedOptions(option);
      }
      this.updateComplete.then(() => this.displayInput.focus({ preventScroll: true }));
      if (this.value !== oldValue) {
        this.updateComplete.then(() => {
          this.emit("sl-input");
          this.emit("sl-change");
        });
      }
      if (!this.multiple) {
        this.hide();
        this.displayInput.focus({ preventScroll: true });
      }
    }
  }
  handleDefaultSlotChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    const values = [];
    if (customElements.get("sl-option")) {
      allOptions.forEach((option) => values.push(option.value));
      this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
    } else {
      customElements.whenDefined("sl-option").then(() => this.handleDefaultSlotChange());
    }
  }
  handleTagRemove(event, option) {
    event.stopPropagation();
    if (!this.disabled) {
      this.toggleOptionSelection(option, false);
      this.updateComplete.then(() => {
        this.emit("sl-input");
        this.emit("sl-change");
      });
    }
  }
  // Gets an array of all <sl-option> elements
  getAllOptions() {
    return [...this.querySelectorAll("sl-option")];
  }
  // Gets the first <sl-option> element
  getFirstOption() {
    return this.querySelector("sl-option");
  }
  // Sets the current option, which is the option the user is currently interacting with (e.g. via keyboard). Only one
  // option may be "current" at a time.
  setCurrentOption(option) {
    const allOptions = this.getAllOptions();
    allOptions.forEach((el) => {
      el.current = false;
      el.tabIndex = -1;
    });
    if (option) {
      this.currentOption = option;
      option.current = true;
      option.tabIndex = 0;
      option.focus();
    }
  }
  // Sets the selected option(s)
  setSelectedOptions(option) {
    const allOptions = this.getAllOptions();
    const newSelectedOptions = Array.isArray(option) ? option : [option];
    allOptions.forEach((el) => el.selected = false);
    if (newSelectedOptions.length) {
      newSelectedOptions.forEach((el) => el.selected = true);
    }
    this.selectionChanged();
  }
  // Toggles an option's selected state
  toggleOptionSelection(option, force) {
    if (force === true || force === false) {
      option.selected = force;
    } else {
      option.selected = !option.selected;
    }
    this.selectionChanged();
  }
  // This method must be called whenever the selection changes. It will update the selected options cache, the current
  // value, and the display value
  selectionChanged() {
    var _a, _b, _c, _d;
    this.selectedOptions = this.getAllOptions().filter((el) => el.selected);
    if (this.multiple) {
      this.value = this.selectedOptions.map((el) => el.value);
      if (this.placeholder && this.value.length === 0) {
        this.displayLabel = "";
      } else {
        this.displayLabel = this.localize.term("numOptionsSelected", this.selectedOptions.length);
      }
    } else {
      this.value = (_b = (_a = this.selectedOptions[0]) == null ? void 0 : _a.value) != null ? _b : "";
      this.displayLabel = (_d = (_c = this.selectedOptions[0]) == null ? void 0 : _c.getTextLabel()) != null ? _d : "";
    }
    this.updateComplete.then(() => {
      this.formControlController.updateValidity();
    });
  }
  get tags() {
    return this.selectedOptions.map((option, index2) => {
      if (index2 < this.maxOptionsVisible || this.maxOptionsVisible <= 0) {
        const tag2 = this.getTag(option, index2);
        return ke`<div @sl-remove=${(e6) => this.handleTagRemove(e6, option)}>
          ${typeof tag2 === "string" ? ae(tag2) : tag2}
        </div>`;
      } else if (index2 === this.maxOptionsVisible) {
        return ke`<sl-tag>+${this.selectedOptions.length - index2}</sl-tag>`;
      }
      return ke``;
    });
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleDisabledChange() {
    if (this.disabled) {
      this.open = false;
      this.handleOpenChange();
    }
  }
  handleValueChange() {
    const allOptions = this.getAllOptions();
    const value = Array.isArray(this.value) ? this.value : [this.value];
    this.setSelectedOptions(allOptions.filter((el) => value.includes(el.value)));
  }
  async handleOpenChange() {
    if (this.open && !this.disabled) {
      this.setCurrentOption(this.selectedOptions[0] || this.getFirstOption());
      this.emit("sl-show");
      this.addOpenListeners();
      await stopAnimations(this);
      this.listbox.hidden = false;
      this.popup.active = true;
      requestAnimationFrame(() => {
        this.setCurrentOption(this.currentOption);
      });
      const { keyframes, options } = getAnimation(this, "select.show", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      if (this.currentOption) {
        scrollIntoView(this.currentOption, this.listbox, "vertical", "auto");
      }
      this.emit("sl-after-show");
    } else {
      this.emit("sl-hide");
      this.removeOpenListeners();
      await stopAnimations(this);
      const { keyframes, options } = getAnimation(this, "select.hide", { dir: this.localize.dir() });
      await animateTo(this.popup.popup, keyframes, options);
      this.listbox.hidden = true;
      this.popup.active = false;
      this.emit("sl-after-hide");
    }
  }
  /** Shows the listbox. */
  async show() {
    if (this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = true;
    return waitForEvent(this, "sl-after-show");
  }
  /** Hides the listbox. */
  async hide() {
    if (!this.open || this.disabled) {
      this.open = false;
      return void 0;
    }
    this.open = false;
    return waitForEvent(this, "sl-after-hide");
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.valueInput.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.valueInput.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.valueInput.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  /** Sets focus on the control. */
  focus(options) {
    this.displayInput.focus(options);
  }
  /** Removes focus from the control. */
  blur() {
    this.displayInput.blur();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && this.value.length > 0;
    const isPlaceholderVisible = this.placeholder && this.value.length === 0;
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          id="label"
          part="form-control-label"
          class="form-control__label"
          aria-hidden=${hasLabel ? "false" : "true"}
          @click=${this.handleLabelClick}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <sl-popup
            class=${Rt({
      select: true,
      "select--standard": true,
      "select--filled": this.filled,
      "select--pill": this.pill,
      "select--open": this.open,
      "select--disabled": this.disabled,
      "select--multiple": this.multiple,
      "select--focused": this.hasFocus,
      "select--placeholder-visible": isPlaceholderVisible,
      "select--top": this.placement === "top",
      "select--bottom": this.placement === "bottom",
      "select--small": this.size === "small",
      "select--medium": this.size === "medium",
      "select--large": this.size === "large"
    })}
            placement=${this.placement}
            strategy=${this.hoist ? "fixed" : "absolute"}
            flip
            shift
            sync="width"
            auto-size="vertical"
            auto-size-padding="10"
          >
            <div
              part="combobox"
              class="select__combobox"
              slot="anchor"
              @keydown=${this.handleComboboxKeyDown}
              @mousedown=${this.handleComboboxMouseDown}
            >
              <slot part="prefix" name="prefix" class="select__prefix"></slot>

              <input
                part="display-input"
                class="select__display-input"
                type="text"
                placeholder=${this.placeholder}
                .disabled=${this.disabled}
                .value=${this.displayLabel}
                autocomplete="off"
                spellcheck="false"
                autocapitalize="off"
                readonly
                aria-controls="listbox"
                aria-expanded=${this.open ? "true" : "false"}
                aria-haspopup="listbox"
                aria-labelledby="label"
                aria-disabled=${this.disabled ? "true" : "false"}
                aria-describedby="help-text"
                role="combobox"
                tabindex="0"
                @focus=${this.handleFocus}
                @blur=${this.handleBlur}
              />

              ${this.multiple ? ke`<div part="tags" class="select__tags">${this.tags}</div>` : ""}

              <input
                class="select__value-input"
                type="text"
                ?disabled=${this.disabled}
                ?required=${this.required}
                .value=${Array.isArray(this.value) ? this.value.join(", ") : this.value}
                tabindex="-1"
                aria-hidden="true"
                @focus=${() => this.focus()}
                @invalid=${this.handleInvalid}
              />

              ${hasClearIcon ? ke`
                    <button
                      part="clear-button"
                      class="select__clear"
                      type="button"
                      aria-label=${this.localize.term("clearEntry")}
                      @mousedown=${this.handleClearMouseDown}
                      @click=${this.handleClearClick}
                      tabindex="-1"
                    >
                      <slot name="clear-icon">
                        <sl-icon name="x-circle-fill" library="system"></sl-icon>
                      </slot>
                    </button>
                  ` : ""}

              <slot name="expand-icon" part="expand-icon" class="select__expand-icon">
                <sl-icon library="system" name="chevron-down"></sl-icon>
              </slot>
            </div>

            <div
              id="listbox"
              role="listbox"
              aria-expanded=${this.open ? "true" : "false"}
              aria-multiselectable=${this.multiple ? "true" : "false"}
              aria-labelledby="label"
              part="listbox"
              class="select__listbox"
              tabindex="-1"
              @mouseup=${this.handleOptionClick}
              @slotchange=${this.handleDefaultSlotChange}
            >
              <slot></slot>
            </div>
          </sl-popup>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlSelect.styles = [component_styles_default, form_control_styles_default, select_styles_default];
SlSelect.dependencies = {
  "sl-icon": SlIcon,
  "sl-popup": SlPopup,
  "sl-tag": SlTag
};
__decorateClass2([
  e4(".select")
], SlSelect.prototype, "popup", 2);
__decorateClass2([
  e4(".select__combobox")
], SlSelect.prototype, "combobox", 2);
__decorateClass2([
  e4(".select__display-input")
], SlSelect.prototype, "displayInput", 2);
__decorateClass2([
  e4(".select__value-input")
], SlSelect.prototype, "valueInput", 2);
__decorateClass2([
  e4(".select__listbox")
], SlSelect.prototype, "listbox", 2);
__decorateClass2([
  r4()
], SlSelect.prototype, "hasFocus", 2);
__decorateClass2([
  r4()
], SlSelect.prototype, "displayLabel", 2);
__decorateClass2([
  r4()
], SlSelect.prototype, "currentOption", 2);
__decorateClass2([
  r4()
], SlSelect.prototype, "selectedOptions", 2);
__decorateClass2([
  n4()
], SlSelect.prototype, "name", 2);
__decorateClass2([
  n4({
    converter: {
      fromAttribute: (value) => value.split(" "),
      toAttribute: (value) => value.join(" ")
    }
  })
], SlSelect.prototype, "value", 2);
__decorateClass2([
  defaultValue()
], SlSelect.prototype, "defaultValue", 2);
__decorateClass2([
  n4({ reflect: true })
], SlSelect.prototype, "size", 2);
__decorateClass2([
  n4()
], SlSelect.prototype, "placeholder", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "multiple", 2);
__decorateClass2([
  n4({ attribute: "max-options-visible", type: Number })
], SlSelect.prototype, "maxOptionsVisible", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "disabled", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlSelect.prototype, "clearable", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "open", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlSelect.prototype, "hoist", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "filled", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "pill", 2);
__decorateClass2([
  n4()
], SlSelect.prototype, "label", 2);
__decorateClass2([
  n4({ reflect: true })
], SlSelect.prototype, "placement", 2);
__decorateClass2([
  n4({ attribute: "help-text" })
], SlSelect.prototype, "helpText", 2);
__decorateClass2([
  n4({ reflect: true })
], SlSelect.prototype, "form", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlSelect.prototype, "required", 2);
__decorateClass2([
  n4()
], SlSelect.prototype, "getTag", 2);
__decorateClass2([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleDisabledChange", 1);
__decorateClass2([
  watch("value", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleValueChange", 1);
__decorateClass2([
  watch("open", { waitUntilFirstUpdate: true })
], SlSelect.prototype, "handleOpenChange", 1);
setDefaultAnimation("select.show", {
  keyframes: [
    { opacity: 0, scale: 0.9 },
    { opacity: 1, scale: 1 }
  ],
  options: { duration: 100, easing: "ease" }
});
setDefaultAnimation("select.hide", {
  keyframes: [
    { opacity: 1, scale: 1 },
    { opacity: 0, scale: 0.9 }
  ],
  options: { duration: 100, easing: "ease" }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FXXKMG2P.js
var option_styles_default = i`
  :host {
    display: block;
    user-select: none;
    -webkit-user-select: none;
  }

  :host(:focus) {
    outline: none;
  }

  .option {
    position: relative;
    display: flex;
    align-items: center;
    font-family: var(--sl-font-sans);
    font-size: var(--sl-font-size-medium);
    font-weight: var(--sl-font-weight-normal);
    line-height: var(--sl-line-height-normal);
    letter-spacing: var(--sl-letter-spacing-normal);
    color: var(--sl-color-neutral-700);
    padding: var(--sl-spacing-x-small) var(--sl-spacing-medium) var(--sl-spacing-x-small) var(--sl-spacing-x-small);
    transition: var(--sl-transition-fast) fill;
    cursor: pointer;
  }

  .option--hover:not(.option--current):not(.option--disabled) {
    background-color: var(--sl-color-neutral-100);
    color: var(--sl-color-neutral-1000);
  }

  .option--current,
  .option--current.option--disabled {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
    opacity: 1;
  }

  .option--disabled {
    outline: none;
    opacity: 0.5;
    cursor: not-allowed;
  }

  .option__label {
    flex: 1 1 auto;
    display: inline-block;
    line-height: var(--sl-line-height-dense);
  }

  .option .option__check {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    visibility: hidden;
    padding-inline-end: var(--sl-spacing-2x-small);
  }

  .option--selected .option__check {
    visibility: visible;
  }

  .option__prefix,
  .option__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
  }

  .option__prefix::slotted(*) {
    margin-inline-end: var(--sl-spacing-x-small);
  }

  .option__suffix::slotted(*) {
    margin-inline-start: var(--sl-spacing-x-small);
  }

  @media (forced-colors: active) {
    :host(:hover:not([aria-disabled='true'])) .option {
      outline: dashed 1px SelectedItem;
      outline-offset: -1px;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.KWDN2DUL.js
var SlOption = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
    this.current = false;
    this.selected = false;
    this.hasHover = false;
    this.value = "";
    this.disabled = false;
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "option");
    this.setAttribute("aria-selected", "false");
  }
  handleDefaultSlotChange() {
    const textLabel = this.getTextLabel();
    if (typeof this.cachedTextLabel === "undefined") {
      this.cachedTextLabel = textLabel;
      return;
    }
    if (textLabel !== this.cachedTextLabel) {
      this.cachedTextLabel = textLabel;
      this.emit("slotchange", { bubbles: true, composed: false, cancelable: false });
    }
  }
  handleMouseEnter() {
    this.hasHover = true;
  }
  handleMouseLeave() {
    this.hasHover = false;
  }
  handleDisabledChange() {
    this.setAttribute("aria-disabled", this.disabled ? "true" : "false");
  }
  handleSelectedChange() {
    this.setAttribute("aria-selected", this.selected ? "true" : "false");
  }
  handleValueChange() {
    if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    if (this.value.includes(" ")) {
      console.error(`Option values cannot include a space. All spaces have been replaced with underscores.`, this);
      this.value = this.value.replace(/ /g, "_");
    }
  }
  /** Returns a plain text label based on the option's content. */
  getTextLabel() {
    const nodes = this.childNodes;
    let label = "";
    [...nodes].forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!node.hasAttribute("slot")) {
          label += node.textContent;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        label += node.textContent;
      }
    });
    return label.trim();
  }
  render() {
    return ke`
      <div
        part="base"
        class=${Rt({
      option: true,
      "option--current": this.current,
      "option--disabled": this.disabled,
      "option--selected": this.selected,
      "option--hover": this.hasHover
    })}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
      >
        <sl-icon part="checked-icon" class="option__check" name="check" library="system" aria-hidden="true"></sl-icon>
        <slot part="prefix" name="prefix" class="option__prefix"></slot>
        <slot part="label" class="option__label" @slotchange=${this.handleDefaultSlotChange}></slot>
        <slot part="suffix" name="suffix" class="option__suffix"></slot>
      </div>
    `;
  }
};
SlOption.styles = [component_styles_default, option_styles_default];
SlOption.dependencies = { "sl-icon": SlIcon };
__decorateClass2([
  e4(".option__label")
], SlOption.prototype, "defaultSlot", 2);
__decorateClass2([
  r4()
], SlOption.prototype, "current", 2);
__decorateClass2([
  r4()
], SlOption.prototype, "selected", 2);
__decorateClass2([
  r4()
], SlOption.prototype, "hasHover", 2);
__decorateClass2([
  n4({ reflect: true })
], SlOption.prototype, "value", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlOption.prototype, "disabled", 2);
__decorateClass2([
  watch("disabled")
], SlOption.prototype, "handleDisabledChange", 1);
__decorateClass2([
  watch("selected")
], SlOption.prototype, "handleSelectedChange", 1);
__decorateClass2([
  watch("value")
], SlOption.prototype, "handleValueChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.OZYH3LSG.js
var input_styles_default = i`
  :host {
    display: block;
  }

  .input {
    flex: 1 1 auto;
    display: inline-flex;
    align-items: stretch;
    justify-content: start;
    position: relative;
    width: 100%;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    letter-spacing: var(--sl-input-letter-spacing);
    vertical-align: middle;
    overflow: hidden;
    cursor: text;
    transition:
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) border,
      var(--sl-transition-fast) box-shadow,
      var(--sl-transition-fast) background-color;
  }

  /* Standard inputs */
  .input--standard {
    background-color: var(--sl-input-background-color);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
  }

  .input--standard:hover:not(.input--disabled) {
    background-color: var(--sl-input-background-color-hover);
    border-color: var(--sl-input-border-color-hover);
  }

  .input--standard.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-background-color-focus);
    border-color: var(--sl-input-border-color-focus);
    box-shadow: 0 0 0 var(--sl-focus-ring-width) var(--sl-input-focus-ring-color);
  }

  .input--standard.input--focused:not(.input--disabled) .input__control {
    color: var(--sl-input-color-focus);
  }

  .input--standard.input--disabled {
    background-color: var(--sl-input-background-color-disabled);
    border-color: var(--sl-input-border-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input--standard.input--disabled .input__control {
    color: var(--sl-input-color-disabled);
  }

  .input--standard.input--disabled .input__control::placeholder {
    color: var(--sl-input-placeholder-color-disabled);
  }

  /* Filled inputs */
  .input--filled {
    border: none;
    background-color: var(--sl-input-filled-background-color);
    color: var(--sl-input-color);
  }

  .input--filled:hover:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-hover);
  }

  .input--filled.input--focused:not(.input--disabled) {
    background-color: var(--sl-input-filled-background-color-focus);
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .input--filled.input--disabled {
    background-color: var(--sl-input-filled-background-color-disabled);
    opacity: 0.5;
    cursor: not-allowed;
  }

  .input__control {
    flex: 1 1 auto;
    font-family: inherit;
    font-size: inherit;
    font-weight: inherit;
    min-width: 0;
    height: 100%;
    color: var(--sl-input-color);
    border: none;
    background: inherit;
    box-shadow: none;
    padding: 0;
    margin: 0;
    cursor: inherit;
    -webkit-appearance: none;
  }

  .input__control::-webkit-search-decoration,
  .input__control::-webkit-search-cancel-button,
  .input__control::-webkit-search-results-button,
  .input__control::-webkit-search-results-decoration {
    -webkit-appearance: none;
  }

  .input__control:-webkit-autofill,
  .input__control:-webkit-autofill:hover,
  .input__control:-webkit-autofill:focus,
  .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-background-color-hover) inset !important;
    -webkit-text-fill-color: var(--sl-color-primary-500);
    caret-color: var(--sl-input-color);
  }

  .input--filled .input__control:-webkit-autofill,
  .input--filled .input__control:-webkit-autofill:hover,
  .input--filled .input__control:-webkit-autofill:focus,
  .input--filled .input__control:-webkit-autofill:active {
    box-shadow: 0 0 0 var(--sl-input-height-large) var(--sl-input-filled-background-color) inset !important;
  }

  .input__control::placeholder {
    color: var(--sl-input-placeholder-color);
    user-select: none;
    -webkit-user-select: none;
  }

  .input:hover:not(.input--disabled) .input__control {
    color: var(--sl-input-color-hover);
  }

  .input__control:focus {
    outline: none;
  }

  .input__prefix,
  .input__suffix {
    display: inline-flex;
    flex: 0 0 auto;
    align-items: center;
    cursor: default;
  }

  .input__prefix ::slotted(sl-icon),
  .input__suffix ::slotted(sl-icon) {
    color: var(--sl-input-icon-color);
  }

  /*
   * Size modifiers
   */

  .input--small {
    border-radius: var(--sl-input-border-radius-small);
    font-size: var(--sl-input-font-size-small);
    height: var(--sl-input-height-small);
  }

  .input--small .input__control {
    height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-small);
  }

  .input--small .input__clear,
  .input--small .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-small) * 2);
  }

  .input--small .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-small);
  }

  .input--small .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-small);
  }

  .input--medium {
    border-radius: var(--sl-input-border-radius-medium);
    font-size: var(--sl-input-font-size-medium);
    height: var(--sl-input-height-medium);
  }

  .input--medium .input__control {
    height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-medium);
  }

  .input--medium .input__clear,
  .input--medium .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-medium) * 2);
  }

  .input--medium .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-medium);
  }

  .input--medium .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-medium);
  }

  .input--large {
    border-radius: var(--sl-input-border-radius-large);
    font-size: var(--sl-input-font-size-large);
    height: var(--sl-input-height-large);
  }

  .input--large .input__control {
    height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    padding: 0 var(--sl-input-spacing-large);
  }

  .input--large .input__clear,
  .input--large .input__password-toggle {
    width: calc(1em + var(--sl-input-spacing-large) * 2);
  }

  .input--large .input__prefix ::slotted(*) {
    margin-inline-start: var(--sl-input-spacing-large);
  }

  .input--large .input__suffix ::slotted(*) {
    margin-inline-end: var(--sl-input-spacing-large);
  }

  /*
   * Pill modifier
   */

  .input--pill.input--small {
    border-radius: var(--sl-input-height-small);
  }

  .input--pill.input--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .input--pill.input--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Clearable + Password Toggle
   */

  .input__clear:not(.input__clear--visible) {
    visibility: hidden;
  }

  .input__clear,
  .input__password-toggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: inherit;
    color: var(--sl-input-icon-color);
    border: none;
    background: none;
    padding: 0;
    transition: var(--sl-transition-fast) color;
    cursor: pointer;
  }

  .input__clear:hover,
  .input__password-toggle:hover {
    color: var(--sl-input-icon-color-hover);
  }

  .input__clear:focus,
  .input__password-toggle:focus {
    outline: none;
  }

  .input--empty .input__clear {
    visibility: hidden;
  }

  /* Don't show the browser's password toggle in Edge */
  ::-ms-reveal {
    display: none;
  }

  /* Hide the built-in number spinner */
  .input--no-spin-buttons input[type='number']::-webkit-outer-spin-button,
  .input--no-spin-buttons input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    display: none;
  }

  .input--no-spin-buttons input[type='number'] {
    -moz-appearance: textfield;
  }
`;

// ../../../node_modules/.pnpm/lit-html@3.2.0/node_modules/lit-html/directives/live.js
var Ft = e5(class extends i3 {
  constructor(r6) {
    if (super(r6), r6.type !== t3.PROPERTY && r6.type !== t3.ATTRIBUTE && r6.type !== t3.BOOLEAN_ATTRIBUTE)
      throw Error("The `live` directive is not allowed on child or event bindings");
    if (!rt(r6))
      throw Error("`live` bindings can only contain a single expression");
  }
  render(r6) {
    return r6;
  }
  update(r6, [e6]) {
    if (e6 === R || e6 === D)
      return e6;
    const i4 = r6.element, n5 = r6.name;
    if (r6.type === t3.PROPERTY) {
      if (e6 === i4[n5])
        return R;
    } else if (r6.type === t3.BOOLEAN_ATTRIBUTE) {
      if (!!e6 === i4.hasAttribute(n5))
        return R;
    } else if (r6.type === t3.ATTRIBUTE && i4.getAttribute(n5) === e6 + "")
      return R;
    return dt(r6), e6;
  }
});

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.54TJVTKO.js
var SlInput = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["sl-blur", "sl-input"]
    });
    this.hasSlotController = new HasSlotController(this, "help-text", "label");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.title = "";
    this.__numberInput = Object.assign(document.createElement("input"), { type: "number" });
    this.__dateInput = Object.assign(document.createElement("input"), { type: "date" });
    this.type = "text";
    this.name = "";
    this.value = "";
    this.defaultValue = "";
    this.size = "medium";
    this.filled = false;
    this.pill = false;
    this.label = "";
    this.helpText = "";
    this.clearable = false;
    this.disabled = false;
    this.placeholder = "";
    this.readonly = false;
    this.passwordToggle = false;
    this.passwordVisible = false;
    this.noSpinButtons = false;
    this.form = "";
    this.required = false;
    this.spellcheck = true;
  }
  //
  // NOTE: We use an in-memory input for these getters/setters instead of the one in the template because the properties
  // can be set before the component is rendered.
  //
  /**
   * Gets or sets the current value as a `Date` object. Returns `null` if the value can't be converted. This will use the native `<input type="{{type}}">` implementation and may result in an error.
   */
  get valueAsDate() {
    var _a;
    this.__dateInput.type = this.type;
    this.__dateInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsDate) || this.__dateInput.valueAsDate;
  }
  set valueAsDate(newValue) {
    this.__dateInput.type = this.type;
    this.__dateInput.valueAsDate = newValue;
    this.value = this.__dateInput.value;
  }
  /** Gets or sets the current value as a number. Returns `NaN` if the value can't be converted. */
  get valueAsNumber() {
    var _a;
    this.__numberInput.value = this.value;
    return ((_a = this.input) == null ? void 0 : _a.valueAsNumber) || this.__numberInput.valueAsNumber;
  }
  set valueAsNumber(newValue) {
    this.__numberInput.valueAsNumber = newValue;
    this.value = this.__numberInput.value;
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleChange() {
    this.value = this.input.value;
    this.emit("sl-change");
  }
  handleClearClick(event) {
    this.value = "";
    this.emit("sl-clear");
    this.emit("sl-input");
    this.emit("sl-change");
    this.input.focus();
    event.stopPropagation();
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleInput() {
    this.value = this.input.value;
    this.formControlController.updateValidity();
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleKeyDown(event) {
    const hasModifier = event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;
    if (event.key === "Enter" && !hasModifier) {
      setTimeout(() => {
        if (!event.defaultPrevented && !event.isComposing) {
          this.formControlController.submit();
        }
      });
    }
  }
  handlePasswordToggle() {
    this.passwordVisible = !this.passwordVisible;
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStepChange() {
    this.input.step = String(this.step);
    this.formControlController.updateValidity();
  }
  async handleValueChange() {
    await this.updateComplete;
    this.formControlController.updateValidity();
  }
  /** Sets focus on the input. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the input. */
  blur() {
    this.input.blur();
  }
  /** Selects all the text in the input. */
  select() {
    this.input.select();
  }
  /** Sets the start and end positions of the text selection (0-based). */
  setSelectionRange(selectionStart, selectionEnd, selectionDirection = "none") {
    this.input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }
  /** Replaces a range of text with a new string. */
  setRangeText(replacement, start, end, selectMode = "preserve") {
    const selectionStart = start != null ? start : this.input.selectionStart;
    const selectionEnd = end != null ? end : this.input.selectionEnd;
    this.input.setRangeText(replacement, selectionStart, selectionEnd, selectMode);
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Displays the browser picker for an input element (only works if the browser supports it for the input type). */
  showPicker() {
    if ("showPicker" in HTMLInputElement.prototype) {
      this.input.showPicker();
    }
  }
  /** Increments the value of a numeric input type by the value of the step attribute. */
  stepUp() {
    this.input.stepUp();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Decrements the value of a numeric input type by the value of the step attribute. */
  stepDown() {
    this.input.stepDown();
    if (this.value !== this.input.value) {
      this.value = this.input.value;
    }
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasLabelSlot = this.hasSlotController.test("label");
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasLabel = this.label ? true : !!hasLabelSlot;
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    const hasClearIcon = this.clearable && !this.disabled && !this.readonly;
    const isClearIconVisible = hasClearIcon && (typeof this.value === "number" || this.value.length > 0);
    return ke`
      <div
        part="form-control"
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-label": hasLabel,
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="form-control-label"
          class="form-control__label"
          for="input"
          aria-hidden=${hasLabel ? "false" : "true"}
        >
          <slot name="label">${this.label}</slot>
        </label>

        <div part="form-control-input" class="form-control-input">
          <div
            part="base"
            class=${Rt({
      input: true,
      // Sizes
      "input--small": this.size === "small",
      "input--medium": this.size === "medium",
      "input--large": this.size === "large",
      // States
      "input--pill": this.pill,
      "input--standard": !this.filled,
      "input--filled": this.filled,
      "input--disabled": this.disabled,
      "input--focused": this.hasFocus,
      "input--empty": !this.value,
      "input--no-spin-buttons": this.noSpinButtons
    })}
          >
            <span part="prefix" class="input__prefix">
              <slot name="prefix"></slot>
            </span>

            <input
              part="input"
              id="input"
              class="input__control"
              type=${this.type === "password" && this.passwordVisible ? "text" : this.type}
              title=${this.title}
              name=${to(this.name)}
              ?disabled=${this.disabled}
              ?readonly=${this.readonly}
              ?required=${this.required}
              placeholder=${to(this.placeholder)}
              minlength=${to(this.minlength)}
              maxlength=${to(this.maxlength)}
              min=${to(this.min)}
              max=${to(this.max)}
              step=${to(this.step)}
              .value=${Ft(this.value)}
              autocapitalize=${to(this.autocapitalize)}
              autocomplete=${to(this.autocomplete)}
              autocorrect=${to(this.autocorrect)}
              ?autofocus=${this.autofocus}
              spellcheck=${this.spellcheck}
              pattern=${to(this.pattern)}
              enterkeyhint=${to(this.enterkeyhint)}
              inputmode=${to(this.inputmode)}
              aria-describedby="help-text"
              @change=${this.handleChange}
              @input=${this.handleInput}
              @invalid=${this.handleInvalid}
              @keydown=${this.handleKeyDown}
              @focus=${this.handleFocus}
              @blur=${this.handleBlur}
            />

            ${hasClearIcon ? ke`
                  <button
                    part="clear-button"
                    class=${Rt({
      input__clear: true,
      "input__clear--visible": isClearIconVisible
    })}
                    type="button"
                    aria-label=${this.localize.term("clearEntry")}
                    @click=${this.handleClearClick}
                    tabindex="-1"
                  >
                    <slot name="clear-icon">
                      <sl-icon name="x-circle-fill" library="system"></sl-icon>
                    </slot>
                  </button>
                ` : ""}
            ${this.passwordToggle && !this.disabled ? ke`
                  <button
                    part="password-toggle-button"
                    class="input__password-toggle"
                    type="button"
                    aria-label=${this.localize.term(this.passwordVisible ? "hidePassword" : "showPassword")}
                    @click=${this.handlePasswordToggle}
                    tabindex="-1"
                  >
                    ${this.passwordVisible ? ke`
                          <slot name="show-password-icon">
                            <sl-icon name="eye-slash" library="system"></sl-icon>
                          </slot>
                        ` : ke`
                          <slot name="hide-password-icon">
                            <sl-icon name="eye" library="system"></sl-icon>
                          </slot>
                        `}
                  </button>
                ` : ""}

            <span part="suffix" class="input__suffix">
              <slot name="suffix"></slot>
            </span>
          </div>
        </div>

        <div
          part="form-control-help-text"
          id="help-text"
          class="form-control__help-text"
          aria-hidden=${hasHelpText ? "false" : "true"}
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlInput.styles = [component_styles_default, form_control_styles_default, input_styles_default];
SlInput.dependencies = { "sl-icon": SlIcon };
__decorateClass2([
  e4(".input__control")
], SlInput.prototype, "input", 2);
__decorateClass2([
  r4()
], SlInput.prototype, "hasFocus", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "title", 2);
__decorateClass2([
  n4({ reflect: true })
], SlInput.prototype, "type", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "name", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "value", 2);
__decorateClass2([
  defaultValue()
], SlInput.prototype, "defaultValue", 2);
__decorateClass2([
  n4({ reflect: true })
], SlInput.prototype, "size", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "filled", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "pill", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "label", 2);
__decorateClass2([
  n4({ attribute: "help-text" })
], SlInput.prototype, "helpText", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlInput.prototype, "clearable", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "disabled", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "placeholder", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "readonly", 2);
__decorateClass2([
  n4({ attribute: "password-toggle", type: Boolean })
], SlInput.prototype, "passwordToggle", 2);
__decorateClass2([
  n4({ attribute: "password-visible", type: Boolean })
], SlInput.prototype, "passwordVisible", 2);
__decorateClass2([
  n4({ attribute: "no-spin-buttons", type: Boolean })
], SlInput.prototype, "noSpinButtons", 2);
__decorateClass2([
  n4({ reflect: true })
], SlInput.prototype, "form", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlInput.prototype, "required", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "pattern", 2);
__decorateClass2([
  n4({ type: Number })
], SlInput.prototype, "minlength", 2);
__decorateClass2([
  n4({ type: Number })
], SlInput.prototype, "maxlength", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "min", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "max", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "step", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "autocapitalize", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "autocorrect", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "autocomplete", 2);
__decorateClass2([
  n4({ type: Boolean })
], SlInput.prototype, "autofocus", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "enterkeyhint", 2);
__decorateClass2([
  n4({
    type: Boolean,
    converter: {
      // Allow "true|false" attribute values but keep the property boolean
      fromAttribute: (value) => !value || value === "false" ? false : true,
      toAttribute: (value) => value ? "true" : "false"
    }
  })
], SlInput.prototype, "spellcheck", 2);
__decorateClass2([
  n4()
], SlInput.prototype, "inputmode", 2);
__decorateClass2([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleDisabledChange", 1);
__decorateClass2([
  watch("step", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleStepChange", 1);
__decorateClass2([
  watch("value", { waitUntilFirstUpdate: true })
], SlInput.prototype, "handleValueChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.7DUCI5S4.js
var spinner_styles_default = i`
  :host {
    --track-width: 2px;
    --track-color: rgb(128 128 128 / 25%);
    --indicator-color: var(--sl-color-primary-600);
    --speed: 2s;

    display: inline-flex;
    width: 1em;
    height: 1em;
    flex: none;
  }

  .spinner {
    flex: 1 1 auto;
    height: 100%;
    width: 100%;
  }

  .spinner__track,
  .spinner__indicator {
    fill: none;
    stroke-width: var(--track-width);
    r: calc(0.5em - var(--track-width) / 2);
    cx: 0.5em;
    cy: 0.5em;
    transform-origin: 50% 50%;
  }

  .spinner__track {
    stroke: var(--track-color);
    transform-origin: 0% 0%;
  }

  .spinner__indicator {
    stroke: var(--indicator-color);
    stroke-linecap: round;
    stroke-dasharray: 150% 75%;
    animation: spin var(--speed) linear infinite;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
      stroke-dasharray: 0.05em, 3em;
    }

    50% {
      transform: rotate(450deg);
      stroke-dasharray: 1.375em, 1.375em;
    }

    100% {
      transform: rotate(1080deg);
      stroke-dasharray: 0.05em, 3em;
    }
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.TY4GUJRD.js
var SlSpinner = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.localize = new LocalizeController2(this);
  }
  render() {
    return ke`
      <svg part="base" class="spinner" role="progressbar" aria-label=${this.localize.term("loading")}>
        <circle class="spinner__track"></circle>
        <circle class="spinner__indicator"></circle>
      </svg>
    `;
  }
};
SlSpinner.styles = [component_styles_default, spinner_styles_default];

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.QPYT3OK4.js
var button_styles_default = i`
  :host {
    display: inline-block;
    position: relative;
    width: auto;
    cursor: pointer;
  }

  .button {
    display: inline-flex;
    align-items: stretch;
    justify-content: center;
    width: 100%;
    border-style: solid;
    border-width: var(--sl-input-border-width);
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-font-weight-semibold);
    text-decoration: none;
    user-select: none;
    -webkit-user-select: none;
    white-space: nowrap;
    vertical-align: middle;
    padding: 0;
    transition:
      var(--sl-transition-x-fast) background-color,
      var(--sl-transition-x-fast) color,
      var(--sl-transition-x-fast) border,
      var(--sl-transition-x-fast) box-shadow;
    cursor: inherit;
  }

  .button::-moz-focus-inner {
    border: 0;
  }

  .button:focus {
    outline: none;
  }

  .button:focus-visible {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  .button--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* When disabled, prevent mouse events from bubbling up from children */
  .button--disabled * {
    pointer-events: none;
  }

  .button__prefix,
  .button__suffix {
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    pointer-events: none;
  }

  .button__label {
    display: inline-block;
  }

  .button__label::slotted(sl-icon) {
    vertical-align: -2px;
  }

  /*
   * Standard buttons
   */

  /* Default */
  .button--standard.button--default {
    background-color: var(--sl-color-neutral-0);
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--standard.button--default:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-50);
    border-color: var(--sl-color-primary-300);
    color: var(--sl-color-primary-700);
  }

  .button--standard.button--default:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-100);
    border-color: var(--sl-color-primary-400);
    color: var(--sl-color-primary-700);
  }

  /* Primary */
  .button--standard.button--primary {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:hover:not(.button--disabled) {
    background-color: var(--sl-color-primary-500);
    border-color: var(--sl-color-primary-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--primary:active:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--standard.button--success {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:hover:not(.button--disabled) {
    background-color: var(--sl-color-success-500);
    border-color: var(--sl-color-success-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--success:active:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--standard.button--neutral {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:hover:not(.button--disabled) {
    background-color: var(--sl-color-neutral-500);
    border-color: var(--sl-color-neutral-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--neutral:active:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--standard.button--warning {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }
  .button--standard.button--warning:hover:not(.button--disabled) {
    background-color: var(--sl-color-warning-500);
    border-color: var(--sl-color-warning-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--warning:active:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--standard.button--danger {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:hover:not(.button--disabled) {
    background-color: var(--sl-color-danger-500);
    border-color: var(--sl-color-danger-500);
    color: var(--sl-color-neutral-0);
  }

  .button--standard.button--danger:active:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  /*
   * Outline buttons
   */

  .button--outline {
    background: none;
    border: solid 1px;
  }

  /* Default */
  .button--outline.button--default {
    border-color: var(--sl-color-neutral-300);
    color: var(--sl-color-neutral-700);
  }

  .button--outline.button--default:hover:not(.button--disabled),
  .button--outline.button--default.button--checked:not(.button--disabled) {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--default:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Primary */
  .button--outline.button--primary {
    border-color: var(--sl-color-primary-600);
    color: var(--sl-color-primary-600);
  }

  .button--outline.button--primary:hover:not(.button--disabled),
  .button--outline.button--primary.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-primary-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--primary:active:not(.button--disabled) {
    border-color: var(--sl-color-primary-700);
    background-color: var(--sl-color-primary-700);
    color: var(--sl-color-neutral-0);
  }

  /* Success */
  .button--outline.button--success {
    border-color: var(--sl-color-success-600);
    color: var(--sl-color-success-600);
  }

  .button--outline.button--success:hover:not(.button--disabled),
  .button--outline.button--success.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-success-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--success:active:not(.button--disabled) {
    border-color: var(--sl-color-success-700);
    background-color: var(--sl-color-success-700);
    color: var(--sl-color-neutral-0);
  }

  /* Neutral */
  .button--outline.button--neutral {
    border-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-600);
  }

  .button--outline.button--neutral:hover:not(.button--disabled),
  .button--outline.button--neutral.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-neutral-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--neutral:active:not(.button--disabled) {
    border-color: var(--sl-color-neutral-700);
    background-color: var(--sl-color-neutral-700);
    color: var(--sl-color-neutral-0);
  }

  /* Warning */
  .button--outline.button--warning {
    border-color: var(--sl-color-warning-600);
    color: var(--sl-color-warning-600);
  }

  .button--outline.button--warning:hover:not(.button--disabled),
  .button--outline.button--warning.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-warning-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--warning:active:not(.button--disabled) {
    border-color: var(--sl-color-warning-700);
    background-color: var(--sl-color-warning-700);
    color: var(--sl-color-neutral-0);
  }

  /* Danger */
  .button--outline.button--danger {
    border-color: var(--sl-color-danger-600);
    color: var(--sl-color-danger-600);
  }

  .button--outline.button--danger:hover:not(.button--disabled),
  .button--outline.button--danger.button--checked:not(.button--disabled) {
    background-color: var(--sl-color-danger-600);
    color: var(--sl-color-neutral-0);
  }

  .button--outline.button--danger:active:not(.button--disabled) {
    border-color: var(--sl-color-danger-700);
    background-color: var(--sl-color-danger-700);
    color: var(--sl-color-neutral-0);
  }

  @media (forced-colors: active) {
    .button.button--outline.button--checked:not(.button--disabled) {
      outline: solid 2px transparent;
    }
  }

  /*
   * Text buttons
   */

  .button--text {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-600);
  }

  .button--text:hover:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:focus-visible:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-500);
  }

  .button--text:active:not(.button--disabled) {
    background-color: transparent;
    border-color: transparent;
    color: var(--sl-color-primary-700);
  }

  /*
   * Size modifiers
   */

  .button--small {
    height: auto;
    min-height: var(--sl-input-height-small);
    font-size: var(--sl-button-font-size-small);
    line-height: calc(var(--sl-input-height-small) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-small);
  }

  .button--medium {
    height: auto;
    min-height: var(--sl-input-height-medium);
    font-size: var(--sl-button-font-size-medium);
    line-height: calc(var(--sl-input-height-medium) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-medium);
  }

  .button--large {
    height: auto;
    min-height: var(--sl-input-height-large);
    font-size: var(--sl-button-font-size-large);
    line-height: calc(var(--sl-input-height-large) - var(--sl-input-border-width) * 2);
    border-radius: var(--sl-input-border-radius-large);
  }

  /*
   * Pill modifier
   */

  .button--pill.button--small {
    border-radius: var(--sl-input-height-small);
  }

  .button--pill.button--medium {
    border-radius: var(--sl-input-height-medium);
  }

  .button--pill.button--large {
    border-radius: var(--sl-input-height-large);
  }

  /*
   * Circle modifier
   */

  .button--circle {
    padding-left: 0;
    padding-right: 0;
  }

  .button--circle.button--small {
    width: var(--sl-input-height-small);
    border-radius: 50%;
  }

  .button--circle.button--medium {
    width: var(--sl-input-height-medium);
    border-radius: 50%;
  }

  .button--circle.button--large {
    width: var(--sl-input-height-large);
    border-radius: 50%;
  }

  .button--circle .button__prefix,
  .button--circle .button__suffix,
  .button--circle .button__caret {
    display: none;
  }

  /*
   * Caret modifier
   */

  .button--caret .button__suffix {
    display: none;
  }

  .button--caret .button__caret {
    height: auto;
  }

  /*
   * Loading modifier
   */

  .button--loading {
    position: relative;
    cursor: wait;
  }

  .button--loading .button__prefix,
  .button--loading .button__label,
  .button--loading .button__suffix,
  .button--loading .button__caret {
    visibility: hidden;
  }

  .button--loading sl-spinner {
    --indicator-color: currentColor;
    position: absolute;
    font-size: 1em;
    height: 1em;
    width: 1em;
    top: calc(50% - 0.5em);
    left: calc(50% - 0.5em);
  }

  /*
   * Badges
   */

  .button ::slotted(sl-badge) {
    position: absolute;
    top: 0;
    right: 0;
    translate: 50% -50%;
    pointer-events: none;
  }

  .button--rtl ::slotted(sl-badge) {
    right: auto;
    left: 0;
    translate: -50% -50%;
  }

  /*
   * Button spacing
   */

  .button--has-label.button--small .button__label {
    padding: 0 var(--sl-spacing-small);
  }

  .button--has-label.button--medium .button__label {
    padding: 0 var(--sl-spacing-medium);
  }

  .button--has-label.button--large .button__label {
    padding: 0 var(--sl-spacing-large);
  }

  .button--has-prefix.button--small {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--small .button__label {
    padding-inline-start: var(--sl-spacing-x-small);
  }

  .button--has-prefix.button--medium {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--medium .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-prefix.button--large .button__label {
    padding-inline-start: var(--sl-spacing-small);
  }

  .button--has-suffix.button--small,
  .button--caret.button--small {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--small .button__label,
  .button--caret.button--small .button__label {
    padding-inline-end: var(--sl-spacing-x-small);
  }

  .button--has-suffix.button--medium,
  .button--caret.button--medium {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--medium .button__label,
  .button--caret.button--medium .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large,
  .button--caret.button--large {
    padding-inline-end: var(--sl-spacing-small);
  }

  .button--has-suffix.button--large .button__label,
  .button--caret.button--large .button__label {
    padding-inline-end: var(--sl-spacing-small);
  }

  /*
   * Button groups support a variety of button types (e.g. buttons with tooltips, buttons as dropdown triggers, etc.).
   * This means buttons aren't always direct descendants of the button group, thus we can't target them with the
   * ::slotted selector. To work around this, the button group component does some magic to add these special classes to
   * buttons and we style them here instead.
   */

  :host(.sl-button-group__button--first:not(.sl-button-group__button--last)) .button {
    border-start-end-radius: 0;
    border-end-end-radius: 0;
  }

  :host(.sl-button-group__button--inner) .button {
    border-radius: 0;
  }

  :host(.sl-button-group__button--last:not(.sl-button-group__button--first)) .button {
    border-start-start-radius: 0;
    border-end-start-radius: 0;
  }

  /* All except the first */
  :host(.sl-button-group__button:not(.sl-button-group__button--first)) {
    margin-inline-start: calc(-1 * var(--sl-input-border-width));
  }

  /* Add a visual separator between solid buttons */
  :host(
      .sl-button-group__button:not(
          .sl-button-group__button--first,
          .sl-button-group__button--radio,
          [variant='default']
        ):not(:hover)
    )
    .button:after {
    content: '';
    position: absolute;
    top: 0;
    inset-inline-start: 0;
    bottom: 0;
    border-left: solid 1px rgb(128 128 128 / 33%);
    mix-blend-mode: multiply;
  }

  /* Bump hovered, focused, and checked buttons up so their focus ring isn't clipped */
  :host(.sl-button-group__button--hover) {
    z-index: 1;
  }

  /* Focus and checked are always on top */
  :host(.sl-button-group__button--focus),
  :host(.sl-button-group__button[checked]) {
    z-index: 2;
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.64QWL6LI.js
var SlButton = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      assumeInteractionOn: ["click"]
    });
    this.hasSlotController = new HasSlotController(this, "[default]", "prefix", "suffix");
    this.localize = new LocalizeController2(this);
    this.hasFocus = false;
    this.invalid = false;
    this.title = "";
    this.variant = "default";
    this.size = "medium";
    this.caret = false;
    this.disabled = false;
    this.loading = false;
    this.outline = false;
    this.pill = false;
    this.circle = false;
    this.type = "button";
    this.name = "";
    this.value = "";
    this.href = "";
    this.rel = "noreferrer noopener";
  }
  /** Gets the validity state object */
  get validity() {
    if (this.isButton()) {
      return this.button.validity;
    }
    return validValidityState;
  }
  /** Gets the validation message */
  get validationMessage() {
    if (this.isButton()) {
      return this.button.validationMessage;
    }
    return "";
  }
  firstUpdated() {
    if (this.isButton()) {
      this.formControlController.updateValidity();
    }
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleClick() {
    if (this.type === "submit") {
      this.formControlController.submit(this);
    }
    if (this.type === "reset") {
      this.formControlController.reset(this);
    }
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  isButton() {
    return this.href ? false : true;
  }
  isLink() {
    return this.href ? true : false;
  }
  handleDisabledChange() {
    if (this.isButton()) {
      this.formControlController.setValidity(this.disabled);
    }
  }
  /** Simulates a click on the button. */
  click() {
    this.button.click();
  }
  /** Sets focus on the button. */
  focus(options) {
    this.button.focus(options);
  }
  /** Removes focus from the button. */
  blur() {
    this.button.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    if (this.isButton()) {
      return this.button.checkValidity();
    }
    return true;
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    if (this.isButton()) {
      return this.button.reportValidity();
    }
    return true;
  }
  /** Sets a custom validation message. Pass an empty string to restore validity. */
  setCustomValidity(message) {
    if (this.isButton()) {
      this.button.setCustomValidity(message);
      this.formControlController.updateValidity();
    }
  }
  render() {
    const isLink = this.isLink();
    const tag2 = isLink ? er`a` : er`button`;
    return ke2`
      <${tag2}
        part="base"
        class=${Rt({
      button: true,
      "button--default": this.variant === "default",
      "button--primary": this.variant === "primary",
      "button--success": this.variant === "success",
      "button--neutral": this.variant === "neutral",
      "button--warning": this.variant === "warning",
      "button--danger": this.variant === "danger",
      "button--text": this.variant === "text",
      "button--small": this.size === "small",
      "button--medium": this.size === "medium",
      "button--large": this.size === "large",
      "button--caret": this.caret,
      "button--circle": this.circle,
      "button--disabled": this.disabled,
      "button--focused": this.hasFocus,
      "button--loading": this.loading,
      "button--standard": !this.outline,
      "button--outline": this.outline,
      "button--pill": this.pill,
      "button--rtl": this.localize.dir() === "rtl",
      "button--has-label": this.hasSlotController.test("[default]"),
      "button--has-prefix": this.hasSlotController.test("prefix"),
      "button--has-suffix": this.hasSlotController.test("suffix")
    })}
        ?disabled=${to(isLink ? void 0 : this.disabled)}
        type=${to(isLink ? void 0 : this.type)}
        title=${this.title}
        name=${to(isLink ? void 0 : this.name)}
        value=${to(isLink ? void 0 : this.value)}
        href=${to(isLink ? this.href : void 0)}
        target=${to(isLink ? this.target : void 0)}
        download=${to(isLink ? this.download : void 0)}
        rel=${to(isLink ? this.rel : void 0)}
        role=${to(isLink ? void 0 : "button")}
        aria-disabled=${this.disabled ? "true" : "false"}
        tabindex=${this.disabled ? "-1" : "0"}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @invalid=${this.isButton() ? this.handleInvalid : null}
        @click=${this.handleClick}
      >
        <slot name="prefix" part="prefix" class="button__prefix"></slot>
        <slot part="label" class="button__label"></slot>
        <slot name="suffix" part="suffix" class="button__suffix"></slot>
        ${this.caret ? ke2` <sl-icon part="caret" class="button__caret" library="system" name="caret"></sl-icon> ` : ""}
        ${this.loading ? ke2`<sl-spinner part="spinner"></sl-spinner>` : ""}
      </${tag2}>
    `;
  }
};
SlButton.styles = [component_styles_default, button_styles_default];
SlButton.dependencies = {
  "sl-icon": SlIcon,
  "sl-spinner": SlSpinner
};
__decorateClass2([
  e4(".button")
], SlButton.prototype, "button", 2);
__decorateClass2([
  r4()
], SlButton.prototype, "hasFocus", 2);
__decorateClass2([
  r4()
], SlButton.prototype, "invalid", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "title", 2);
__decorateClass2([
  n4({ reflect: true })
], SlButton.prototype, "variant", 2);
__decorateClass2([
  n4({ reflect: true })
], SlButton.prototype, "size", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "caret", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "disabled", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "loading", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "outline", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "pill", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlButton.prototype, "circle", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "type", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "name", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "value", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "href", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "target", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "rel", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "download", 2);
__decorateClass2([
  n4()
], SlButton.prototype, "form", 2);
__decorateClass2([
  n4({ attribute: "formaction" })
], SlButton.prototype, "formAction", 2);
__decorateClass2([
  n4({ attribute: "formenctype" })
], SlButton.prototype, "formEnctype", 2);
__decorateClass2([
  n4({ attribute: "formmethod" })
], SlButton.prototype, "formMethod", 2);
__decorateClass2([
  n4({ attribute: "formnovalidate", type: Boolean })
], SlButton.prototype, "formNoValidate", 2);
__decorateClass2([
  n4({ attribute: "formtarget" })
], SlButton.prototype, "formTarget", 2);
__decorateClass2([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlButton.prototype, "handleDisabledChange", 1);

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.W7K6OMDR.js
var checkbox_styles_default = i`
  :host {
    display: inline-block;
  }

  .checkbox {
    position: relative;
    display: inline-flex;
    align-items: flex-start;
    font-family: var(--sl-input-font-family);
    font-weight: var(--sl-input-font-weight);
    color: var(--sl-input-label-color);
    vertical-align: middle;
    cursor: pointer;
  }

  .checkbox--small {
    --toggle-size: var(--sl-toggle-size-small);
    font-size: var(--sl-input-font-size-small);
  }

  .checkbox--medium {
    --toggle-size: var(--sl-toggle-size-medium);
    font-size: var(--sl-input-font-size-medium);
  }

  .checkbox--large {
    --toggle-size: var(--sl-toggle-size-large);
    font-size: var(--sl-input-font-size-large);
  }

  .checkbox__control {
    flex: 0 0 auto;
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--toggle-size);
    height: var(--toggle-size);
    border: solid var(--sl-input-border-width) var(--sl-input-border-color);
    border-radius: 2px;
    background-color: var(--sl-input-background-color);
    color: var(--sl-color-neutral-0);
    transition:
      var(--sl-transition-fast) border-color,
      var(--sl-transition-fast) background-color,
      var(--sl-transition-fast) color,
      var(--sl-transition-fast) box-shadow;
  }

  .checkbox__input {
    position: absolute;
    opacity: 0;
    padding: 0;
    margin: 0;
    pointer-events: none;
  }

  .checkbox__checked-icon,
  .checkbox__indeterminate-icon {
    display: inline-flex;
    width: var(--toggle-size);
    height: var(--toggle-size);
  }

  /* Hover */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-input-border-color-hover);
    background-color: var(--sl-input-background-color-hover);
  }

  /* Focus */
  .checkbox:not(.checkbox--checked):not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Checked/indeterminate */
  .checkbox--checked .checkbox__control,
  .checkbox--indeterminate .checkbox__control {
    border-color: var(--sl-color-primary-600);
    background-color: var(--sl-color-primary-600);
  }

  /* Checked/indeterminate + hover */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__control:hover,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__control:hover {
    border-color: var(--sl-color-primary-500);
    background-color: var(--sl-color-primary-500);
  }

  /* Checked/indeterminate + focus */
  .checkbox.checkbox--checked:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control,
  .checkbox.checkbox--indeterminate:not(.checkbox--disabled) .checkbox__input:focus-visible ~ .checkbox__control {
    outline: var(--sl-focus-ring);
    outline-offset: var(--sl-focus-ring-offset);
  }

  /* Disabled */
  .checkbox--disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .checkbox__label {
    display: inline-block;
    color: var(--sl-input-label-color);
    line-height: var(--toggle-size);
    margin-inline-start: 0.5em;
    user-select: none;
    -webkit-user-select: none;
  }

  :host([required]) .checkbox__label::after {
    content: var(--sl-input-required-content);
    margin-inline-start: var(--sl-input-required-content-offset);
  }
`;

// ../../../node_modules/.pnpm/@shoelace-style+shoelace@2.14.0_@types+react@18.3.3/node_modules/@shoelace-style/shoelace/dist/chunks/chunk.FHOQLXTU.js
var SlCheckbox = class extends ShoelaceElement {
  constructor() {
    super(...arguments);
    this.formControlController = new FormControlController(this, {
      value: (control) => control.checked ? control.value || "on" : void 0,
      defaultValue: (control) => control.defaultChecked,
      setValue: (control, checked) => control.checked = checked
    });
    this.hasSlotController = new HasSlotController(this, "help-text");
    this.hasFocus = false;
    this.title = "";
    this.name = "";
    this.size = "medium";
    this.disabled = false;
    this.checked = false;
    this.indeterminate = false;
    this.defaultChecked = false;
    this.form = "";
    this.required = false;
    this.helpText = "";
  }
  /** Gets the validity state object */
  get validity() {
    return this.input.validity;
  }
  /** Gets the validation message */
  get validationMessage() {
    return this.input.validationMessage;
  }
  firstUpdated() {
    this.formControlController.updateValidity();
  }
  handleClick() {
    this.checked = !this.checked;
    this.indeterminate = false;
    this.emit("sl-change");
  }
  handleBlur() {
    this.hasFocus = false;
    this.emit("sl-blur");
  }
  handleInput() {
    this.emit("sl-input");
  }
  handleInvalid(event) {
    this.formControlController.setValidity(false);
    this.formControlController.emitInvalidEvent(event);
  }
  handleFocus() {
    this.hasFocus = true;
    this.emit("sl-focus");
  }
  handleDisabledChange() {
    this.formControlController.setValidity(this.disabled);
  }
  handleStateChange() {
    this.input.checked = this.checked;
    this.input.indeterminate = this.indeterminate;
    this.formControlController.updateValidity();
  }
  /** Simulates a click on the checkbox. */
  click() {
    this.input.click();
  }
  /** Sets focus on the checkbox. */
  focus(options) {
    this.input.focus(options);
  }
  /** Removes focus from the checkbox. */
  blur() {
    this.input.blur();
  }
  /** Checks for validity but does not show a validation message. Returns `true` when valid and `false` when invalid. */
  checkValidity() {
    return this.input.checkValidity();
  }
  /** Gets the associated form, if one exists. */
  getForm() {
    return this.formControlController.getForm();
  }
  /** Checks for validity and shows the browser's validation message if the control is invalid. */
  reportValidity() {
    return this.input.reportValidity();
  }
  /**
   * Sets a custom validation message. The value provided will be shown to the user when the form is submitted. To clear
   * the custom validation message, call this method with an empty string.
   */
  setCustomValidity(message) {
    this.input.setCustomValidity(message);
    this.formControlController.updateValidity();
  }
  render() {
    const hasHelpTextSlot = this.hasSlotController.test("help-text");
    const hasHelpText = this.helpText ? true : !!hasHelpTextSlot;
    return ke`
      <div
        class=${Rt({
      "form-control": true,
      "form-control--small": this.size === "small",
      "form-control--medium": this.size === "medium",
      "form-control--large": this.size === "large",
      "form-control--has-help-text": hasHelpText
    })}
      >
        <label
          part="base"
          class=${Rt({
      checkbox: true,
      "checkbox--checked": this.checked,
      "checkbox--disabled": this.disabled,
      "checkbox--focused": this.hasFocus,
      "checkbox--indeterminate": this.indeterminate,
      "checkbox--small": this.size === "small",
      "checkbox--medium": this.size === "medium",
      "checkbox--large": this.size === "large"
    })}
        >
          <input
            class="checkbox__input"
            type="checkbox"
            title=${this.title}
            name=${this.name}
            value=${to(this.value)}
            .indeterminate=${Ft(this.indeterminate)}
            .checked=${Ft(this.checked)}
            .disabled=${this.disabled}
            .required=${this.required}
            aria-checked=${this.checked ? "true" : "false"}
            aria-describedby="help-text"
            @click=${this.handleClick}
            @input=${this.handleInput}
            @invalid=${this.handleInvalid}
            @blur=${this.handleBlur}
            @focus=${this.handleFocus}
          />

          <span
            part="control${this.checked ? " control--checked" : ""}${this.indeterminate ? " control--indeterminate" : ""}"
            class="checkbox__control"
          >
            ${this.checked ? ke`
                  <sl-icon part="checked-icon" class="checkbox__checked-icon" library="system" name="check"></sl-icon>
                ` : ""}
            ${!this.checked && this.indeterminate ? ke`
                  <sl-icon
                    part="indeterminate-icon"
                    class="checkbox__indeterminate-icon"
                    library="system"
                    name="indeterminate"
                  ></sl-icon>
                ` : ""}
          </span>

          <div part="label" class="checkbox__label">
            <slot></slot>
          </div>
        </label>

        <div
          aria-hidden=${hasHelpText ? "false" : "true"}
          class="form-control__help-text"
          id="help-text"
          part="form-control-help-text"
        >
          <slot name="help-text">${this.helpText}</slot>
        </div>
      </div>
    `;
  }
};
SlCheckbox.styles = [component_styles_default, checkbox_styles_default];
SlCheckbox.dependencies = { "sl-icon": SlIcon };
__decorateClass2([
  e4('input[type="checkbox"]')
], SlCheckbox.prototype, "input", 2);
__decorateClass2([
  r4()
], SlCheckbox.prototype, "hasFocus", 2);
__decorateClass2([
  n4()
], SlCheckbox.prototype, "title", 2);
__decorateClass2([
  n4()
], SlCheckbox.prototype, "name", 2);
__decorateClass2([
  n4()
], SlCheckbox.prototype, "value", 2);
__decorateClass2([
  n4({ reflect: true })
], SlCheckbox.prototype, "size", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "disabled", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "checked", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "indeterminate", 2);
__decorateClass2([
  defaultValue("checked")
], SlCheckbox.prototype, "defaultChecked", 2);
__decorateClass2([
  n4({ reflect: true })
], SlCheckbox.prototype, "form", 2);
__decorateClass2([
  n4({ type: Boolean, reflect: true })
], SlCheckbox.prototype, "required", 2);
__decorateClass2([
  n4({ attribute: "help-text" })
], SlCheckbox.prototype, "helpText", 2);
__decorateClass2([
  watch("disabled", { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleDisabledChange", 1);
__decorateClass2([
  watch(["checked", "indeterminate"], { waitUntilFirstUpdate: true })
], SlCheckbox.prototype, "handleStateChange", 1);

// src/stories/inlang-settings.ts
if (!customElements.get("sl-select"))
  customElements.define("sl-select", SlSelect);
if (!customElements.get("sl-option"))
  customElements.define("sl-option", SlOption);
if (!customElements.get("sl-input"))
  customElements.define("sl-input", SlInput);
if (!customElements.get("sl-button"))
  customElements.define("sl-button", SlButton);
if (!customElements.get("sl-checkbox"))
  customElements.define("sl-checkbox", SlCheckbox);
var InlangSettings = class extends h3 {
  constructor() {
    super(...arguments);
    this.settings = {};
    this.installedPlugins = [];
    this.installedMessageLintRules = [];
    this._newSettings = void 0;
    this._unsavedChanges = false;
    this.handleInlangProjectChange = (value, property, moduleId) => {
      if (this._newSettings && moduleId) {
        this._newSettings = {
          ...this._newSettings,
          [moduleId]: {
            ...this._newSettings[moduleId],
            [property]: value
          }
        };
      } else if (this._newSettings) {
        this._newSettings = {
          ...this._newSettings,
          [property]: value
        };
      }
      if (JSON.stringify(this.settings) !== JSON.stringify(this._newSettings)) {
        this._unsavedChanges = true;
      } else {
        this._unsavedChanges = false;
      }
    };
    this._revertChanges = () => {
      if (this.settings) {
        this._newSettings = JSON.parse(JSON.stringify(this.settings));
      }
      this._unsavedChanges = false;
    };
    this._saveChanges = () => {
      if (this._newSettings) {
        this.dispatchOnSetSettings(this._newSettings);
        this.settings = JSON.parse(JSON.stringify(this._newSettings));
      }
      this._unsavedChanges = false;
    };
  }
  dispatchOnSetSettings(settings) {
    const onSetSettings = new CustomEvent("set-settings", {
      detail: {
        argument: settings
      }
    });
    this.dispatchEvent(onSetSettings);
  }
  async firstUpdated() {
    await this.updateComplete;
    if (this.settings) {
      this._newSettings = JSON.parse(JSON.stringify(this.settings));
    }
    overridePrimitiveColors_default();
  }
  get _settingProperties() {
    const _settings = this.settings;
    const _installedPlugins = this.installedPlugins;
    const _installedMessageLintRules = this.installedMessageLintRules;
    if (!_settings)
      throw new Error("No inlang settings");
    if (!_installedPlugins)
      throw new Error("No installed plugins");
    const generalSchema = { internal: { schema: ProjectSettings.allOf[0] } };
    for (const plugin of _installedPlugins) {
      if (plugin.settingsSchema) {
        generalSchema[plugin.id] = {
          schema: plugin.settingsSchema,
          meta: plugin
        };
      }
    }
    for (const lintRule of _installedMessageLintRules) {
      if (lintRule.settingsSchema) {
        generalSchema[lintRule.id] = {
          schema: lintRule.settingsSchema,
          meta: lintRule
        };
      }
    }
    return generalSchema;
  }
  render() {
    return ke` <div class="container" part="base">
			${Object.entries(this._settingProperties).map(([key, value]) => {
      const item = registry.find((item2) => item2.id === value.meta?.id);
      return value.schema?.properties && this._newSettings ? ke`<div class="module-container" part="module">
							${value.meta && (value.meta?.displayName).en && item && ke`<div>
								<h2 part="module-title">
									${value.meta && (value.meta?.displayName).en}
								</h2>
								<div class="module-link-container">
									<svg width="24" height="24" fill="none" viewBox="0 0 24 24">
										<path
											fill="currentColor"
											d="M11 17H7c-1.383 0-2.562-.488-3.537-1.463C2.488 14.562 2.001 13.383 2 12c0-1.383.487-2.562 1.463-3.537C4.439 7.488 5.618 7 7 7h4v2H7c-.833 0-1.542.292-2.125.875A2.893 2.893 0 004 12c0 .833.292 1.542.875 2.125A2.893 2.893 0 007 15h4v2zm-3-4v-2h8v2H8zm5 4v-2h4c.833 0 1.542-.292 2.125-.875A2.893 2.893 0 0020 12c0-.833-.292-1.542-.875-2.125A2.893 2.893 0 0017 9h-4V7h4c1.383 0 2.563.488 3.538 1.463.975.975 1.463 2.154 1.462 3.537 0 1.383-.488 2.562-1.463 3.538-.975.976-2.154 1.463-3.537 1.462h-4z"
										></path>
									</svg>
									<a
										target="_blank"
										href=${`https://inlang.com/m/${item.uniqueID}/${item.id.replaceAll(".", "-")}`}
										class="module-link"
									>
										${`https://inlang.com/.../${item.id.replaceAll(".", "-")}`}
									</a>
									<div class="module-type">
										${value.meta.id.startsWith("plugin") ? "Plugin" : "Lint Rule"}
									</div>
								</div>
							</div>`}
							${Object.entries(value.schema.properties).map(([property, schema2]) => {
        if (property === "$schema" || property === "modules")
          return void 0;
        return key === "internal" ? ke`
											<general-input
												exportparts="property, property-title, property-paragraph, option, option-wrapper, button"
												.property=${property}
												.modules=${this.installedMessageLintRules || []}
												.value=${structuredClone(
          this._newSettings?.[property]
        )}
												.schema=${schema2}
												.handleInlangProjectChange=${this.handleInlangProjectChange}
												.required=${checkRequired_default(value.schema, property)}
											></general-input>
									  ` : ke`
											<general-input
												exportparts="property, property-title, property-paragraph, option, option-wrapper, button"
												.property=${property}
												.value=${// @ts-ignore
        structuredClone(this._newSettings?.[key]?.[property])}
												.schema=${schema2}
												.moduleId=${key}
												.handleInlangProjectChange=${this.handleInlangProjectChange}
												.required=${checkRequired_default(value.schema, property)}
											></general-input>
									  `;
      })}
					  </div>` : void 0;
    })}
			${this._unsavedChanges ? ke`<div class="hover-bar-container">
						<div class="hover-bar" part="float">
							<p class="hover-bar-text">Attention, you have unsaved changes.</p>
							<div>
								<sl-button
									exportparts="base:button"
									size="small"
									@click=${() => {
      this._revertChanges();
    }}
									varaint="default"
								>
									Cancel
								</sl-button>
								<sl-button
									size="small"
									@click=${() => {
      this._saveChanges();
    }}
									variant="primary"
								>
									Save Changes
								</sl-button>
							</div>
						</div>
				  </div>` : ke``}
		</div>`;
  }
};
InlangSettings.styles = [
  baseStyling,
  i`
			h2 {
				margin: 0;
				padding-top: 1rem;
			}
			.container {
				position: relative;
				display: flex;
				flex-direction: column;
				gap: 48px;
			}
			.module-container {
				display: flex;
				flex-direction: column;
				gap: 40px;
			}
			.hover-bar-container {
				width: 100%;
				box-sizing: border-box;
				position: sticky;
				bottom: 1rem;
			}
			.hover-bar {
				box-sizing: border-box;
				width: 100%;
				max-width: 500px;
				padding-top: 0.5rem;
				padding-bottom: 0.5rem;
				margin: 0 auto;
				display: flex;
				flex-wrap: wrap;
				justify-content: space-between;
				align-items: center;
				gap: 8px;
				background-color: var(--sl-panel-background-color);
				padding-left: 1rem;
				padding-right: 0.8rem;
				border-radius: 0.5rem;
				border: 1px solid var(--sl-panel-border-color);
				filter: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));
				font-weight: 600;
				line-height: 1.5;
				font-size: 14px;
			}
			.hover-bar-text {
				margin: 0;
			}
			.module-link-container {
				display: flex;
				color: var(--sl-input-help-text-color);
				gap: 6px;
				padding-top: 0.5rem;
			}
			.module-link {
				margin: 0;
				font-size: 14px;
				line-height: 1.5;
				flex-grow: 1;
				text-decoration: none;
				color: var(--sl-input-help-text-color);
			}
			.module-link:hover {
				color: var(--sl-color-primary-600);
			}
			.module-type {
				background-color: var(--sl-input-background-color-disabled);
				width: fit-content;
				padding: 0px 6px;
				border-radius: 2px;
				font-size: 14px;
				display: flex;
				align-items: center;
				justify-content: center;
				color: var(--sl-input-color-disabled);
				margin: 0;
				line-height: 1.5;
				flex-grow: 0;
			}
		`
];
__decorateClass([
  n4({ type: Object })
], InlangSettings.prototype, "settings", 2);
__decorateClass([
  n4({ type: Array })
], InlangSettings.prototype, "installedPlugins", 2);
__decorateClass([
  n4({ type: Array })
], InlangSettings.prototype, "installedMessageLintRules", 2);
__decorateClass([
  r4()
], InlangSettings.prototype, "_newSettings", 2);
__decorateClass([
  r4()
], InlangSettings.prototype, "_unsavedChanges", 2);
InlangSettings = __decorateClass([
  t2("inlang-settings")
], InlangSettings);
export {
  InlangSettings
};
//! Do not edit this file manually. It is automatically generated based on the contents of the registry.json file.
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

crc-32/crc32.js:
  (*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/static.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
