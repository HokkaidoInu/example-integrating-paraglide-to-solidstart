import { describe, it, expect } from "vitest"
import { compile } from "./compile.js"
import { createBundle, MessageNested } from "@inlang/sdk2"

const msg: MessageNested = {
	locale: "en",
	bundleId: "happy_elephant_bundle",
	id: "some_message",
	declarations: [
		{
			type: "input",
			name: "fistInput",
			value: { type: "expression", arg: { type: "variable", name: "fistInput" } },
		},
		{
			type: "input",
			name: "secondInput",
			value: { type: "expression", arg: { type: "variable", name: "second Input" } },
		},
	],
	selectors: [
		{ type: "expression", arg: { type: "variable", name: "fistInput" } },
		{
			type: "expression",
			arg: { type: "variable", name: "second Input" },
			annotation: { type: "function", name: "plural", options: [] },
		},
	],
	variants: [
		{
			id: "1",
			messageId: "some_message",
			match: ["1", "2"],
			pattern: [{ type: "text", value: "One" }],
		},
		{
			id: "2",
			messageId: "some_message",
			match: ["*", "*"],
			pattern: [{ type: "text", value: "Many" }],
		},
	],
}

const germanMessage: MessageNested = {
	id: "some_message_de",
	locale: "de",
	bundleId: "happy_elephant_bundle",
	declarations: [],
	selectors: [],
	variants: [
		{
			id: "some_variant",
			match: [],
			messageId: "some_message_de",
			pattern: [{ type: "text", value: "Hallo Welt!" }],
		},
	],
}

describe("compile", () => {
	it("compiles", async () => {
		const bundleId = "happy_elephant_bundle"
		const bundle = createBundle({
			id: bundleId,
			alias: {
				"inlang-messageformat": "bundle_alias",
			},
			messages: [msg, germanMessage],
		})

		const output = await compile({
			bundles: [bundle],
			settings: {
				baseLocale: "en",
				locales: ["en", "de"],
			},
			projectId: undefined,
		})

		expect(output).toMatchInlineSnapshot(`
			{
			  ".gitignore": "# ignore everything because the directory is auto-generated by inlang paraglide-js
			# for more info visit https://inlang.com/m/gerre34r/paraglide-js
			*
			",
			  ".prettierignore": "# ignore everything because the directory is auto-generated by inlang paraglide-js
			# for more info visit https://inlang.com/m/gerre34r/paraglide-js
			*
			",
			  "messages.js": "/* eslint-disable */
			import { languageTag } from './runtime.js';
			import * as en from './messages/en.js';
			import * as de from './messages/de.js';

			/**
			 * This message has been compiled by [inlang
			 * paraglide](https://inlang.com/m/gerre34r/library-inlang-paraglideJs).
			 *
			 * - Don't edit the message's code. Use [Sherlock (VS Code
			 *   extension)](https://inlang.com/m/r7kp499g/app-inlang-ideExtension),
			 *   [Fink](https://inlang.com/m/tdozzpar/app-inlang-finkLocalizationEditor)
			 *   instead, or edit the translation files manually.
			 *
			 * @param {{ 'second Input': number }} inputs
			 * @param {{ languageTag?: 'en' | 'de' }} options
			 * @returns {string}
			 */
			/* @__NO_SIDE_EFFECTS__ */
			export const happy_elephant_bundle = (inputs, options = {}) => {
			  return {
			    de: de.happy_elephant_bundle,
			    en: en.happy_elephant_bundle,
			  }[options.languageTag ?? languageTag()](inputs);
			};
			/**
			 * Change the reference from the alias \`m.undefined()\` to
			 * \`m.happy_elephant_bundle()\`:
			 *
			 * \`\`\`diff
			 * -m.bundle_alias() + m.happy_elephant_bundle();
			 * \`\`\`
			 *
			 * \`bundle_alias\` is an alias for the message \`happy_elephant_bundle\`.
			 * Referencing aliases instead of the message ID has downsides like:
			 *
			 * - The alias might be renamed in the future, breaking the code.
			 * - Constant naming convention discussions.
			 *
			 * Read more about aliases and their downsides here
			 *
			 * @deprecated Reference the MessageBundle by id \`m.happy_elephant_bundle()\`
			 *   instead
			 * @param {Parameters<typeof happy_elephant_bundle>} args
			 * @returns {ReturnType<typeof happy_elephant_bundle>}
			 * @see inlang.com/link.
			 * ---
			 */
			export const bundle_alias = (...args) => happy_elephant_bundle(...args);
			",
			  "messages/de.js": "/* eslint-disable */
			import * as registry from '../registry.js';
			/** @returns {string} */
			/* @__NO_SIDE_EFFECTS__ */
			const some_message_de = () => \`Hallo Welt!\`;
			export { some_message_de as happy_elephant_bundle };
			export { some_message_de as bundle_alias };
			",
			  "messages/en.js": "/* eslint-disable */
			import * as registry from '../registry.js';
			/**
			 * @param {{ 'second Input': number; fistInput: NonNullable<unknown> }} inputs
			 * @returns {string}
			 */
			/* @__NO_SIDE_EFFECTS__ */
			const some_message = (inputs) => {
			  const selectors = [
			    inputs.fistInput,
			    registry.plural('en', inputs['second Input']),
			  ];
			  if (selectors[0] === '1' && selectors[1] === '2') return \`One\`;
			  return \`Many\`;
			};
			export { some_message as happy_elephant_bundle };
			export { some_message as bundle_alias };
			",
			  "registry.js": "/* eslint-disable */

			/**
			 * @param {import('./runtime.js').AvailableLanguageTag} locale
			 * @param {number} input
			 * @param {object} [options]
			 * @param {'cardinal' | 'ordinal'} [options.type=\\"cardinal\\"] Default is
			 *   \`\\"cardinal\\"\`
			 * @returns {string}
			 */
			export const plural = (locale, input, options) =>
			  new Intl.PluralRules(locale, options).select(input);
			",
			  "runtime.js": "/* eslint-disable */
			/** @type {((tag: AvailableLanguageTag) => void) | undefined} */
			let _onSetLanguageTag;

			/**
			 * The project's source language tag.
			 *
			 * @example
			 *   if (newlySelectedLanguageTag === sourceLanguageTag) {
			 *     // do nothing as the source language tag is the default language
			 *     return;
			 *   }
			 */
			export const sourceLanguageTag = 'en';

			/**
			 * The project's available language tags.
			 *
			 * @example
			 *   if (availableLanguageTags.includes(userSelectedLanguageTag) === false) {
			 *     throw new Error('Language tag not available');
			 *   }
			 */
			export const availableLanguageTags = /** @type {const} */ (['en', 'de']);

			/**
			 * Get the current language tag.
			 *
			 * @example
			 *   if (languageTag() === 'de') {
			 *     console.log('Germany ðŸ‡©ðŸ‡ª');
			 *   } else if (languageTag() === 'nl') {
			 *     console.log('Netherlands ðŸ‡³ðŸ‡±');
			 *   }
			 *
			 * @type {() => AvailableLanguageTag}
			 */
			export let languageTag = () => sourceLanguageTag;

			/**
			 * Set the language tag.
			 *
			 * @example
			 *   // changing to language
			 *   setLanguageTag('en');
			 *
			 *   // passing a getter function also works.
			 *   //
			 *   // a getter function is useful for resolving a language tag
			 *   // on the server where every request has a different language tag
			 *   setLanguageTag(() => {
			 *     return request.langaugeTag;
			 *   });
			 *
			 * @param {AvailableLanguageTag | (() => AvailableLanguageTag)} tag
			 */
			export const setLanguageTag = (tag) => {
			  if (typeof tag === 'function') {
			    languageTag = enforceLanguageTag(tag);
			  } else {
			    languageTag = enforceLanguageTag(() => tag);
			  }
			  // call the callback function if it has been defined
			  if (_onSetLanguageTag !== undefined) {
			    _onSetLanguageTag(languageTag());
			  }
			};

			/**
			 * Wraps an untrusted function and enforces that it returns a language tag.
			 *
			 * @param {() => AvailableLanguageTag} unsafeLanguageTag
			 * @returns {() => AvailableLanguageTag}
			 */
			function enforceLanguageTag(unsafeLanguageTag) {
			  return () => {
			    const tag = unsafeLanguageTag();
			    if (!isAvailableLanguageTag(tag)) {
			      throw new Error(
			        \`languageTag() didn't return a valid language tag. Check your setLanguageTag call\`,
			      );
			    }
			    return tag;
			  };
			}

			/**
			 * Set the \`onSetLanguageTag()\` callback function.
			 *
			 * The function can be used to trigger client-side side-effects such as making a
			 * new request to the server with the updated language tag, or re-rendering the
			 * UI on the client (SPA apps).
			 *
			 * - Don't use this function on the server (!). Triggering a side-effect is only
			 *   useful on the client because a server-side environment doesn't need to
			 *   re-render the UI.
			 * - The \`onSetLanguageTag()\` callback can only be defined once to avoid
			 *   unexpected behavior.
			 *
			 * @example
			 *   // if you use inlang paraglide on the server, make sure
			 *   // to not call \`onSetLanguageTag()\` on the server
			 *   if (isServer === false) {
			 *     onSetLanguageTag((tag) => {
			 *       // (for example) make a new request to the
			 *       // server with the updated language tag
			 *       window.location.href = \`/\${tag}/\${window.location.pathname}\`;
			 *     });
			 *   }
			 *
			 * @param {(languageTag: AvailableLanguageTag) => void} fn
			 */
			export const onSetLanguageTag = (fn) => {
			  _onSetLanguageTag = fn;
			};

			/**
			 * Check if something is an available language tag.
			 *
			 * @example
			 *   if (isAvailableLanguageTag(params.locale)) {
			 *     setLanguageTag(params.locale);
			 *   } else {
			 *     setLanguageTag('en');
			 *   }
			 *
			 * @param {any} thing
			 * @returns {thing is AvailableLanguageTag}
			 */
			export function isAvailableLanguageTag(thing) {
			  return availableLanguageTags.includes(thing);
			}

			// ------ TYPES ------

			/**
			 * A language tag that is available in the project.
			 *
			 * @example
			 *   setLanguageTag(request.languageTag as AvailableLanguageTag)
			 *
			 * @typedef {(typeof availableLanguageTags)[number]} AvailableLanguageTag
			 */
			",
			}
		`)
	})
})
