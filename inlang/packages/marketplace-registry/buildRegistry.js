import fs from "node:fs/promises";
import { MarketplaceManifest } from "@inlang/marketplace-manifest";
import { Value } from "@sinclair/typebox/value";
import algoliasearch from "algoliasearch";
import path from "node:path";

// eslint-disable-next-line no-undef
const envVariables = process.env;

const repositoryRoot = import.meta.url.slice(
	0,
	import.meta.url.lastIndexOf("inlang/packages")
);
const manifestLinks = JSON.parse(await fs.readFile("./registry.json", "utf-8"));

/** @type {(import("@inlang/marketplace-manifest").MarketplaceManifest)[]} */
const manifests = [];

/**
 * Convert relative paths to absolute paths based on the manifest link.
 * @param {string} baseUrl - The base URL of the manifest.
 * @param {string} relativePath - The relative path to convert.
 * @returns {string} - The absolute path.
 */
function toAbsolutePath(baseUrl, relativePath) {
	if (!relativePath.startsWith("./")) {
		return relativePath;
	}
	const base = new URL(baseUrl);
	const path = new URL(relativePath, base).href;
	console.log({ baseUrl, relativePath, path });
	return new URL(relativePath, base).href;
}

for (const type of Object.keys(manifestLinks)) {
	let manifest;
	// eslint-disable-next-line no-undef
	console.info(`Fetching ${type} manifests...`);

	for (const uniqueID of Object.keys(manifestLinks[type])) {
		const link = manifestLinks[type][uniqueID];

		try {
			if (link.includes("http")) {
				manifest = JSON.parse(await fetch(link).then((res) => res.text()));
			} else {
				// eslint-disable-next-line no-undef
				manifest = JSON.parse(
					await fs.readFile(new URL(link, repositoryRoot), "utf-8")
				);
			}

			if (Value.Check(MarketplaceManifest, manifest) === false) {
				const errors = [...Value.Errors(MarketplaceManifest, manifest)];
				// eslint-disable-next-line no-undef
				console.error(errors);
				throw new Error(`Manifest is invalid.`);
			}

			// Convert relative paths to absolute paths
			if (manifest.pages) {
				for (const page in manifest.pages) {
					const isNamespace = typeof manifest.pages[page] === "object";
					if (isNamespace) {
						for (const namespace in manifest.pages[page]) {
							manifest.pages[page][namespace] = toAbsolutePath(
								link,
								manifest.pages[page][namespace]
							);
						}
					} else {
						manifest.pages[page] = toAbsolutePath(link, manifest.pages[page]);
					}
				}
			}

			if (manifest.readme) {
				if (typeof manifest.readme === "object") {
					for (const lang in manifest.readme) {
						manifest.readme[lang] = toAbsolutePath(link, manifest.readme[lang]);
					}
				} else {
					manifest.readme = toAbsolutePath(link, manifest.readme);
				}
			}

			if (manifest.gallery) {
				manifest.gallery = manifest.gallery.map((path) =>
					toAbsolutePath(link, path)
				);
			}
			if (manifest.icon) {
				manifest.icon = toAbsolutePath(link, manifest.icon);
			}

			manifests.push({
				uniqueID,
				...manifest,
			});
		} catch (e) {
			throw new Error(`Manifest '${link}' is invalid. ${e}`);
		}
	}
}

// checks if every manifest has a unique id
checkUniqueIDs(manifests);

// checks if the module links have the correct schema
checkModuleLinks(manifests);

// sort the manifests by id
manifests.sort((a, b) => {
	if (a.id.toUpperCase() < b.id.toUpperCase()) return -1;
	if (a.id.toUpperCase() > b.id.toUpperCase()) return 1;
	return 0;
});

await fs.writeFile(
	"./src/registry.ts",
	`
	//! Do not edit this file manually. It is automatically generated based on the contents of the registry.manifest file.
	
	import type { MarketplaceManifest } from "@inlang/marketplace-manifest"
	export type Registry = MarketplaceManifest & { uniqueID: string };

	export const registry: Registry[] = ${JSON.stringify(
		manifests.map((manifest) => ({ ...manifest, uniqueID: manifest.uniqueID })),
		undefined,
		"\t"
	)}`
);

// DISABLED BECAUSE TOO MUCH OVERHEAD. Need locally working search index. Screw the cloud.

// if (envVariables.DOPPLER_ENVIRONMENT === "production") {
// 	const client = algoliasearch(
// 		envVariables.ALGOLIA_APPLICATION,
// 		envVariables.ALGOLIA_ADMIN
// 	);
// 	const index = client.initIndex("registry");

// 	const objects = await Promise.all(
// 		[...manifests.values()].map(async (manifest) => {
// 			let readmeLink = undefined;
// 			if (manifest.pages) {
// 				if (manifest.pages["/"]) {
// 					readmeLink = manifest.pages["/"];
// 				} else {
// 					if (
// 						Object.values(manifest.pages).some(
// 							(namespace) => typeof namespace === "object" && namespace["/"]
// 						)
// 					) {
// 						readmeLink = Object.values(manifest.pages).find(
// 							(namespace) => typeof namespace === "object" && namespace["/"]
// 						)["/"];
// 					} else {
// 						throw new Error(`No page at "/" found for ${manifest.id}`);
// 					}
// 				}
// 			} else if (manifest.readme) {
// 				readmeLink =
// 					typeof manifest.readme === "object"
// 						? manifest.readme.en
// 						: manifest.readme;
// 			} else {
// 				throw new Error(`No readmeLink found for ${manifest.id}`);
// 			}

// 			const absolute = toAbsolutePath(readmeLink, repositoryRoot);

// 			const text = absolute.includes("http")
// 				? (await fetch(absolute)).text()
// 				: await fs.readFile(absolute, "utf-8");

// 			return { objectID: uniqueID, readme: text, ...manifest };
// 		})
// 	);

// 	await index.saveObjects(objects);
// 	console.info("Successfully uploaded registry on Algolia");
// }

/* This function checks for uniqueIDs to verify they are not duplicated */
function checkUniqueIDs(manifests) {
  const uniqueIDs = new Set();

  for (const manifest of manifests) {
    if (uniqueIDs.has(manifest.uniqueID)) {
      throw new Error(
        `Manifest with unique id '${manifest.uniqueID}' already exists.`,
      );
    }
    uniqueIDs.add(manifest.uniqueID);
  }
}

/* This function checks for the module links to have the correct schema */
function checkModuleLinks(manifests) {
  for (const manifest of manifests) {
    if (manifest.module !== undefined) {
      // should be in this schema https://cdn.jsdelivr.net/npm/PUBLISHER/NAME@latest/PATH
      if (!manifest.module.startsWith("https://cdn.jsdelivr.net/npm/")) {
        throw new Error(
          `Module link '${manifest.module}' does not start with 'https://cdn.jsdelivr.net/npm/'.`,
        );
      } else if (!manifest.module.includes("@latest")) {
        throw new Error(
          `Module link '${manifest.module}' does not include a package name.`,
        );
      }
    }
  }
}
